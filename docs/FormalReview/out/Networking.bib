
@article{vishwanathan_semantics_2021,
	title = {Semantics, Verification, and Efficient Implementations for Tristate Numbers},
	url = {http://arxiv.org/abs/2105.05398},
	abstract = {Extended Berkeley Packet Filter({BPF})is an in-kernel, register-based virtual machine in the Linux operating system that allows non-superusers to execute code at specific points within the Linux kernel. To ensure that such user code is safe within the kernel, {BPF} relies on an in-kernel static analyzer that proves properties such as bounded memory access and the absence of illegal operations. This static analyzer uses an abstract domain, which it calls tnums (tristate numbers), to over-approximate the set of values that a variable may store. This abstract domain is implemented efficiently with bitwise and arithmetic operations. This paper formalizes the semantics and various properties of tnums and provides the first proofs of soundness and precision of arithmetic and logical operations with tnums. We describe a novel sound algorithm for multiplying two tnums that is more precise and efficient (runs 55\% faster on average) than the Linux kernel's tnum multiplication.},
	journaltitle = {{arXiv}:2105.05398 [cs]},
	author = {Vishwanathan, Harishankar and Shachnai, Matan and Narayana, Srinivas and Nagarakatte, Santosh},
	urldate = {2021-05-19},
	date = {2021-05-11},
	eprinttype = {arxiv},
	eprint = {2105.05398},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/NTTDPYXY/2105.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/BBQ93GHZ/Vishwanathan et al. - 2021 - Semantics, Verification, and Efficient Implementat.pdf:application/pdf},
}

@article{burlo_monitorability_2021,
	title = {On the Monitorability of Session Types, in Theory and Practice},
	url = {http://arxiv.org/abs/2105.06291},
	abstract = {In concurrent and distributed systems, software components are expected to communicate according to predetermined protocols and {APIs} - and if a component does not observe them, the system's reliability is compromised. Furthermore, isolating and fixing protocol/{API} errors can be very difficult. Many methods have been proposed to check the correctness of communicating systems, ranging from compile-time to run-time verification; among such methods, session types have been applied for both static type-checking, and run-time monitoring. This work takes a fresh look at the run-time verification of communicating systems using session types, in theory and in practice. On the theoretical side, we develop a novel formal model of session-monitored processes; with it, we formulate and prove new results on the monitorability of session types, connecting their run-time and static verification - in terms of soundness (i.e., whether monitors only flag ill-typed processes) and completeness (i.e., whether all ill-typed processes can be flagged by a monitor). On the practical side, we show that our monitoring theory is indeed realisable: building upon our formal model, we develop a Scala toolkit for the automatic generation of session monitors. Our executable monitors can be used to instrument black-box processes written in any programming language; we assess the viability of our approach with a series of benchmarks.},
	journaltitle = {{arXiv}:2105.06291 [cs]},
	author = {Burlò, Christian Batrolo and Francalanza, Adrian and Scalas, Alceste},
	urldate = {2021-05-19},
	date = {2021-05-13},
	eprinttype = {arxiv},
	eprint = {2105.06291},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/H5SHCIGH/2105.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/WM3FZKS8/Burlò et al. - 2021 - On the Monitorability of Session Types, in Theory .pdf:application/pdf},
}

@book{paulson_inductive_2021,
	title = {The Inductive Approach to Verifying Cryptographic Protocols},
	abstract = {Informal arguments that cryptographic protocols are secure can be made rigorous using inductive definitions. The approach is based on ordinary predicate calculus and copes with infinite-state systems. Proofs are generated using Isabelle/{HOL}. The human effort required to analyze a protocol can be as little as a week or two, yielding a proof script that takes a few minutes to run. Protocols are inductively defined as sets of traces. A trace is a list of communication events, perhaps comprising many interleaved protocol runs. Protocol descriptions incorporate attacks and accidental losses. The model spy knows some private keys and can forge messages using components decrypted from previous traffic. Three protocols are analyzed below: Otway-Rees (which uses shared-key encryption), Needham-Schroeder (which uses public-key encryption), and a recursive protocol by Bull and Otway (which is of variable length). One can prove that event \$ev\$ always precedes event \$ev'\$ or that property \$P\$ holds provided \$X\$ remains secret. Properties can be proved from the viewpoint of the various principals: say, if \$A\$ receives a final message from \$B\$ then the session key it conveys is good.},
	author = {Paulson, Lawrence},
	date = {2021-05-13},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/9R63WKCD/Paulson - 2021 - The Inductive Approach to Verifying Cryptographic .pdf:application/pdf},
}

@inproceedings{csoma_escape_2014,
	location = {Chicago Illinois {USA}},
	title = {{ESCAPE}: extensible service chain prototyping environment using mininet, click, {NETCONF} and {POX}},
	isbn = {978-1-4503-2836-4},
	url = {https://dl.acm.org/doi/10.1145/2619239.2631448},
	doi = {10.1145/2619239.2631448},
	shorttitle = {{ESCAPE}},
	abstract = {Mininet is a great prototyping tool which combines existing {SDN}-related software components (e.g., Open {vSwitch}, {OpenFlow} controllers, network namespaces, cgroups) into a framework, which can automatically set up and conﬁgure customized {OpenFlow} testbeds scaling up to hundreds of nodes. Standing on the shoulders of Mininet, we implement a similar prototyping system called {ESCAPE}, which can be used to develop and test various components of the service chaining architecture. Our framework incorporates Click for implementing Virtual Network Functions ({VNF}), {NETCONF} for managing Click-based {VNFs} and {POX} for taking care of traﬃc steering. We also add our extensible Orchestrator module, which can accommodate mapping algorithms from abstract service descriptions to deployed and running service chains.},
	eventtitle = {{SIGCOMM}'14: {ACM} {SIGCOMM} 2014 Conference},
	pages = {125--126},
	booktitle = {Proceedings of the 2014 {ACM} conference on {SIGCOMM}},
	publisher = {{ACM}},
	author = {Csoma, Attila and Sonkoly, Balázs and Csikor, Levente and Németh, Felicián and Gulyas, Andràs and Tavernier, Wouter and Sahhaf, Sahel},
	urldate = {2021-02-17},
	date = {2014-08-17},
	langid = {english},
	file = {Csoma et al. - 2014 - ESCAPE extensible service chain prototyping envir.pdf:/home/fordrl/Zotero/storage/HMQJVQXX/Csoma et al. - 2014 - ESCAPE extensible service chain prototyping envir.pdf:application/pdf},
}

@inproceedings{erickson_beacon_2013,
	location = {New York, {NY}, {USA}},
	title = {The beacon openflow controller},
	isbn = {978-1-4503-2178-5},
	url = {https://doi.org/10.1145/2491185.2491189},
	doi = {10.1145/2491185.2491189},
	series = {{HotSDN} '13},
	abstract = {Beacon is a Java-based open source {OpenFlow} controller created in 2010. It has been widely used for teaching, research, and as the basis of Floodlight. This paper describes the architectural decisions and implementation that achieves three of Beacon's goals: to improve developer productivity, to provide the runtime ability to start and stop existing and new applications, and to be high performance.},
	pages = {13--18},
	booktitle = {Proceedings of the second {ACM} {SIGCOMM} workshop on Hot topics in software defined networking},
	publisher = {Association for Computing Machinery},
	author = {Erickson, David},
	urldate = {2021-02-17},
	date = {2013-08-16},
	keywords = {beacon, controller, java, openflow},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/4387MFJD/Erickson - 2013 - The beacon openflow controller.pdf:application/pdf},
}

@article{foster_languages_2013,
	title = {Languages for software-defined networks},
	volume = {51},
	issn = {1558-1896},
	doi = {10.1109/MCOM.2013.6461197},
	abstract = {Modern computer networks perform a bewildering array of tasks, from routing and traffic monitoring, to access control and server load balancing. However, managing these networks is unnecessarily complicated and error-prone, due to a heterogeneous mix of devices (e.g., routers, switches, firewalls, and middleboxes) with closed and proprietary configuration interfaces. Softwaredefined networks are poised to change this by offering a clean and open interface between networking devices and the software that controls them. In particular, many commercial switches support the {OpenFlow} protocol, and a number of campus, data center, and backbone networks have deployed the new technology. However, while {SDNs} make it possible to program the network, they does not make it easy. Today's {OpenFlow} controllers offer low-level {APIs} that mimic the underlying switch hardware. To reach {SDNs} full potential, we need to identify the right higher-level abstractions for creating (and composing) applications. In the Frenetic project, we are designing simple and intuitive abstractions for programming the three main stages of network management: monitoring network traffic, specifying and composing packet forwarding policies, and updating policies in a consistent way. Overall, these abstractions make it dramatically easier for programmers to write and reason about {SDN} applications.},
	pages = {128--134},
	number = {2},
	journaltitle = {{IEEE} Communications Magazine},
	author = {Foster, Nate and Guha, A. and Reitblatt, M. and Story, A. and Freedman, M. J. and Katta, N. P. and Monsanto, C. and Reich, J. and Rexford, J. and Schlesinger, C. and Walker, D. and Harrison, R.},
	date = {2013-02},
	note = {Conference Name: {IEEE} Communications Magazine},
	keywords = {Runtime, access control, application program interfaces, backbone networks, computer network management, computer networks, Control systems, data center, Frenetic project, high level languages, higher-level abstractions, intuitive abstractions, {IP} networks, Languages, low-level {API}, Monitoring, network management, network traffic monitoring, networking devices, {OpenFlow} controllers, {OpenFlow} protocol, packet forwarding policies, Ports (Computers), proprietary configuration interfaces, protocols, Repeaters, {SDN}, server load balancing, software radio, Software radio, software-defined networks, switch hardware, telecommunication traffic},
	file = {IEEE Xplore Abstract Record:/home/fordrl/Zotero/storage/8SXK2726/6461197.html:text/html;Submitted Version:/home/fordrl/Zotero/storage/SRC2FBZM/Foster et al. - 2013 - Languages for software-defined networks.pdf:application/pdf},
}

@book{kaur_network_2014,
	title = {Network Programmability Using {POX} Controller},
	abstract = {{POX} is a Python based open source {OpenFlow}/Software Defined Networking ({SDN}) Controller. {POX} is used for faster development and prototyping of new network applications. {POX} controller comes pre installed with the mininet virtual machine. Using {POX} controller you can turn dumb openflow devices into hub, switch, load balancer, firewall devices. The {POX} controller allows easy way to run {OpenFlow}/{SDN} experiments. {POX} can be passed different parameters according to real or experimental topologies, thus allowing you to run experiments on real hardware, testbeds or in mininet emulator. In this paper, first section will contain introduction about {POX}, {OpenFlow} and {SDN}, then discussion about relationship between {POX} and Mininet. Final Sections will be regarding creating and verifying behavior of network applications in {POX}.},
	author = {Kaur, Sukhveer and Singh, Japinder and Ghumman, Navtej},
	date = {2014-08-24},
	doi = {10.13140/RG.2.1.1950.6961},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/SLBE6NSW/Kaur et al. - 2014 - Network Programmability Using POX Controller.pdf:application/pdf},
}

@article{reich_modular_2013,
	title = {Modular {SDN} Programming with Pyretic},
	volume = {38},
	pages = {8},
	number = {5},
	author = {Reich, Joshua and Monsanto, Christopher and Foster, Nate and Rexford, Jennifer and Walker, David},
	date = {2013},
	langid = {english},
	file = {Reich et al. - 2013 - Modular SDN Programming with Pyretic.pdf:/home/fordrl/Zotero/storage/TPBTZ5JM/Reich et al. - 2013 - Modular SDN Programming with Pyretic.pdf:application/pdf},
}

@inproceedings{foster_frenetic_2010,
	location = {New York, {NY}, {USA}},
	title = {Frenetic: a high-level language for {OpenFlow} networks},
	isbn = {978-1-4503-0467-2},
	url = {https://doi.org/10.1145/1921151.1921160},
	doi = {10.1145/1921151.1921160},
	series = {{PRESTO} '10},
	shorttitle = {Frenetic},
	abstract = {Most interfaces for programming network devices are defined at the low level of abstraction supported by the underlying hardware, which leads to complicated programs that are prone to errors. This paper proposes a high-level programming language for {OpenFlow} networks based on ideas originally developed in the functional programming community. Our language, called Frenetic, includes a rich pattern algebra for classifying packets, a "program like you see every packet" abstraction, and a run-time system that automatically generates the low-level packet-processing rules. We describe the design and implementation of Frenetic, and show how to use it to implement common management tasks.},
	pages = {1--6},
	booktitle = {Proceedings of the Workshop on Programmable Routers for Extensible Services of Tomorrow},
	publisher = {Association for Computing Machinery},
	author = {Foster, Nate and Freedman, Michael J. and Harrison, Rob and Rexford, Jennifer and Meola, Matthew L. and Walker, David},
	urldate = {2021-02-12},
	date = {2010-11-30},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/HTTB8VR3/Foster et al. - 2010 - Frenetic a high-level language for OpenFlow netwo.pdf:application/pdf},
}

@article{gude_nox_2008,
	title = {{NOX}: towards an operating system for networks},
	volume = {38},
	issn = {0146-4833},
	url = {https://doi.org/10.1145/1384609.1384625},
	doi = {10.1145/1384609.1384625},
	shorttitle = {{NOX}},
	pages = {105--110},
	number = {3},
	journaltitle = {{ACM} {SIGCOMM} Computer Communication Review},
	shortjournal = {{SIGCOMM} Comput. Commun. Rev.},
	author = {Gude, Natasha and Koponen, Teemu and Pettit, Justin and Pfaff, Ben and Casado, Martín and {McKeown}, Nick and Shenker, Scott},
	urldate = {2021-02-12},
	date = {2008-07-01},
	keywords = {security, architecture, management, network},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/AY7EIKWP/Gude et al. - 2008 - NOX towards an operating system for networks.pdf:application/pdf},
}

@article{canini_nice_2012,
	title = {A {NICE} Way to Test {OpenFlow} Applications},
	abstract = {The emergence of {OpenFlow}-capable switches enables exciting new network functionality, at the risk of programming errors that make communication less reliable. The centralized programming model, where a single controller program manages the network, seems to reduce the likelihood of bugs. However, the system is inherently distributed and asynchronous, with events happening at different switches and end hosts, and inevitable delays affecting communication with the controller. In this paper, we present efﬁcient, systematic techniques for testing unmodiﬁed controller programs. Our {NICE} tool applies model checking to explore the state space of the entire system—the controller, the switches, and the hosts. Scalability is the main challenge, given the diversity of data packets, the large system state, and the many possible event orderings. To address this, we propose a novel way to augment model checking with symbolic execution of event handlers (to identify representative packets that exercise code paths on the controller). We also present a simpliﬁed {OpenFlow} switch model (to reduce the state space), and effective strategies for generating event interleavings likely to uncover bugs. Our prototype tests Python applications on the popular {NOX} platform. In testing three real applications—a {MAC}-learning switch, in-network server load balancing, and energyefﬁcient trafﬁc engineering—we uncover eleven bugs.},
	pages = {14},
	author = {Canini, Marco and Venzano, Daniele and Peresˇıni, Peter and Kostic, Dejan and Rexford, Jennifer},
	date = {2012},
	langid = {english},
	file = {Canini et al. - A NICE Way to Test OpenFlow Applications.pdf:/home/fordrl/Zotero/storage/4VRHA4SD/Canini et al. - A NICE Way to Test OpenFlow Applications.pdf:application/pdf},
}

@inproceedings{hogan_elastic_2020,
	location = {New York, {NY}, {USA}},
	title = {Elastic Switch Programming with P4All},
	isbn = {978-1-4503-8145-1},
	url = {https://doi.org/10.1145/3422604.3425933},
	doi = {10.1145/3422604.3425933},
	series = {{HotNets} '20},
	abstract = {The P4 language enables a range of new network applications. However, it is still far from easy to implement and optimize P4 programs for {PISA} hardware. Programmers must engage in a tedious "trial and error" process wherein they write their program (guessing it will fit within the hardware) and then check by compiling it. If it fails, they repeat the process. In this paper, we argue that programmers should define elastic data structures that stretch automatically to make use of available switch resources. We present P4All, an extension of P4 that supports elastic switch programming. Elastic data structures also make P4All modules reusable across different applications and hardware targets, where resource needs and constraints may vary.Our design is oriented around use of symbolic primitives (integers that may take on a range of possible values at compile time), arrays, and loops. We show how to use these primitive mechanisms to build a range of reusable libraries such as hash tables, Bloom filters, sketches, and key-value stores. We also explain the important role that elasticity plays in modular programming, and we allow programmers to declare utility functions that control the relative share of data-plane resources apportioned to each module.},
	pages = {168--174},
	booktitle = {Proceedings of the 19th {ACM} Workshop on Hot Topics in Networks},
	publisher = {Association for Computing Machinery},
	author = {Hogan, Mary and Landau-Feibish, Shir and Tahmasbi Arashloo, Mina and Rexford, Jennifer and Walker, David and Harrison, Rob},
	urldate = {2021-02-04},
	date = {2020-11-04},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/YG2BFKHH/Hogan et al. - 2020 - Elastic Switch Programming with P4All.pdf:application/pdf},
}

@inproceedings{skalka_proof-carrying_2019,
	location = {New York, {NY}, {USA}},
	title = {Proof-Carrying Network Code},
	isbn = {978-1-4503-6747-9},
	url = {https://doi.org/10.1145/3319535.3363214},
	doi = {10.1145/3319535.3363214},
	series = {{CCS} '19},
	abstract = {Computer networks often serve as the first line of defense against malicious attacks. Although there are a growing number of tools for defining and enforcing security policies in software-defined networks ({SDNs}), most assume a single point of control and are unable to handle the challenges that arise in networks with multiple administrative domains. For example, consumers may want want to allow their home {IoT} networks to be configured by device vendors, which raises security and privacy concerns. In this paper we propose a framework called Proof-Carrying Network Code ({PCNC}) for specifying and enforcing security in {SDNs} with interacting administrative domains. Like Proof-Carrying Authorization ({PCA}), {PCNC} provides methods for managing authorization domains, and like Proof-Carrying Code ({PCC}), {PCNC} provides methods for enforcing behavioral properties of network programs. We develop theoretical foundations for {PCNC} and evaluate it in simulated and real network settings, including a case study that considers security in {IoT} networks for home health monitoring.},
	pages = {1115--1129},
	booktitle = {Proceedings of the 2019 {ACM} {SIGSAC} Conference on Computer and Communications Security},
	publisher = {Association for Computing Machinery},
	author = {Skalka, Christian and Ring, John and Darias, David and Kwon, Minseok and Gupta, Sahil and Diller, Kyle and Smolka, Steffen and Foster, Nate},
	urldate = {2021-02-04},
	date = {2019-11-06},
	keywords = {formal verification, software-defined networks, netkat, nexus authorization logic, trust management},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/QKEIJHLT/Skalka et al. - 2019 - Proof-Carrying Network Code.pdf:application/pdf},
}

@article{smolka_guarded_2019,
	title = {Guarded Kleene algebra with tests: verification of uninterpreted programs in nearly linear time},
	volume = {4},
	url = {https://doi.org/10.1145/3371129},
	doi = {10.1145/3371129},
	shorttitle = {Guarded Kleene algebra with tests},
	abstract = {Guarded Kleene Algebra with Tests ({GKAT}) is a variation on Kleene Algebra with Tests ({KAT}) that arises by restricting the union (+) and iteration (*) operations from {KAT} to predicate-guarded versions. We develop the (co)algebraic theory of {GKAT} and show how it can be efficiently used to reason about imperative programs. In contrast to {KAT}, whose equational theory is {PSPACE}-complete, we show that the equational theory of {GKAT} is (almost) linear time. We also provide a full Kleene theorem and prove completeness for an analogue of Salomaa’s axiomatization of Kleene Algebra.},
	pages = {61:1--61:28},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Smolka, Steffen and Foster, Nate and Hsu, Justin and Kappé, Tobias and Kozen, Dexter and Silva, Alexandra},
	urldate = {2021-02-04},
	date = {2019-12-20},
	keywords = {program equivalence, coalgebra, guarded automata, Kleene algebra with Tests, program schemes, uninterpreted programs},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/4KD8IZ8M/Smolka et al. - 2019 - Guarded Kleene algebra with tests verification of.pdf:application/pdf},
}

@inproceedings{smolka_scalable_2019,
	location = {New York, {NY}, {USA}},
	title = {Scalable verification of probabilistic networks},
	isbn = {978-1-4503-6712-7},
	url = {https://doi.org/10.1145/3314221.3314639},
	doi = {10.1145/3314221.3314639},
	series = {{PLDI} 2019},
	abstract = {This paper presents {McNetKAT}, a scalable tool for verifying probabilistic network programs. {McNetKAT} is based on a new semantics for the guarded and history-free fragment of Probabilistic {NetKAT} in terms of finite-state, absorbing Markov chains. This view allows the semantics of all programs to be computed exactly, enabling construction of an automatic verification tool. Domain-specific optimizations and a parallelizing backend enable {McNetKAT} to analyze networks with thousands of nodes, automatically reasoning about general properties such as probabilistic program equivalence and refinement, as well as networking properties such as resilience to failures. We evaluate {McNetKAT}'s scalability using real-world topologies, compare its performance against state-of-the-art tools, and develop an extended case study on a recently proposed data center network design.},
	pages = {190--203},
	booktitle = {Proceedings of the 40th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Smolka, Steffen and Kumar, Praveen and Kahn, David M. and Foster, Nate and Hsu, Justin and Kozen, Dexter and Silva, Alexandra},
	urldate = {2021-02-04},
	date = {2019-06-08},
	keywords = {Network verification, Probabilistic Programming},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/C6PRG6JN/Smolka et al. - 2019 - Scalable verification of probabilistic networks.pdf:application/pdf},
}

@inproceedings{smolka_cantor_2017,
	location = {New York, {NY}, {USA}},
	title = {Cantor meets Scott: semantic foundations for probabilistic networks},
	isbn = {978-1-4503-4660-3},
	url = {https://doi.org/10.1145/3009837.3009843},
	doi = {10.1145/3009837.3009843},
	series = {{POPL} 2017},
	shorttitle = {Cantor meets Scott},
	abstract = {{ProbNetKAT} is a probabilistic extension of {NetKAT} with a denotational semantics based on Markov kernels. The language is expressive enough to generate continuous distributions, which raises the question of how to compute effectively in the language. This paper gives an new characterization of {ProbNetKAT}’s semantics using domain theory, which provides the foundation needed to build a practical implementation. We show how to use the semantics to approximate the behavior of arbitrary {ProbNetKAT} programs using distributions with finite support. We develop a prototype implementation and show how to use it to solve a variety of problems including characterizing the expected congestion induced by different routing schemes and reasoning probabilistically about reachability in a network.},
	pages = {557--571},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {Association for Computing Machinery},
	author = {Smolka, Steffen and Kumar, Praveen and Foster, Nate and Kozen, Dexter and Silva, Alexandra},
	urldate = {2021-02-04},
	date = {2017-01-01},
	keywords = {D.3.1 [Programming Lan- guages]: Formal Definitions and {TheoryźSemantics} Kleene algebra with tests, Domain theory, {NetKAT}, Probabilistic semantics, Software-defined networking},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/PF7LK8JB/Smolka et al. - 2017 - Cantor meets Scott semantic foundations for proba.pdf:application/pdf},
}

@inproceedings{foster_coalgebraic_2015,
	location = {New York, {NY}, {USA}},
	title = {A Coalgebraic Decision Procedure for {NetKAT}},
	isbn = {978-1-4503-3300-9},
	url = {https://doi.org/10.1145/2676726.2677011},
	doi = {10.1145/2676726.2677011},
	series = {{POPL} '15},
	abstract = {{NetKAT} is a domain-specific language and logic for specifying and verifying network packet-processing functions. It consists of Kleene algebra with tests ({KAT}) augmented with primitives for testing and modifying packet headers and encoding network topologies. Previous work developed the design of the language and its standard semantics, proved the soundness and completeness of the logic, defined a {PSPACE} algorithm for deciding equivalence, and presented several practical applications. This paper develops the coalgebraic theory of {NetKAT}, including a specialized version of the Brzozowski derivative, and presents a new efficient algorithm for deciding the equational theory using bisimulation. The coalgebraic structure admits an efficient sparse representation that results in a significant reduction in the size of the state space. We discuss the details of our implementation and optimizations that exploit {NetKAT}'s equational axioms and coalgebraic structure to yield significantly improved performance. We present results from experiments demonstrating that our tool is competitive with state-of-the-art tools on several benchmarks including all-pairs connectivity, loop-freedom, and translation validation.},
	pages = {343--355},
	booktitle = {Proceedings of the 42nd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {Association for Computing Machinery},
	author = {Foster, Nate and Kozen, Dexter and Milano, Matthew and Silva, Alexandra and Thompson, Laure},
	urldate = {2021-02-04},
	date = {2015-01-14},
	keywords = {netkat, coalgebra, automata, brzozowski derivatives, kleene algebra with tests, network verification},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/DIV8PZLJ/Foster et al. - 2015 - A Coalgebraic Decision Procedure for NetKAT.pdf:application/pdf},
}

@article{vandenbroucke_plonk_2019,
	title = {{PloNK}: functional probabilistic {NetKAT}},
	volume = {4},
	url = {https://doi.org/10.1145/3371107},
	doi = {10.1145/3371107},
	shorttitle = {P\&\#x3bb;\&\#x3c9;{NK}},
	abstract = {This work presents {PλωNK}, a functional probabilistic network programming language that extends Probabilistic {NetKAT} ({PNK}). Like {PNK}, it enables probabilistic modelling of network behaviour, by providing probabilistic choice and infinite iteration (to simulate looping network packets). Yet, unlike {PNK}, it also offers abstraction and higher-order functions to make programming much more convenient. The formalisation of {PλωNK} is challenging for two reasons: Firstly, network programming induces multiple side effects (in particular, parallelism and probabilistic choice) which need to be carefully controlled in a functional setting. Our system uses an explicit syntax for thunks and sequencing which makes the interplay of these effects explicit. Secondly, measure theory, the standard domain for formalisations of (continuous) probablistic languages, does not admit higher-order functions. We address this by leveraging ω-Quasi Borel Spaces (ω{QBSes}), a recent advancement in the domain theory of probabilistic programming languages. We believe that our work is not only useful for bringing abstraction to {PNK}, but that—as part of our contribution—we have developed the meta-theory for a probabilistic language that combines advanced features like higher-order functions, iteration and parallelism, which may inform similar meta-theoretic efforts.},
	pages = {39:1--39:27},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Vandenbroucke, Alexander and Schrijvers, Tom},
	urldate = {2021-02-04},
	date = {2019-12-20},
	keywords = {Probabilistic Programming, {NetKAT}, ?-{QBS}, Network Modelling, Quasi-Borel Spaces},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/MFQGM8AG/Vandenbroucke and Schrijvers - 2019 - P&#x3bb\;&#x3c9\;NK functional probabilistic NetKAT.pdf:application/pdf},
}

@inproceedings{beckett_temporal_2016,
	location = {New York, {NY}, {USA}},
	title = {Temporal {NetKAT}},
	isbn = {978-1-4503-4261-2},
	url = {https://doi.org/10.1145/2908080.2908108},
	doi = {10.1145/2908080.2908108},
	series = {{PLDI} '16},
	abstract = {Over the past 5-10 years, the rise of software-defined networking ({SDN}) has inspired a wide range of new systems, libraries, hypervisors and languages for programming, monitoring, and debugging network behavior. Oftentimes, these systems are disjoint—one language for programming and another for verification, and yet another for run-time monitoring and debugging. In this paper, we present a new, unified framework, called Temporal {NetKAT}, capable of facilitating all of these tasks at once. As its name suggests, Temporal {NetKAT} is the synthesis of two formal theories: past-time (finite trace) linear temporal logic and (network) Kleene Algebra with Tests. Temporal predicates allow programmers to write down concise properties of a packet’s path through the network and to make dynamic packet-forwarding, access control or debugging decisions on that basis. In addition to being useful for programming, the combined equational theory of {LTL} and {NetKAT} facilitates proofs of path-based correctness properties. Using new, general, proof techniques, we show that the equational semantics is sound with respect to the denotational semantics, and, for a class of programs we call network-wide programs, complete. We have also implemented a compiler for temporal {NetKAT}, evaluated its performance on a range of benchmarks, and studied the effectiveness of several optimizations.},
	pages = {386--401},
	booktitle = {Proceedings of the 37th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Beckett, Ryan and Greenberg, Michael and Walker, David},
	urldate = {2021-02-04},
	date = {2016-06-02},
	keywords = {{NetKAT}, Domain-specific languages, Kleene algebra with tests, Network programming languages, Temporal logic},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/TRJ6BLPU/Beckett et al. - 2016 - Temporal NetKAT.pdf:application/pdf},
}

@article{bertino_computing_2021,
	title = {Computing Research Challenges in Next Generation Wireless Networking},
	url = {http://arxiv.org/abs/2101.01279},
	abstract = {By all measures, wireless networking has seen explosive growth over the past decade. Fourth Generation Long Term Evolution (4G {LTE}) cellular technology has increased the bandwidth available for smartphones, in essence, delivering broadband speeds to mobile devices. The most recent 5G technology is further enhancing the transmission speeds and cell capacity, as well as, reducing latency through the use of different radio technologies and is expected to provide Internet connections that are an order of magnitude faster than 4G {LTE}. Technology continues to advance rapidly, however, and the next generation, 6G, is already being envisioned. 6G will make possible a wide range of powerful, new applications including holographic telepresence, telehealth, remote education, ubiquitous robotics and autonomous vehicles, smart cities and communities ({IoT}), and advanced manufacturing (Industry 4.0, sometimes referred to as the Fourth Industrial Revolution), to name but a few. The advances we will see begin at the hardware level and extend all the way to the top of the software "stack." Artificial Intelligence ({AI}) will also start playing a greater role in the development and management of wireless networking infrastructure by becoming embedded in applications throughout all levels of the network. The resulting benefits to society will be enormous. At the same time these exciting new wireless capabilities are appearing rapidly on the horizon, a broad range of research challenges loom ahead. These stem from the ever-increasing complexity of the hardware and software systems, along with the need to provide infrastructure that is robust and secure while simultaneously protecting the privacy of users. Here we outline some of those challenges and provide recommendations for the research that needs to be done to address them.},
	journaltitle = {{arXiv}:2101.01279 [cs]},
	author = {Bertino, Elisa and Bliss, Daniel and Lopresti, Daniel and Peterson, Larry and Schulzrinne, Henning},
	urldate = {2021-02-04},
	date = {2021-01-04},
	eprinttype = {arxiv},
	eprint = {2101.01279},
	keywords = {Computer Science - Computers and Society, Computer Science - Networking and Internet Architecture},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/8LXPKDN7/2101.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/9TM83CTV/Bertino et al. - 2021 - Computing Research Challenges in Next Generation W.pdf:application/pdf},
}

@inproceedings{mccauley_enabling_2019,
	location = {New York, {NY}, {USA}},
	title = {Enabling a permanent revolution in internet architecture},
	isbn = {978-1-4503-5956-6},
	url = {https://doi.org/10.1145/3341302.3342075},
	doi = {10.1145/3341302.3342075},
	series = {{SIGCOMM} '19},
	abstract = {Recent Internet research has been driven by two facts and their contradictory implications: the current Internet architecture is both inherently flawed (so we should explore radically different alternative designs) and deeply entrenched (so we should restrict ourselves to backwards-compatible and therefore incrementally deployable improvements). In this paper, we try to reconcile these two perspectives by proposing a backwards-compatible architectural framework called Trotsky in which one can incrementally deploy radically new designs. We show how this can lead to a permanent revolution in Internet architecture by (i) easing the deployment of new architectures and (ii) allowing multiple coexisting architectures to be used simultaneously by applications. By enabling both architectural evolution and architectural diversity, Trotsky would create a far more extensible Internet whose functionality is not defined by a single narrow waist, but by the union of many coexisting architectures. By being incrementally deployable, Trotsky is not just an interesting but unrealistic clean-slate design, but a step forward that is clearly within our reach.},
	pages = {1--14},
	booktitle = {Proceedings of the {ACM} Special Interest Group on Data Communication},
	publisher = {Association for Computing Machinery},
	author = {{McCauley}, James and Harchol, Yotam and Panda, Aurojit and Raghavan, Barath and Shenker, Scott},
	urldate = {2021-02-03},
	date = {2019-08-19},
	keywords = {internet architecture, internet evolution},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/6TAXWGYN/McCauley et al. - 2019 - Enabling a permanent revolution in internet archit.pdf:application/pdf},
}

@article{zave_compositional_2019,
	title = {The compositional architecture of the internet},
	volume = {62},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/3226588},
	doi = {10.1145/3226588},
	pages = {78--87},
	number = {3},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Zave, Pamela and Rexford, Jennifer},
	urldate = {2021-02-03},
	date = {2019-02-21},
	langid = {english},
	file = {Zave and Rexford - 2019 - The compositional architecture of the internet.pdf:/home/fordrl/Zotero/storage/KRTU7QN9/Zave and Rexford - 2019 - The compositional architecture of the internet.pdf:application/pdf},
}

@article{kim_experience-driven_2021,
	title = {Experience-Driven Research on Programmable Networks},
	abstract = {Many promising networking research ideas in programmable networks never see the light of day. Yet, deploying research prototypes in production networks can help validate research ideas, improve them with faster feedback, uncover new research questions, and also ease the subsequent transition to practice. In this paper, we show how researchers can run and validate their research ideas in their own backyards—on their production campus networks—and we have seen that such a demonstrator can expedite the deployment of a research idea in practice to solve real network operation problems. We present Camp4, a proof-of-concept that encompasses tools, an infrastructure design, strategies, and best practices—–both technical and non-technical–—that can help researchers run experiments against their programmable network idea in their own network. We use network tapping devices, packet brokers, and commodity programmable switches to enable running experiments against research ideas on a production campus network. We present several compelling data-plane applications as use cases that run on our campus and solve production network problems. By sharing our experiences, we hope to encourage similar efforts on other campuses.},
	pages = {7},
	journaltitle = {{SIGCOMM} Computer Communications Review},
	author = {Kim, Hyojoon and Chen, Xiaoqi and Brassil, Jack and Rexford, Jennifer},
	date = {2021-01},
	langid = {english},
	file = {Kim et al. - Experience-Driven Research on Programmable Network.pdf:/home/fordrl/Zotero/storage/YC3BCLJT/Kim et al. - Experience-Driven Research on Programmable Network.pdf:application/pdf},
}

@article{zave_remaining_2020,
	title = {The Remaining Improbable: Toward Verifiable Network Services},
	url = {http://arxiv.org/abs/2009.12861},
	shorttitle = {The Remaining Improbable},
	abstract = {The trustworthiness of modern networked services is too important to leave to chance. We need to design these services with specific properties in mind, and verify that the properties hold. In this paper, we argue that a compositional network architecture, based on a notion of layering where each layer is its own complete network customized for a specific purpose, is the only plausible approach to making network services verifiable. Realistic examples show how to use the architecture to reason about sophisticated network properties in a modular way. We also describe a prototype in which the basic structures of the architectural model are implemented in efficient P4 code for programmable data planes, then explain how this scaffolding fits into an integrated process of specification, code generation, implementation of additional network functions, and automated verification.},
	journaltitle = {{arXiv}:2009.12861 [cs]},
	author = {Zave, Pamela and Rexford, Jennifer and Sonchack, John},
	urldate = {2021-02-03},
	date = {2020-09-27},
	eprinttype = {arxiv},
	eprint = {2009.12861},
	keywords = {Computer Science - Networking and Internet Architecture},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/JGK36CHV/2009.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/I6QKZPRX/Zave et al. - 2020 - The Remaining Improbable Toward Verifiable Networ.pdf:application/pdf},
}

@article{basu_languages_2018,
	title = {Languages for Path-Based Network Programming},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International},
	issn = {1048-9738},
	url = {https://ecommons.cornell.edu/handle/1813/59642},
	doi = {10.7298/X4057D4D},
	abstract = {The notion of a path is an important abstraction for reasoning about and managing computer networks. By thinking of network configuration in terms of paths (instead of individual devices), network administrators can reap significant benefits in terms of usability, performance and correctness. Paths themselves can be specified and reasoned about using foundational computational tools such as regular expressions and Kleene Algebras. Furthermore, path-based abstractions can express key network behavior such as isolation requirements and bandwidth constraints, while supporting heterogeneity in terms of devices, physical substrates and administrative domains. This dissertation shows that it is possible to use specifications of network paths, extended with constraints on traffic classes, bandwidth, and the capabilities of network devices, to enable flexible management of modern networks. This is realized by developing path-oriented domain-specific languages to express network policies. These languages show that by starting with abstractions for network paths, it is possible to specify route and bandwidth requirements for classes of traffic, delegate policy management to trusted parties, and enable high-level management of heterogenous networks. Furthermore, by leveraging techniques and tools such as mixed-integer programming, {SAT} solvers and {SDN} controller frameworks, we have built practical compilers and runtimes for these languages. These compilers take high-level specifications of network policies and generate efficient configurations for a range of network devices including packet and optical switches, middlebox frameworks and end-hosts. We have tested these implementations by building and benchmarking a range of practical applications on real-world networks.},
	author = {Basu, Shrutarshi},
	urldate = {2021-02-03},
	date = {2018-08-30},
	langid = {american},
	note = {Accepted: 2018-10-23T13:34:32Z},
	file = {Snapshot:/home/fordrl/Zotero/storage/LDLKW25Y/59642.html:text/html;Full Text PDF:/home/fordrl/Zotero/storage/235GXRQ3/Basu - 2018 - Languages for Path-Based Network Programming.pdf:application/pdf},
}

@article{smolka_coalgebraic_2019,
	title = {A (Co)algebraic Approach to Programming and Verifying Computer Networks},
	rights = {Attribution-{NoDerivatives} 4.0 International},
	url = {https://ecommons.cornell.edu/handle/1813/70019},
	doi = {10.7298/1dpd-c128},
	abstract = {As computer networks have grown into some of the most complex and critical computing systems today, the means of configuring them have not kept up: they remain manual, low-level, and ad-hoc. This makes network operations expensive and network outages due to misconfigurations commonplace. The thesis of this dissertation is that high-level programming languages and formal methods can make network configuration dramatically easier and more reliable. The dissertation consists of three parts. In the first part, we develop algorithms for compiling a network programming language with high-level abstractions to low-level network configurations, and introduce a symbolic data structure that makes compilation efficient in practice. In the second part, we develop foundations for a probabilistic network programming language using measure and domain theory, showing that continuity can be exploited to approximate (statistics of) packet distributions algorithmically. Based on this foundation and the theory of Markov chains, we then design a network verification tool that can reason about fault-tolerance and other probabilistic properties, scaling to data-center-size networks. In the third part, we introduce a general-purpose (co)algebraic framework for designing and reasoning about programming languages, and show that it permits an almost linear-time decision procedure for program equivalence. We hope that the framework will serve as a foundation for efficient verification tools, for networks and beyond, in the future.},
	author = {Smolka, Steffen Juilf},
	urldate = {2021-02-03},
	date = {2019-12},
	langid = {english},
	note = {Accepted: 2020-06-23T18:00:06Z},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/3JL6QJEQ/Smolka - 2019 - A (Co)algebraic Approach to Programming and Verify.pdf:application/pdf},
}

@article{reitblatt_formal_2017,
	title = {Formal Reasoning in Software-defined Networks},
	rights = {Attribution-{NonCommercial}-{NoDerivatives} 4.0 International},
	url = {https://ecommons.cornell.edu/handle/1813/47888},
	doi = {10.7298/X45M63PH},
	abstract = {This thesis presents an end-to-end approach for building computer networks that can be reasoned about and verified formally. In it, we present a high-level specification language for describing the desired forwarding behavior of networks based on regular expressions over network paths, as well as a tool that automatically verifies network forwarding policies; an approach to building formally verified compilers and runtimes for forwarding policies written in a network programming language that preserve the semantics of the source policy; and a technique for updating network configurations while preserving correctness.},
	author = {Reitblatt, Mark},
	urldate = {2021-02-03},
	date = {2017-01-30},
	langid = {american},
	note = {Accepted: 2017-04-04T20:28:27Z},
	file = {Snapshot:/home/fordrl/Zotero/storage/FD7JEN6N/47888.html:text/html;Full Text PDF:/home/fordrl/Zotero/storage/LHS57FBX/Reitblatt - 2017 - Formal Reasoning in Software-defined Networks.pdf:application/pdf},
}

@inproceedings{foster_probabilistic_2016,
	location = {Berlin, Heidelberg},
	title = {Probabilistic {NetKAT}},
	isbn = {978-3-662-49498-1},
	doi = {10.1007/978-3-662-49498-1_12},
	series = {Lecture Notes in Computer Science},
	abstract = {This paper presents a new language for network programming based on a probabilistic semantics. We extend the {NetKATlanguage} with new primitives for expressing probabilistic behaviors and enrich the semantics from one based on deterministic functions to one based on measurable functions on sets of packet histories. We establish fundamental properties of the semantics, prove that it is a conservative extension of the deterministic semantics, show that it satisfies a number of natural equations, and develop a notion of approximation. We present case studies that show how the language can be used to model a diverse collection of scenarios drawn from real-world networks.},
	pages = {282--309},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Foster, Nate and Kozen, Dexter and Mamouras, Konstantinos and Reitblatt, Mark and Silva, Alexandra},
	editor = {Thiemann, Peter},
	date = {2016},
	langid = {english},
	keywords = {Denotational Semantic, Head Packet, Markov Kernel, Network Calculus, Parallel Composition},
	file = {Full Text:/home/fordrl/Zotero/storage/HLZ9CP5Z/Foster et al. - 2016 - Probabilistic NetKAT.pdf:application/pdf},
}

@inproceedings{anderson_netkat_2014,
	location = {New York, {NY}, {USA}},
	title = {{NetKAT}: semantic foundations for networks},
	isbn = {978-1-4503-2544-8},
	url = {https://doi.org/10.1145/2535838.2535862},
	doi = {10.1145/2535838.2535862},
	series = {{POPL} '14},
	shorttitle = {{NetKAT}},
	abstract = {Recent years have seen growing interest in high-level languages for programming networks. But the design of these languages has been largely ad hoc, driven more by the needs of applications and the capabilities of network hardware than by foundational principles. The lack of a semantic foundation has left language designers with little guidance in determining how to incorporate new features, and programmers without a means to reason precisely about their code. This paper presents {NetKAT}, a new network programming language that is based on a solid mathematical foundation and comes equipped with a sound and complete equational theory. We describe the design of {NetKAT}, including primitives for filtering, modifying, and transmitting packets; union and sequential composition operators; and a Kleene star operator that iterates programs. We show that {NetKAT} is an instance of a canonical and well-studied mathematical structure called a Kleene algebra with tests ({KAT}) and prove that its equational theory is sound and complete with respect to its denotational semantics. Finally, we present practical applications of the equational theory including syntactic techniques for checking reachability, proving non-interference properties that ensure isolation between programs, and establishing the correctness of compilation algorithms.},
	pages = {113--126},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {Association for Computing Machinery},
	author = {Anderson, Carolyn Jane and Foster, Nate and Guha, Arjun and Jeannin, Jean-Baptiste and Kozen, Dexter and Schlesinger, Cole and Walker, David},
	urldate = {2021-02-02},
	date = {2014-01-08},
	keywords = {netkat, kleene algebra with tests, domain-specific languages, frenetic, network programming languages, software-defined networking},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/PXGRYHGF/Anderson et al. - 2014 - NetKAT semantic foundations for networks.pdf:application/pdf},
}

@inproceedings{soni_composing_2020,
	location = {Virtual Event {USA}},
	title = {Composing Dataplane Programs with μP4},
	isbn = {978-1-4503-7955-7},
	url = {https://dl.acm.org/doi/10.1145/3387514.3405872},
	doi = {10.1145/3387514.3405872},
	abstract = {Dataplane languages like P4 enable flexible and efficient packetprocessing using domain-specific primitives such as programmable parsers and match-action tables. Unfortunately, P4 programs tend to be monolithic and tightly coupled to the hardware architecture, which makes it hard to write programs in a portable and modular way—e.g., by composing reusable libraries of standard protocols.},
	eventtitle = {{SIGCOMM} '20: Annual conference of the {ACM} Special Interest Group on Data Communication on the applications, technologies, architectures, and protocols for computer communication},
	pages = {329--343},
	booktitle = {Proceedings of the Annual conference of the {ACM} Special Interest Group on Data Communication on the applications, technologies, architectures, and protocols for computer communication},
	publisher = {{ACM}},
	author = {Soni, Hardik and Rifai, Myriana and Kumar, Praveen and Doenges, Ryan and Foster, Nate},
	urldate = {2021-02-02},
	date = {2020-07-30},
	langid = {english},
	file = {Soni et al. - 2020 - Composing Dataplane Programs with μP4.pdf:/home/fordrl/Zotero/storage/DCVKG8FU/Soni et al. - 2020 - Composing Dataplane Programs with μP4.pdf:application/pdf},
}

@article{hauser_survey_2021,
	title = {A Survey on Data Plane Programming with P4: Fundamentals, Advances, and Applied Research},
	url = {http://arxiv.org/abs/2101.10632},
	shorttitle = {A Survey on Data Plane Programming with P4},
	abstract = {With traditional networking, users can configure control plane protocols to match the specific network configuration, but without the ability to fundamentally change the underlying algorithms. With {SDN}, the users may provide their own control plane, that can control network devices through their data plane {APIs}. Programmable data planes allow users to define their own data plane algorithms for network devices including appropriate data plane {APIs} which may be leveraged by user-defined {SDN} control. Thus, programmable data planes and {SDN} offer great flexibility for network customization, be it for specialized, commercial appliances, e.g., in 5G or data center networks, or for rapid prototyping in industrial and academic research. Programming protocol-independent packet processors (P4) has emerged as the currently most widespread abstraction, programming language, and concept for data plane programming. It is developed and standardized by an open community and it is supported by various software and hardware platforms. In this paper, we survey the literature from 2015 to 2020 on data plane programming with P4. Our survey covers 497 references of which 367 are scientific publications. We organize our work into two parts. In the first part, we give an overview of data plane programming models, the programming language, architectures, compilers, targets, and data plane {APIs}. We also consider research efforts to advance P4 technology. In the second part, we analyze a large body of literature considering P4-based applied research. We categorize 241 research papers into different application domains, summarize their contributions, and extract prototypes, target platforms, and source code availability.},
	journaltitle = {{arXiv}:2101.10632 [cs]},
	author = {Hauser, Frederik and Häberle, Marco and Merling, Daniel and Lindner, Steffen and Gurevich, Vladimir and Zeiger, Florian and Frank, Reinhard and Menth, Michael},
	urldate = {2021-02-01},
	date = {2021-01-26},
	eprinttype = {arxiv},
	eprint = {2101.10632},
	keywords = {Computer Science - Networking and Internet Architecture},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/4TV9NBJP/2101.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/SCAQTQLB/Hauser et al. - 2021 - A Survey on Data Plane Programming with P4 Fundam.pdf:application/pdf},
}

@article{casado_abstractions_2014,
	title = {Abstractions for software-defined networks},
	volume = {57},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/2661061.2661063},
	doi = {10.1145/2661061.2661063},
	abstract = {New abstractions are critical for achieving {SDN} goals.},
	pages = {86--95},
	number = {10},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Casado, Martin and Foster, Nate and Guha, Arjun},
	urldate = {2021-01-21},
	date = {2014-09-23},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/L55A9RD8/Casado et al. - 2014 - Abstractions for software-defined networks.pdf:application/pdf},
}

@online{p4_consortium_p4_2021,
	title = {P4 Language and Related Specifications},
	url = {https://p4.org/specs/},
	author = {P4 Consortium},
	urldate = {2021-01-13},
	date = {2021},
	file = {P4 Language and Related Specifications:/home/fordrl/Zotero/storage/GF2D92AS/specs.html:text/html},
}

@online{p4org_application_working_group_inband_2020,
	title = {Inband Network Telemetry ({INT}) Dataplane Specification},
	url = {https://github.com/p4lang/p4-applications/blob/master/docs/INT_v2_1.pdf},
	abstract = {Inband Network Telemetry ("{INT}") is a framework designed to allow the collection and reporting of network state, by the data plane, without intervention or work by the control plane.},
	titleaddon = {{GitHub}},
	author = {P4.org Application Working Group},
	urldate = {2021-01-21},
	date = {2020-01-06},
	langid = {english},
	file = {Snapshot:/home/fordrl/Zotero/storage/JNF6QQRM/INT_v2_1.html:text/html},
}

@online{onf_sdn_2021,
	title = {{SDN} Technical Specifications},
	url = {https://opennetworking.org/software-defined-standards/specifications/},
	abstract = {These technical {SDN} specifications include standards of protocol, informational model, functionality and related framework},
	titleaddon = {Open Networking Foundation},
	author = {{ONF}},
	urldate = {2021-01-21},
	date = {2021},
	langid = {american},
	file = {Snapshot:/home/fordrl/Zotero/storage/4XVP82DD/specifications.html:text/html},
}

@online{riecke_frenetic_2016,
	title = {Frenetic Programmers Guide},
	url = {https://github.com/frenetic-lang/manual},
	abstract = {Programmers Guide and other written materials. Contribute to frenetic-lang/manual development by creating an account on {GitHub}.},
	titleaddon = {{GitHub}},
	author = {Riecke, Craig},
	urldate = {2021-01-13},
	date = {2016-07-13},
	langid = {english},
	file = {frenetic-langmanual.pdf:/home/fordrl/Zotero/storage/NI4XLBG2/frenetic-langmanual.pdf:application/pdf;Snapshot:/home/fordrl/Zotero/storage/EZA3Q6GM/frenetic_programmers_guide.html:text/html},
}

@inproceedings{tsuzaki_reactive_2017,
	title = {Reactive configuration updating for Intent-Based Networking},
	doi = {10.1109/ICOIN.2017.7899484},
	abstract = {Since network configurations in the Internet are getting complicated, managing networks has become a heavy task. As an attempt to solve this problem, the concept of Intent-Based Networking ({IBN}) has been proposed. While intent of a network administrator in conventional networks is used to be expressed in concrete description of configurations stored on devices each, intent of an administrator in {IBN} is expressed abstractly and prescriptively as what he wants to do. The concept of Intent-Based Network Modeling ({NEMO}) language has been discussed in {IETF} {IB}-Nemo {BoF}, and a draft specification and implementation of it is developed in the {NEMO} project. {NEMO}, a transaction based Northbound {API}, currently supports description of simple proactive policy only such as change of network path at a specified time. We propose a mechanism that enables an administrator to update network configuration automatically in accordance with the change of external environment, based on reactive configurations which express the intent of the administrator. In this paper, we will describe automatic network management methods that have been studied, and then describe our proposed procedure to update configuration reactively in an extended {NEMO} language. Issues on implementation are also discussed.},
	eventtitle = {2017 International Conference on Information Networking ({ICOIN})},
	pages = {97--102},
	booktitle = {2017 International Conference on Information Networking ({ICOIN})},
	author = {Tsuzaki, Y. and Okabe, Y.},
	date = {2017-01},
	keywords = {application program interfaces, computer network management, automatic network management methods, Bandwidth, Concrete, Data models, Event Condition Action, {IBN}, {IETF} {IB}-Nemo {BoF}, intent-based network modeling, Intent-Based Networking, Internet, {NEMO} language, network administrator, network configurations, Network Management, Protocols, reactive configuration updating, Routing, Software defined networking, Terminology, transaction based northbound {API}},
	file = {Tsuzaki and Okabe - 2017 - Reactive configuration updating for Intent-Based N.pdf:/home/fordrl/Zotero/storage/HJQDFLEQ/Tsuzaki and Okabe - 2017 - Reactive configuration updating for Intent-Based N.pdf:application/pdf;IEEE Xplore Abstract Record:/home/fordrl/Zotero/storage/2QHKJA6R/7899484.html:text/html},
}

@online{mitchell_what_2015,
	title = {What is {OpenFlow} and why should you care?},
	url = {https://itbrief.co.nz/story/what-openflow-and-why-should-you-care},
	abstract = {Network switch manufacturers traditionally competed on the speed, features and software running and monitoring their products - change is in the air.},
	author = {Mitchell, Sean},
	urldate = {2021-01-21},
	date = {2015-12-16},
	langid = {english},
	file = {Snapshot:/home/fordrl/Zotero/storage/IWLV6S8W/what-openflow-and-why-should-you-care.html:text/html},
}

@book{kang_formal_2013,
	title = {Formal Modeling and Verification of {SDN}-{OpenFlow}},
	isbn = {978-1-4673-5961-0},
	abstract = {Software-Defined Networking ({SDN}) is a network architecture where a controller manages flow control to enable intelligent networking. Currently, a popular specification for creating an {SDN} is an open standard called {OpenFlow}. The behavior of the {SDN} {OpenFlow} ({SDN}-{OF}) is critical to the safety of the network system and its correctness must be proven so as to avoid system failures. In this paper, we report our experience in applying formal techniques for modeling and analysis of {SDN}-{OF}. The formal model of {SDN}-{OF} is described in detail and its correctness is formalized in logical formulas based on the informal specification. The desired properties are verified over the model using {VERSA} and {UPPAAL}. Our work-in-progressinvolves the development of a model translation tool that facilitates automatic conversion of the verified model to Python for modular code synthesis on the application platform},
	pagetotal = {481},
	author = {Kang, Miyoung and Kang, Eun-Young and Hwang, Dae-Yon and Kim, Beom-Jin and Nam, Ki-Hyuk and Shin, Myung-Ki and Choi, Jin-Young},
	date = {2013-03-01},
	doi = {10.1109/ICST.2013.69},
	note = {Pages: 482},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/FDVKED6E/Kang et al. - 2013 - Formal Modeling and Verification of SDN-OpenFlow.pdf:application/pdf},
}

@book{covington_implementing_nodate,
	title = {Implementing an {OpenFlow} Switch on the {NetFPGA} platform},
	abstract = {We describe the implementation of an {OpenFlow} Switch on the {NetFPGA} platform. {OpenFlow} is a way to deploy experimental or new protocols in networks that carry production traffic. An {OpenFlow} network consists of simple flow-based switches in the datapath, with a remote controller to manage several switches. In practice, {OpenFlow} is most often added as a feature to an existing Ethernet switch, {IPv}4 router or wireless access point. An {OpenFlow}-enabled device has an internal flow-table and a standardized interface to add and remove flow entries remotely. Our implementation of {OpenFlow} on the {NetFPGA} is one of several reference implementations we have implemented on different platforms. Our simple {OpenFlow} implementation is capable of running at line-rate and handling all the traffic that is going through the Stanford Electrical Engineering and Computer Science building. We compare our implementation’s complexity to a basic {IPv}4 router implementation and a basic Ethernet learning switch implementation. We describe the {OpenFlow} deployment into the Stanford campus and the Internet2 backbone.},
	author = {Covington, G. Adam and Naous, Jad and Erickson, David and Mckeown, Nick},
	file = {Citeseer - Snapshot:/home/fordrl/Zotero/storage/QX7TD5H6/download.html:text/html;Citeseer - Full Text PDF:/home/fordrl/Zotero/storage/4GHX9YMA/Covington et al. - Implementing an OpenFlow Switch on the NetFPGA pla.pdf:application/pdf},
}

@online{noauthor_open_nodate,
	title = {Open {vSwitch} 2.15.90 documentation},
	url = {https://docs.openvswitch.org/en/latest/},
	urldate = {2021-01-20},
	file = {Open vSwitch 2.15.90 documentation:/home/fordrl/Zotero/storage/QX39SMZT/Open vSwitch 2.15.90 documentation.html:text/html},
}

@online{noauthor_open_nodate-1,
	title = {Open Compute Project},
	url = {https://www.opencompute.org},
	abstract = {Open Compute Project},
	titleaddon = {Open Compute Project},
	urldate = {2021-01-20},
	langid = {english},
	file = {Snapshot:/home/fordrl/Zotero/storage/BTDMW5XD/www.opencompute.org.html:text/html},
}

@article{feamster_road_2013,
	title = {The Road to {SDN}: An Intellectual History of Programmable Networks},
	abstract = {Software Deﬁned Networking ({SDN}) is an exciting technology that enables innovation in how we design and manage networks. Although this technology seems to have appeared suddenly, {SDN} is part of a long history of efforts to make computer networks more programmable. In this paper, we trace the intellectual history of programmable networks, including active networks, early efforts to separate the control and data plane, and more recent work on {OpenFlow} and network operating systems. We highlight key concepts, as well as the technology pushes and application pulls that spurred each innovation. Along the way, we debunk common myths and misconceptions about the technologies and clarify the relationship between {SDN} and related technologies such as network virtualization.},
	pages = {13},
	author = {Feamster, Nick and Rexford, Jennifer and Zegura, Ellen},
	date = {2013},
	langid = {english},
	file = {Feamster et al. - The Road to SDN An Intellectual History of Progra.pdf:/home/fordrl/Zotero/storage/SACLCBSU/Feamster et al. - The Road to SDN An Intellectual History of Progra.pdf:application/pdf},
}

@online{davie_why_2020,
	title = {Why 5G Matters},
	url = {http://www.systemsapproach.org/1/archives/12-2020},
	abstract = {Over the last month I undertook a detailed review of a new book in the Systems Approach series, 5G Mobile Networks: A Systems Approach by Larry Peterson and Oguz Sunay. Talking to people outside the...},
	titleaddon = {Systems Approach},
	author = {Davie, Bruce},
	urldate = {2021-01-20},
	date = {2020-12-14},
	langid = {english},
	file = {Snapshot:/home/fordrl/Zotero/storage/FDBPNCTD/12-2020.html:text/html},
}

@inproceedings{schnepf_automated_2017,
	title = {Automated verification of security chains in software-defined networks with synaptic},
	doi = {10.1109/NETSOFT.2017.8004195},
	abstract = {Software-defined networks provide new facilities for deploying security mechanisms dynamically. In particular, it is possible to build and adjust security chains to protect the infrastructures, by combining different security functions, such as firewalls, intrusion detection systems and services for preventing data leakage. It is important to ensure that these security chains, in view of their complexity and dynamics, are consistent and do not include security violations. We propose in this paper an automated strategy for supporting the verification of security chains in software-defined networks. It relies on an architecture integrating formal verification methods for checking both the control and data planes of these chains, before their deployment. We describe algorithms for translating specifications of security chains into formal models that can then be verified by {SMT}1 solving or model checking. Our solution is prototyped as a package, named Synaptic, built as an extension of the Frenetic family of {SDN} programming languages. The performances of our approach are evaluated through extensive experimentations based on the {CVC}4, {veriT}, and {nuXmv} checkers.},
	eventtitle = {2017 {IEEE} Conference on Network Softwarization ({NetSoft})},
	pages = {1--9},
	booktitle = {2017 {IEEE} Conference on Network Softwarization ({NetSoft})},
	author = {Schnepf, N. and Badonnel, R. and Lahmadi, A. and Merz, S.},
	date = {2017-07},
	keywords = {Security, formal verification, model checking, Control systems, software-defined networks, Formal Verification, {SMT}, formal specification, automated verification, Cloud computing, Computer languages, computer network security, {CVC}4, data leakage prevention, firewalls, formal models, Frenetic family, infrastructure protection, intrusion detection systems, Middleboxes, Model checking, {nuXmv} checkers, {SDN} programming languages, security chain verification, security chains, security functions, Security Management, Smart devices, software defined networking, Software-Defined Networking, specification translation, Synaptic, {veriT}},
	file = {IEEE Xplore Abstract Record:/home/fordrl/Zotero/storage/GYTUKKZQ/8004195.html:text/html;Submitted Version:/home/fordrl/Zotero/storage/22LPIV93/Schnepf et al. - 2017 - Automated verification of security chains in softw.pdf:application/pdf},
}

@article{kim_kinetic_nodate,
	title = {Kinetic: Veriﬁable Dynamic Network Control},
	abstract = {Network conditions are dynamic; unfortunately, current approaches to conﬁguring networks. Network operators need tools to express how a network’s data-plane behavior should respond to a wide range of events and changing conditions, ranging from unexpected failures to shifting trafﬁc patterns to planned maintenance. Yet, to update the network conﬁguration today, operators typically rely on a combination of manual intervention and ad hoc scripts. In this paper, we present Kinetic, a domain speciﬁc language and network control system that enables operators to control their networks dynamically in a concise, intuitive way. Kinetic also automatically veriﬁes the correctness of these control programs with respect to user-speciﬁed temporal properties. Our user study of Kinetic with several hundred network operators demonstrates that Kinetic is intuitive and usable, and our performance evaluation shows that realistic Kinetic programs scale well with the number of policies and the size of the network.},
	pages = {15},
	author = {Kim, Hyojoon and Reich, Joshua and Gupta, Arpit and Shahbaz, Muhammad and Feamster, Nick and Clark, Russ},
	langid = {english},
	file = {Kim et al. - Kinetic Veriﬁable Dynamic Network Control.pdf:/home/fordrl/Zotero/storage/PUJ5NWEV/Kim et al. - Kinetic Veriﬁable Dynamic Network Control.pdf:application/pdf},
}

@inproceedings{darvas_formal_2016,
	location = {Berlin, Heidelberg},
	title = {Formal Verification of Safety {PLC} Based Control Software},
	isbn = {978-3-319-33692-3},
	url = {https://doi.org/10.1007/978-3-319-33693-0_32},
	doi = {10.1007/978-3-319-33693-0_32},
	series = {{IFM} 2016},
	abstract = {Programmable Logic Controllers {PLCs} are widely used in the industry for various industrial automation tasks. Besides non-safety applications, the usage of {PLCs} became accepted in safety-critical installations, where the cost of failure is high. In these cases the used hardware is special so-called fail-safe or safety {PLCs}, but also the software needs special considerations. Formal verification is a method that can help to develop high-quality software for critical tasks. However, such method should be adapted to the special needs of the safety {PLCs}, that are often particular compared to the normal {PLC} development domain. In this paper we propose two complementary solutions for the formal verification of safety-critical {PLC} programs based on model checking and equivalence checking using formal specification. Furthermore, a case study is presented, demonstrating our approach.},
	pages = {508--522},
	booktitle = {Proceedings of the 12th International Conference on Integrated Formal Methods - Volume 9681},
	publisher = {Springer-Verlag},
	author = {Darvas, Dániel and Majzik, István and Blanco Viñuela, Enrique},
	urldate = {2021-01-19},
	date = {2016-06-01},
	keywords = {Safety-critical systems, Model checking, Formal specification, {PLC}},
	file = {2016_Book_IntegratedFormalMethods-has-safetyPLC-based-control-software.pdf:/Users/richardford/Dropbox/oasys/proposals/2020-dec/Papers/2016_Book_IntegratedFormalMethods-has-safetyPLC-based-control-software.pdf:application/pdf},
}

@inproceedings{ball_vericon_2014,
	location = {Edinburgh United Kingdom},
	title = {{VeriCon}: towards verifying controller programs in software-defined networks},
	isbn = {978-1-4503-2784-8},
	url = {https://dl.acm.org/doi/10.1145/2594291.2594317},
	doi = {10.1145/2594291.2594317},
	shorttitle = {{VeriCon}},
	abstract = {Software-deﬁned networking ({SDN}) is a new paradigm for operating and managing computer networks. {SDN} enables logicallycentralized control over network devices through a “controller” software that operates independently from the network hardware, and can be viewed as the network operating system. Network operators can run both inhouse and third-party {SDN} programs (often called applications) on top of the controller, e.g., to specify routing and access control policies. {SDN} opens up the possibility of applying formal methods to prove the correctness of computer networks. Indeed, recently much effort has been invested in applying ﬁnite state model checking to check that {SDN} programs behave correctly. However, in general, scaling these methods to large networks is challenging and, moreover, they cannot guarantee the absence of errors. We present {VeriCon}, the ﬁrst system for verifying that an {SDN} program is correct on all admissible topologies and for all possible (inﬁnite) sequences of network events. {VeriCon} either conﬁrms the correctness of the controller program on all admissible network topologies or outputs a concrete counterexample. {VeriCon} uses ﬁrst-order logic to specify admissible network topologies and desired network-wide invariants, and then implements classical {FloydHoare}-Dijkstra deductive veriﬁcation using Z3. Our preliminary experience indicates that {VeriCon} is able to rapidly verify correctness, or identify bugs, for a large repertoire of simple core {SDN} programs. {VeriCon} is compositional, in the sense that it veriﬁes the correctness of execution of any single network event w.r.t. the speciﬁed invariant, and can thus scale to handle large programs. To relieve the burden of specifying inductive invariants from the programmer, {VeriCon} includes a separate procedure for inferring invariants, which is shown to be effective on simple controller programs. We view {VeriCon} as a ﬁrst step en route to practical mechanisms for verifying network-wide invariants of {SDN} programs.},
	eventtitle = {{PLDI} '14: {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	pages = {282--293},
	booktitle = {Proceedings of the 35th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Ball, Thomas and Bjørner, Nikolaj and Gember, Aaron and Itzhaky, Shachar and Karbyshev, Aleksandr and Sagiv, Mooly and Schapira, Michael and Valadarsky, Asaf},
	urldate = {2021-01-19},
	date = {2014-06-09},
	langid = {english},
	file = {Ball et al. - 2014 - VeriCon towards verifying controller programs in .pdf:/home/fordrl/Zotero/storage/N9LE5U4Z/Ball et al. - 2014 - VeriCon towards verifying controller programs in .pdf:application/pdf},
}

@article{peterson_democratizing_2019,
	title = {Democratizing the Network Edge},
	volume = {49},
	issn = {0146-4833},
	url = {https://dl.acm.org/doi/10.1145/3336937.3336942},
	doi = {10.1145/3336937.3336942},
	abstract = {With datacenters established as part of the global computing infrastructure, industry is now in the midst of a transition towards the edge. Previous research initiatives laid the groundwork for this transition, but that is no guarantee the emerging edge will continue to be open to researchers. This paper argues that there is a tremendous opportunity to innovate at the edge, but having impact requires understanding the nature of the current industry momentum, and making a concerted effort to align with that momentum. We believe there are three keys to doing this: (1) focus on the intersection of the cloud and access networks, (2) contribute to the relevant open source projects, and (3) address the challenge of operationalizing the results. The paper puts forward a concrete proposal for all three, and discusses the opportunity to influence how the Internet evolves at the edge and enable new and transformative edge applications.},
	pages = {31--36},
	number = {2},
	journaltitle = {{ACM} {SIGCOMM} Computer Communication Review},
	shortjournal = {{SIGCOMM} Comput. Commun. Rev.},
	author = {Peterson, Larry and Anderson, Tom and Katti, Sachin and {McKeown}, Nick and Parulkar, Guru and Rexford, Jennifer and Satyanarayanan, Mahadev and Sunay, Oguz and Vahdat, Amin},
	urldate = {2021-01-14},
	date = {2019-05-21},
	langid = {english},
	file = {Peterson et al. - 2019 - Democratizing the Network Edge.pdf:/home/fordrl/Zotero/storage/NRIVNQUG/Peterson et al. - 2019 - Democratizing the Network Edge.pdf:application/pdf},
}

@inproceedings{liu_p4v_2018,
	location = {Budapest Hungary},
	title = {p4v: practical verification for programmable data planes},
	isbn = {978-1-4503-5567-4},
	url = {https://dl.acm.org/doi/10.1145/3230543.3230582},
	doi = {10.1145/3230543.3230582},
	shorttitle = {p4v},
	abstract = {We present the design and implementation of p4v, a practical tool for verifying data planes described using the P4 programming language. The design of p4v is based on classic verification techniques but adds several key innovations including a novel mechanism for incorporating assumptions about the control plane and domain-specific optimizations which are needed to scale to large programs. We present case studies showing that p4v verifies important properties and finds bugs in real-world programs. We conduct experiments to quantify the scalability of p4v on a wide range of additional examples. We show that with just a few hundred lines of control-plane annotations, p4v is able to verify critical safety properties for switch.p4, a program that implements the functionality of on a modern data center switch, in under three minutes.},
	eventtitle = {{SIGCOMM} '18: {ACM} {SIGCOMM} 2018 Conference},
	pages = {490--503},
	booktitle = {Proceedings of the 2018 Conference of the {ACM} Special Interest Group on Data Communication},
	publisher = {{ACM}},
	author = {Liu, Jed and Hallahan, William and Schlesinger, Cole and Sharif, Milad and Lee, Jeongkeun and Soulé, Robert and Wang, Han and Caşcaval, Călin and {McKeown}, Nick and Foster, Nate},
	urldate = {2021-01-14},
	date = {2018-08-07},
	langid = {english},
	file = {Liu et al. - 2018 - p4v practical verification for programmable data .pdf:/home/fordrl/Zotero/storage/RBHMRW63/Liu et al. - 2018 - p4v practical verification for programmable data .pdf:application/pdf},
}

@article{jain_b4_nodate,
	title = {B4: Experience with a Globally-Deployed Software Deﬁned {WAN}},
	abstract = {We present the design, implementation, and evaluation of B , a private {WAN} connecting Google’s data centers across the planet. B has a number of unique characteristics: i) massive bandwidth requirements deployed to a modest number of sites, ii) elastic trafc demand that seeks to maximize average bandwidth, and iii) full control over the edge servers and network, which enables rate limiting and demand measurement at the edge. ese characteristics led to a So ware De ned Networking architecture using {OpenFlow} to control relatively simple switches built from merchant silicon. B ’s centralized tra c engineering service drives links to near utilization, while splitting application ows among multiple paths to balance capacity against application priority/demands. We describe experience with three years of B production deployment, lessons learned, and areas for future work.},
	pages = {12},
	author = {Jain, Sushant and Kumar, Alok and Mandal, Subhasree and Ong, Joon and Poutievski, Leon and Singh, Arjun and Venkata, Subbaiah and Wanderer, Jim and Zhou, Junlan and Zhu, Min and Zolla, Jonathan and Hölzle, Urs and Stuart, Stephen and Vahdat, Amin},
	langid = {english},
	file = {Jain et al. - B4 Experience with a Globally-Deployed Software D.pdf:/home/fordrl/Zotero/storage/26CGJ4YA/Jain et al. - B4 Experience with a Globally-Deployed Software D.pdf:application/pdf},
}

@online{noauthor_open_nodate-2,
	title = {Open {vSwitch}},
	url = {https://www.openvswitch.org/},
	urldate = {2021-01-14},
	file = {Open vSwitch:/home/fordrl/Zotero/storage/EQVA3U4L/www.openvswitch.org.html:text/html},
}

@inproceedings{dumitrescu_bf4_2020,
	location = {New York, {NY}, {USA}},
	title = {bf4: towards bug-free P4 programs},
	isbn = {978-1-4503-7955-7},
	url = {https://doi.org/10.1145/3387514.3405888},
	doi = {10.1145/3387514.3405888},
	series = {{SIGCOMM} '20},
	shorttitle = {bf4},
	abstract = {Recent verification work has made advances in finding bugs in P4 programs before deployment, but it requires that the programmer specifies table rules that are possible at runtime[32, 24, 27]. This imposes a specification burden on the programmer, while at the same time failing to guarantee that bugs will not be inserted at runtime by faulty controllers. We present bf4, a novel verification approach for P4 programs that uses a mix of static verification, code changes and runtime checks to ensure that the deployed P4 program is bug free. To achieve this, bf4 uses static analysis to find all possible bugs in the P4 program; for each possible bug, bf4 attempts to find predicates that, when applied to table rules inserted by the controller, make that bug unreachable. If such predicates do not exist, bf4 can change the P4 code and re-run the procedure above. We applied bf4 to a wide range of P4 programs; for all these, bf4 is able to generate controller assertions and propose fixes that guarantee no controller-induced bug is reachable. At runtime, bf4 checks that the controller does not insert faulty rules; when it does, it throws an exception which helps troubleshoot the bug.},
	pages = {571--585},
	booktitle = {Proceedings of the Annual conference of the {ACM} Special Interest Group on Data Communication on the applications, technologies, architectures, and protocols for computer communication},
	publisher = {Association for Computing Machinery},
	author = {Dumitrescu, Dragos and Stoenescu, Radu and Negreanu, Lorina and Raiciu, Costin},
	urldate = {2021-01-13},
	date = {2020-07-30},
	keywords = {Network dataplane verification, programmable networks},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/YWLHQC7Q/Dumitrescu et al. - 2020 - bf4 towards bug-free P4 programs.pdf:application/pdf},
}

@article{backes_one-click_2019,
	title = {One-Click Formal Methods},
	volume = {36},
	issn = {0740-7459, 1937-4194},
	url = {https://ieeexplore.ieee.org/document/8880058/},
	doi = {10.1109/MS.2019.2930609},
	pages = {61--65},
	number = {6},
	journaltitle = {{IEEE} Software},
	shortjournal = {{IEEE} Softw.},
	author = {Backes, John and Varming, Carsten and Whalen, Michael and Bolignano, Pauline and Cook, Byron and Gacek, Andrew and Luckow, Kasper Soe and Rungta, Neha and Schaef, Martin and Schlesinger, Cole and Tanash, Rima},
	urldate = {2021-01-14},
	date = {2019-11},
	langid = {english},
	file = {Backes et al. - 2019 - One-Click Formal Methods.pdf:/home/fordrl/Zotero/storage/E3IEM6T3/Backes et al. - 2019 - One-Click Formal Methods.pdf:application/pdf},
}

@online{noauthor_provable_nodate,
	title = {Provable Security - Amazon Web Services ({AWS})},
	url = {https://aws.amazon.com/security/provable-security/},
	abstract = {Insights and research from {AWS} Security experts on security assurance, backed by mathematical proof.},
	titleaddon = {Amazon Web Services, Inc.},
	urldate = {2021-01-14},
	langid = {american},
	file = {Snapshot:/home/fordrl/Zotero/storage/H84VKB4M/provable-security.html:text/html},
}

@inproceedings{magrino_efficient_2019,
	location = {New York, {NY}, {USA}},
	title = {Efficient, Consistent Distributed Computation with Predictive Treaties},
	isbn = {978-1-4503-6281-8},
	url = {https://doi.org/10.1145/3302424.3303987},
	doi = {10.1145/3302424.3303987},
	series = {{EuroSys} '19},
	abstract = {To achieve good performance, modern applications often partition their state across multiple geographically distributed nodes. While this approach reduces latency in the common case, it can be challenging for programmers to use correctly, especially in applications that require strong consistency. We introduce predictive treaties, a mechanism that can significantly reduce distributed coordination without losing strong consistency. The central insight behind our approach is that many computations can be expressed in terms of predicates over distributed state that can be partitioned and enforced locally. Predictive treaties improve on previous work by allowing the locally enforced predicates to depend on time. Intuitively, by predicting the evolution of system state, coordination can be significantly reduced compared to static approaches. We implemented predictive treaties in a distributed system that exposes them in an intuitive programming model. We evaluate performance on several benchmarks, including {TPC}-C, showing that predictive treaties can significantly increase performance by orders of magnitude and can even outperform customized algorithms.},
	pages = {1--16},
	booktitle = {Proceedings of the Fourteenth {EuroSys} Conference 2019},
	publisher = {Association for Computing Machinery},
	author = {Magrino, Tom and Liu, Jed and Foster, Nate and Gehrke, Johannes and Myers, Andrew C.},
	urldate = {2021-01-13},
	date = {2019-03-25},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/6S9MX8U5/Magrino et al. - 2019 - Efficient, Consistent Distributed Computation with.pdf:application/pdf},
}

@inproceedings{liu_secure_2018,
	location = {New York, {NY}, {USA}},
	title = {Secure Autonomous Cyber-Physical Systems Through Verifiable Information Flow Control},
	isbn = {978-1-4503-5992-4},
	url = {https://doi.org/10.1145/3264888.3264889},
	doi = {10.1145/3264888.3264889},
	series = {{CPS}-{SPC} '18},
	abstract = {Modern cyber-physical systems are complex networked computing systems that electronically control physical systems. Autonomous road vehicles are an important and increasingly ubiquitous instance. Unfortunately, their increasing complexity often leads to security vulnerabilities. Network connectivity exposes these vulnerable systems to remote software attacks that can result in real-world physical damage, including vehicle crashes and loss of control authority. We introduce an integrated architecture to provide provable security and safety assurance for cyber-physical systems by ensuring that safety-critical operations and control cannot be unintentionally affected by potentially malicious parts of the system. Fine-grained information flow control is used to design both hardware and software, determining how low-integrity information can affect high-integrity control decisions. This security assurance is used to improve end-to-end security across the entire cyber-physical system. We demonstrate this integrated approach by developing a mobile robotic testbed modeling a self-driving system and testing it with a malicious attack.},
	pages = {48--59},
	booktitle = {Proceedings of the 2018 Workshop on Cyber-Physical Systems Security and {PrivaCy}},
	publisher = {Association for Computing Machinery},
	author = {Liu, Jed and Corbett-Davies, Joe and Ferraiuolo, Andrew and Ivanov, Alexander and Luo, Mulong and Suh, G. Edward and Myers, Andrew C. and Campbell, Mark},
	urldate = {2021-01-13},
	date = {2018-01-15},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/UUHDAUP6/Liu et al. - 2018 - Secure Autonomous Cyber-Physical Systems Through V.pdf:application/pdf},
}

@inproceedings{oconnor_using_2019,
	title = {Using P4 on Fixed-Pipeline and Programmable Stratum Switches},
	doi = {10.1109/ANCS.2019.8901885},
	abstract = {Stratum is an open source network operating system ({NOS})that provides a common implementation of P4Runtime and {OpenConfig} interfaces for white box switches. This demonstration will show an {SDN} leaf-spine fabric of Stratum-enabled white box switches managed by the {ONOS} {SDN} controller. The switching chips ({ASICs})and platforms will come from different vendors, but they will share a common P4-defined pipeline and set of {OpenConfig} models.},
	eventtitle = {2019 {ACM}/{IEEE} Symposium on Architectures for Networking and Communications Systems ({ANCS})},
	pages = {1--2},
	booktitle = {2019 {ACM}/{IEEE} Symposium on Architectures for Networking and Communications Systems ({ANCS})},
	author = {O'Connor, B. and Tseng, Y. and Pudelko, M. and Cascone, C. and Endurthi, A. and Wang, Y. and Ghaffarkhah, A. and Gopalpur, D. and Everman, T. and Madejski, T. and Wanderer, J. and Vahdat, A.},
	date = {2019-09},
	keywords = {Software defined networking, Computer networks, {gNMI}, {gNOI}, Next generation networking, Open-Config, P4, P4Runtime, Stratum},
	file = {O'Connor et al. - 2019 - Using P4 on Fixed-Pipeline and Programmable Stratu.pdf:/home/fordrl/Zotero/storage/34T5AY4J/O'Connor et al. - 2019 - Using P4 on Fixed-Pipeline and Programmable Stratu.pdf:application/pdf},
}

@article{ruffy_gauntlet_nodate,
	title = {Gauntlet: Finding Bugs in Compilers for Programmable Packet Processing},
	abstract = {Programmable packet-processing devices such as programmable switches and network interface cards are becoming mainstream. These devices are conﬁgured in a domainspeciﬁc language such as P4, using a compiler to translate packet-processing programs into instructions for different targets. As networks with programmable devices become widespread, it is critical that these compilers be dependable. This paper considers the problem of ﬁnding bugs in compilers for packet processing in the context of P416. We introduce domain-speciﬁc techniques to induce both abnormal termination of the compiler (crash bugs) and miscompilation (semantic bugs). We apply these techniques to (1) the opensource P4 compiler (P4C) infrastructure, which serves as a common base for different P4 back ends; (2) the P4 back end for the P4 reference software switch; and (3) the P4 back end for the Barefoot Toﬁno switch.},
	pages = {17},
	author = {Ruffy, Fabian and Wang, Tao and Sivaraman, Anirudh},
	langid = {english},
	file = {Ruffy et al. - Gauntlet Finding Bugs in Compilers for Programmab.pdf:/home/fordrl/Zotero/storage/A98KWFZQ/Ruffy et al. - Gauntlet Finding Bugs in Compilers for Programmab.pdf:application/pdf},
}

@online{noauthor_o-ran_nodate,
	title = {O-{RAN} {ALLIANCE}},
	url = {https://www.o-ran.org},
	titleaddon = {O-{RAN} {ALLIANCE}},
	urldate = {2021-01-14},
	langid = {american},
	file = {Snapshot:/home/fordrl/Zotero/storage/MJF4DEJ6/www.o-ran.org.html:text/html},
}

@online{jordan_ultimate_nodate,
	title = {The Ultimate Guide to Open {RAN}: Open {RAN} Intelligent Controller ({RIC}) - Part 2: Implementations},
	url = {https://www.thefastmode.com/expert-opinion/18274-the-ultimate-guide-to-open-ran-open-ran-intelligent-controller-ric-part-2-implementations},
	shorttitle = {The Ultimate Guide to Open {RAN}},
	abstract = {When designing next-gen {RAN}, there are three objectives that need be achieved simultaneously including operation efficiency, automation of configuration and},
	author = {Jordan, Eugina},
	urldate = {2021-01-14},
	langid = {english},
	file = {Snapshot:/home/fordrl/Zotero/storage/LXWAZ8M8/18274-the-ultimate-guide-to-open-ran-open-ran-intelligent-controller-ric-part-2-implementations.html:text/html},
}

@online{jordan_ultimate_nodate-1,
	title = {The Ultimate Guide to Open {RAN}: Open {RAN} Intelligent Controller ({RIC}) - Part 1},
	url = {https://www.thefastmode.com/expert-opinion/18213-the-ultimate-guide-to-open-ran-open-ran-intelligent-controller-ric-part-1},
	shorttitle = {The Ultimate Guide to Open {RAN}},
	abstract = {In 2G and 3G, the mobile architectures had controllers that were responsible for {RAN} orchestration and management. With 4G, overall network architecture},
	author = {Jordan, Eugina},
	urldate = {2021-01-14},
	langid = {english},
	file = {Snapshot:/home/fordrl/Zotero/storage/V7QGGWX6/18213-the-ultimate-guide-to-open-ran-open-ran-intelligent-controller-ric-part-1.html:text/html},
}

@incollection{ahrendt_dione_2019,
	location = {Cham},
	title = {Dione: A Protocol Verification System Built with Dafny for I/O Automata},
	volume = {11918},
	isbn = {978-3-030-34967-7 978-3-030-34968-4},
	url = {http://link.springer.com/10.1007/978-3-030-34968-4_13},
	shorttitle = {Dione},
	abstract = {Input/Output Automata ({IOA}) is an expressive speciﬁcation framework with built-in properties for compositional reasoning. It has been shown to be eﬀective in specifying and analyzing distributed and networked systems. The available veriﬁcation engines for {IOA} are based on interactive theorem provers such as Isabelle, Larch, {PVS}, and Coq, and are expressive but require heavy human interaction. Motivated by the advances in {SMT} solvers, in this work we explore a diﬀerent expressivity-automation tradeoﬀ for {IOA}. We present Dione, the ﬁrst {IOA} analysis system built with Dafny and its {SMT}-powered toolchain and demonstrate its eﬀectiveness on four distributed applications. Our translator tool converts Python-esque Dione language speciﬁcation of {IOA} and their properties to parameterized Dafny modules. Dione automatically generates the relevant compatibility and composition lemmas for the {IOA} speciﬁcations, which can then be checked with Dafny on a per module-basis. We ensure that all resulting formulas are expressed mostly in fragments solvable by {SMT} solvers and hence enables Bounded Model Checking and k-induction-based invariant checking using Z3. We present successful applications of Dione in veriﬁcation of an asynchronous leader election algorithm, two self-stabilizing mutual exclusion algorithms, and {CAN} bus Arbitration. We automatically prove key invariants of all four protocols; for the last three this involves reasoning about arbitrary number of participants. These analyses are largely automatic with minimal manual inputs needed, and they demonstrate the eﬀectiveness of this approach in analyzing networked and distributed systems.},
	pages = {227--245},
	booktitle = {Integrated Formal Methods},
	publisher = {Springer International Publishing},
	author = {Hsieh, Chiao and Mitra, Sayan},
	editor = {Ahrendt, Wolfgang and Tapia Tarifa, Silvia Lizeth},
	urldate = {2021-01-13},
	date = {2019},
	langid = {english},
	doi = {10.1007/978-3-030-34968-4_13},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Hsieh and Mitra - 2019 - Dione A Protocol Verification System Built with D.pdf:/home/fordrl/Zotero/storage/8JJU4YNM/Hsieh and Mitra - 2019 - Dione A Protocol Verification System Built with D.pdf:application/pdf},
}

@inproceedings{hsieh_dione_2019,
	location = {Cham},
	title = {Dione: A Protocol Verification System Built with Dafny for I/O Automata},
	isbn = {978-3-030-34968-4},
	doi = {10.1007/978-3-030-34968-4_13},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Dione},
	abstract = {Input/Output Automata ({IOA}) is an expressive specification framework with built-in properties for compositional reasoning. It has been shown to be effective in specifying and analyzing distributed and networked systems. The available verification engines for {IOA} are based on interactive theorem provers such as Isabelle, Larch, {PVS}, and Coq, and are expressive but require heavy human interaction. Motivated by the advances in {SMT} solvers, in this work we explore a different expressivity-automation tradeoff for {IOA}. We present Dione, the first {IOA} analysis system built with Dafny and its {SMT}-powered toolchain and demonstrate its effectiveness on four distributed applications. Our translator tool converts Python-esque Dione language specification of {IOA} and their properties to parameterized Dafny modules. Dione automatically generates the relevant compatibility and composition lemmas for the {IOA} specifications,which can then be checked with Dafny on a per module-basis. We ensure that all resulting formulas are expressed mostly in fragments solvable by {SMT} solvers and hence enables Bounded Model Checking and k-induction-based invariant checking using Z3. We present successful applications of Dione in verification of an asynchronous leader election algorithm, two self-stabilizing mutual exclusion algorithms, and {CAN} bus Arbitration. We automatically prove key invariants of all four protocols; for the last three this involves reasoning about arbitrary number of participants. These analyses are largely automatic with minimal manual inputs needed, and they demonstrate the effectiveness of this approach in analyzing networked and distributed systems.},
	pages = {227--245},
	booktitle = {Integrated Formal Methods},
	publisher = {Springer International Publishing},
	author = {Hsieh, Chiao and Mitra, Sayan},
	editor = {Ahrendt, Wolfgang and Tapia Tarifa, Silvia Lizeth},
	date = {2019},
	langid = {english},
}

@article{bosshart_programming_2014,
	title = {Programming Protocol-Independent Packet Processors},
	url = {http://arxiv.org/abs/1312.1719},
	abstract = {P4 is a high-level language for programming protocol-independent packet processors. P4 works in conjunction with {SDN} control protocols like {OpenFlow}. In its current form, {OpenFlow} explicitly specifies protocol headers on which it operates. This set has grown from 12 to 41 fields in a few years, increasing the complexity of the specification while still not providing the flexibility to add new headers. In this paper we propose P4 as a strawman proposal for how {OpenFlow} should evolve in the future. We have three goals: (1) Reconfigurability in the field: Programmers should be able to change the way switches process packets once they are deployed. (2) Protocol independence: Switches should not be tied to any specific network protocols. (3) Target independence: Programmers should be able to describe packet-processing functionality independently of the specifics of the underlying hardware. As an example, we describe how to use P4 to configure a switch to add a new hierarchical label.},
	journaltitle = {{arXiv}:1312.1719 [cs]},
	author = {Bosshart, Pat and Daly, Dan and Izzard, Martin and {McKeown}, Nick and Rexford, Jennifer and Schlesinger, Cole and Talayco, Dan and Vahdat, Amin and Varghese, George and Walker, David},
	urldate = {2021-01-13},
	date = {2014-05-15},
	eprinttype = {arxiv},
	eprint = {1312.1719},
	keywords = {Computer Science - Networking and Internet Architecture},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/FFEPQ2TK/1312.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/5I8B9SND/Bosshart et al. - 2014 - Programming Protocol-Independent Packet Processors.pdf:application/pdf},
}

@article{bjorner_formal_2015,
	title = {Formal Foundations for Networking (Dagstuhl Seminar 15071)},
	volume = {5},
	issn = {2192-5283},
	url = {http://drops.dagstuhl.de/opus/volltexte/2015/5044},
	doi = {10.4230/DagRep.5.2.44},
	pages = {44--63},
	number = {2},
	journaltitle = {Dagstuhl Reports},
	author = {Bjorner, Nikolaj and Foster, Nate and Godfrey, Philip Brighten and Zave, Pamela},
	editor = {Bjorner, Nikolaj and Foster, Nate and Godfrey, Philip Brighten and Zave, Pamela},
	urldate = {2021-01-12},
	date = {2015},
	note = {Place: Dagstuhl, Germany
Publisher: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik},
	keywords = {logic, model checking, security, software-defined networking, verification, Formal methods, middleboxes, networking, program synthesis},
	file = {Snapshot:/home/fordrl/Zotero/storage/PAFCN7QD/5044.html:text/html;Full Text PDF:/home/fordrl/Zotero/storage/TNWDDD2F/Bjorner et al. - 2015 - Formal Foundations for Networking (Dagstuhl Semina.pdf:application/pdf},
}

@inproceedings{stoenescu_debugging_2018,
	location = {New York, {NY}, {USA}},
	title = {Debugging P4 programs with vera},
	isbn = {978-1-4503-5567-4},
	url = {https://doi.org/10.1145/3230543.3230548},
	doi = {10.1145/3230543.3230548},
	series = {{SIGCOMM} '18},
	abstract = {We present Vera, a tool that verifies P4 programs using symbolic execution. Vera automatically uncovers a number of common bugs including parsing/deparsing errors, invalid memory accesses, loops and tunneling errors, among others. Vera can also be used to verify user-specified properties in a novel language we call {NetCTL}. To enable scalable, exhaustive verification of P4 program snapshots, Vera automatically generates all valid header layouts and uses a novel data-structure for match-action processing optimized for verification. These techniques allow Vera to scale very well: it only takes between 5s-15s to track the execution of a purely symbolic packet in the largest P4 program currently available (6KLOC) and can compute {SEFL} model updates in milliseconds. Vera can also explore multiple concrete dataplanes at once by allowing the programmer to insert symbolic table entries; the resulting verification highlights possible control plane errors. We have used Vera to analyze many P4 programs including the P4 tutorials, P4 programs in the research literature and the switch code from https://p4.org. Vera has found several bugs in each of them in seconds/minutes.},
	pages = {518--532},
	booktitle = {Proceedings of the 2018 Conference of the {ACM} Special Interest Group on Data Communication},
	publisher = {Association for Computing Machinery},
	author = {Stoenescu, Radu and Dumitrescu, Dragos and Popovici, Matei and Negreanu, Lorina and Raiciu, Costin},
	urldate = {2021-01-12},
	date = {2018-08-07},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/7S3Y248W/Stoenescu et al. - 2018 - Debugging P4 programs with vera.pdf:application/pdf},
}

@article{doenges_petr4_2020,
	title = {Petr4: Formal Foundations for P4 Data Planes},
	url = {http://arxiv.org/abs/2011.05948},
	shorttitle = {Petr4},
	abstract = {P4 is a domain-specific language for programming and specifying packet-processing systems. It is based on an elegant design with high-level abstractions like parsers and match-action pipelines that can be compiled to efficient implementations in software or hardware. Unfortunately, like many industrial languages, P4 has developed without a formal foundation. The P4 Language Specification is a 160-page document with a mixture of informal prose, graphical diagrams, and pseudocode. The P4 reference implementation is a complex system, running to over 40KLoC of C++ code. Clearly neither of these artifacts is suitable for formal reasoning. This paper presents a new framework, called Petr4, that puts P4 on a solid foundation. Petr4 consists of a clean-slate definitional interpreter and a calculus that models the semantics of a core fragment of P4. Throughout the specification, some aspects of program behavior are left up to targets. Our interpreter is parameterized over a target interface which collects all the target-specific behavior in the specification in a single interface. The specification makes ad-hoc restrictions on the nesting of certain program constructs in order to simplify compilation and avoid the possibility of nonterminating programs. We captured the latter intention in our core calculus by stratifying its type system, rather than imposing unnatural syntactic restrictions, and we proved that all programs in this core calculus terminate. We have validated the interpreter against a suite of over 750 tests from the P4 reference implementation, exercising our target interface with tests for different targets. We established termination for the core calculus by induction on the stratified type system. While developing Petr4, we reported dozens of bugs in the language specification and the reference implementation, many of which have been fixed.},
	journaltitle = {{arXiv}:2011.05948 [cs]},
	author = {Doenges, Ryan and Arashloo, Mina Tahmasbi and Bautista, Santiago and Chang, Alexander and Ni, Newton and Parkinson, Samwise and Peterson, Rudy and Solko-Breslin, Alaia and Xu, Amanda and Foster, Nate},
	urldate = {2021-01-12},
	date = {2020-11-11},
	eprinttype = {arxiv},
	eprint = {2011.05948},
	keywords = {Computer Science - Programming Languages, Computer Science - Networking and Internet Architecture},
	file = {arXiv.org Snapshot:/home/fordrl/Zotero/storage/2APBCUP8/2011.html:text/html;arXiv Fulltext PDF:/home/fordrl/Zotero/storage/LELLPA8B/Doenges et al. - 2020 - Petr4 Formal Foundations for P4 Data Planes.pdf:application/pdf},
}

@article{foster_using_2020,
	title = {Using deep programmability to put network owners in control},
	volume = {50},
	issn = {0146-4833},
	url = {https://doi.org/10.1145/3431832.3431842},
	doi = {10.1145/3431832.3431842},
	abstract = {Controlling an opaque system by reading some "dials" and setting some "knobs," without really knowing what they do, is a hazardous and fruitless endeavor, particularly at scale. What we need are transparent networks, that start at the top with a high-level intent and map all the way down, through the control plane to the data plane. If we can specify the behavior we want in software, then we can check that the system behaves as we expect. This is impossible if the implementation is opaque. We therefore need to use open-source software or write it ourselves (or both), and have mechanisms for checking actual behavior against the specified intent. With fine-grain checking (e.g., every packet, every state variable), we can build networks that are more reliable, secure, and performant. In the limit, we can build networks that run autonomously under verifiable, closed-loop control. We believe this vision, while ambitious, is finally within our reach, due to deep programmability across the stack, both vertically (control and data plane) and horizontally (end to end). It will emerge naturally in some networks, as network owners take control of their software and engage in open-source efforts; whereas in enterprise networks it may take longer. In 5G access networks, there is a pressing need for our community to engage, so these networks, too, can operate autonomously under verifiable, closed-loop control.},
	pages = {82--88},
	number = {4},
	journaltitle = {{ACM} {SIGCOMM} Computer Communication Review},
	shortjournal = {{SIGCOMM} Comput. Commun. Rev.},
	author = {Foster, Nate and {McKeown}, Nick and Rexford, Jennifer and Parulkar, Guru and Peterson, Larry and Sunay, Oguz},
	urldate = {2021-01-10},
	date = {2020-10-26},
	keywords = {network verification, programmable networks, software defined networks ({SDN}), telemetry},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/286YIG6A/Foster et al. - 2020 - Using deep programmability to put network owners i.pdf:application/pdf},
}

@article{campbell_avenir_nodate,
	title = {Avenir: Managing Data Plane Diversity with Control Plane Synthesis},
	abstract = {The classical conception of software-deﬁned networking ({SDN}) is based on an attractive myth: a logically centralized controller manages a collection of homogeneous data planes. In reality, however, {SDN} control planes must deal with signiﬁcant diversity in hardware, drivers, interfaces, and protocols, all of which contribute to idiosyncratic differences in forwarding behavior that must be dealt with by hand.},
	pages = {21},
	author = {Campbell, Eric Hayden and Ramamurthy, Vignesh and Hallahan, William T and Srikumar, Priya and Cascone, Carmelo and Liu, Jed and Hojjat, Hossein and Piskac, Ruzica and Soulé, Robert and Foster, Nate},
	langid = {english},
	file = {Campbell et al. - Avenir Managing Data Plane Diversity with Control.pdf:/home/fordrl/Zotero/storage/3AG7J7NS/Campbell et al. - Avenir Managing Data Plane Diversity with Control.pdf:application/pdf},
}

@article{shi_network_2021,
	title = {Network Traﬃc Classiﬁcation by Program Synthesis},
	abstract = {Writing classiﬁcation rules to identify interesting network traﬃc is a time-consuming and error-prone task. Learning-based classiﬁcation systems automatically extract such rules from positive and negative traﬃc examples. However, due to limitations in the representation of network traﬃc and the learning strategy, these systems lack both expressiveness to cover a range of applications and interpretability in fully describing the traﬃc’s structure at the session layer. This paper presents Sharingan system, which uses program synthesis techniques to generate network classiﬁcation programs at the session layer. Sharingan accepts raw network traces as inputs and reports potential patterns of the target traﬃc in {NetQRE}, a domain speciﬁc language designed for specifying session-layer quantitative properties. We develop a range of novel optimizations that reduce the synthesis time for large and complex tasks to a matter of minutes. Our experiments show that Sharingan is able to correctly identify patterns from a diverse set of network traces and generates explainable outputs, while achieving accuracy comparable to state-of-the-art learning-based systems.},
	pages = {19},
	journaltitle = {{TACAS}21},
	author = {Shi, Lei and Li, Yahui and Loo, Boon Thau and Alur, Rajeev},
	date = {2021},
	langid = {english},
	file = {Shi et al. - Network Traﬃc Classiﬁcation by Program Synthesis.pdf:/home/fordrl/Zotero/storage/TI5Z97IG/Shi et al. - Network Traﬃc Classiﬁcation by Program Synthesis.pdf:application/pdf},
}

@online{eichholz_dependently-typed_nodate,
	title = {Dependently-Typed Data Plane Programming},
	url = {https://ericthewry.github.io/pdfs/pi4.pdf},
	author = {Eichholz, Matthias},
	urldate = {2021-12-07},
	file = {pi4.pdf:/home/fordrl/Zotero/storage/TTRNRXJW/pi4.pdf:application/pdf},
}

@article{eichholz_dependently-typed_2022,
	title = {Dependently-typed data plane programming},
	volume = {6},
	url = {https://doi.org/10.1145/3498701},
	doi = {10.1145/3498701},
	abstract = {Programming languages like P4 enable specifying the behavior of network data planes in software. However, with increasingly powerful and complex applications running in the network, the risk of faults also increases. Hence, there is growing recognition of the need for methods and tools to statically verify the correctness of P4 code, especially as the language lacks basic safety guarantees. Type systems are a lightweight and compositional way to establish program properties, but there is a significant gap between the kinds of properties that can be proved using simple type systems (e.g., {SafeP}4) and those that can be obtained using full-blown verification tools (e.g., p4v). In this paper, we close this gap by developing Π4, a dependently-typed version of P4 based on decidable refinements. We motivate the design of Π4, prove the soundness of its type system, develop an {SMT}-based implementation, and present case studies that illustrate its applicability to a variety of data plane programs.},
	pages = {40:1--40:28},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Eichholz, Matthias and Campbell, Eric Hayden and Krebs, Matthias and Foster, Nate and Mezini, Mira},
	urldate = {2022-01-21},
	date = {2022-01-11},
	keywords = {Dependent Types, Software-Defined Networking, P4},
	file = {Full Text PDF:/home/fordrl/Zotero/storage/M7DV6WA3/Eichholz et al. - 2022 - Dependently-typed data plane programming.pdf:application/pdf},
}