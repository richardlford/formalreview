
@article{calcagno_compositional_2011,
	title = {Compositional Shape Analysis by Means of Bi-Abduction},
	volume = {58},
	issn = {00045411},
	url = {http://dl.acm.org/citation.cfm?doid=2049697.2049700},
	doi = {10.1145/2049697.2049700},
	pages = {1--66},
	number = {6},
	journaltitle = {Journal of the {ACM}},
	author = {Calcagno, Cristiano and Distefano, Dino and O’Hearn, Peter W. and Yang, Hongseok},
	urldate = {2019-01-30},
	date = {2011-12-01},
	langid = {english},
	file = {Submitted Version:/Users/richardford/Zotero/storage/F7XZGISE/Calcagno et al. - 2011 - Compositional Shape Analysis by Means of Bi-Abduct.pdf:application/pdf}
}

@inproceedings{krishnan_modelling_2018,
	location = {Bengaluru},
	title = {Modelling and validating 1553B protocol using the {SPIN} model checker},
	isbn = {978-1-5386-1182-1},
	url = {http://ieeexplore.ieee.org/document/8328247/},
	doi = {10.1109/COMSNETS.2018.8328247},
	eventtitle = {2018 10th International Conference on Communication Systems \& Networks ({COMSNETS})},
	pages = {472--475},
	booktitle = {2018 10th International Conference on Communication Systems \& Networks ({COMSNETS})},
	publisher = {{IEEE}},
	author = {Krishnan, Ranjani and Lalithambika, V R},
	urldate = {2019-01-31},
	date = {2018-01},
	note = {1553B/08328247.pdf}
}

@article{jung_rustbelt:_2017,
	title = {{RustBelt}: securing the foundations of the rust programming language},
	volume = {2},
	issn = {24751421},
	url = {http://dl.acm.org/citation.cfm?doid=3177123.3158154},
	doi = {10.1145/3158154},
	shorttitle = {{RustBelt}},
	pages = {1--34},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
	urldate = {2019-01-31},
	date = {2017-12-27},
	langid = {english},
	file = {Full Text:/Users/richardford/Zotero/storage/8KU8PUZ4/Jung et al. - 2017 - RustBelt securing the foundations of the rust pro.pdf:application/pdf}
}

@article{ohearn_separation_2019,
	title = {Separation logic},
	volume = {62},
	issn = {00010782},
	url = {http://dl.acm.org/citation.cfm?doid=3310134.3211968},
	doi = {10.1145/3211968},
	pages = {86--95},
	number = {2},
	journaltitle = {Communications of the {ACM}},
	author = {O'Hearn, Peter},
	urldate = {2019-01-31},
	date = {2019-01-28},
	langid = {english}
}

@misc{ohearn_peter_nodate,
	title = {Peter W O'hearn - acm profile},
	url = {https://dl.acm.org/author_page.cfm?id=81332519314&coll=DL&dl=ACM&trk=0},
	author = {O'Hearn, Peter W.}
}

@article{gorogiannis_true_2019,
	title = {A true positives theorem for a static race detector},
	volume = {3},
	issn = {24751421},
	url = {http://dl.acm.org/citation.cfm?doid=3302515.3290370},
	doi = {10.1145/3290370},
	pages = {1--29},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	author = {Gorogiannis, Nikos and O'Hearn, Peter W. and Sergey, Ilya},
	urldate = {2019-01-31},
	date = {2019-01-02},
	langid = {english},
	file = {Submitted Version:/Users/richardford/Zotero/storage/4765ZUM2/Gorogiannis et al. - 2019 - A true positives theorem for a static race detecto.pdf:application/pdf}
}

@inproceedings{ohearn_continuous_2018,
	location = {Oxford, United Kingdom},
	title = {Continuous Reasoning: Scaling the impact of formal methods},
	isbn = {978-1-4503-5583-4},
	url = {http://dl.acm.org/citation.cfm?doid=3209108.3209109},
	doi = {10.1145/3209108.3209109},
	shorttitle = {Continuous Reasoning},
	eventtitle = {the 33rd Annual {ACM}/{IEEE} Symposium},
	pages = {13--25},
	booktitle = {Proceedings of the 33rd Annual {ACM}/{IEEE} Symposium on Logic in Computer Science  - {LICS} '18},
	publisher = {{ACM} Press},
	author = {O'Hearn, Peter W.},
	urldate = {2019-01-31},
	date = {2018},
	langid = {english},
	file = {Full Text:/Users/richardford/Zotero/storage/CTESDFKX/O'Hearn - 2018 - Continuous Reasoning Scaling the impact of formal.pdf:application/pdf}
}

@article{brookes_concurrent_2016,
	title = {Concurrent Separation Logic},
	volume = {3},
	issn = {2372-3491},
	url = {http://doi.acm.org/10.1145/2984450.2984457},
	doi = {10.1145/2984450.2984457},
	pages = {47--65},
	number = {3},
	journaltitle = {{ACM} {SIGLOG} News},
	author = {Brookes, Stephen and O'Hearn, Peter W.},
	date = {2016-08}
}

@article{brookes_semantics_2007,
	title = {A semantics for concurrent separation logic},
	volume = {375},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0304397506009248},
	doi = {10.1016/j.tcs.2006.12.034},
	pages = {227--270},
	number = {1},
	journaltitle = {Theoretical Computer Science},
	author = {Brookes, Stephen},
	urldate = {2019-01-31},
	date = {2007-05},
	langid = {english},
	file = {Submitted Version:/Users/richardford/Zotero/storage/E2WWQBZ9/Brookes - 2007 - A semantics for concurrent separation logic.pdf:application/pdf}
}

@inproceedings{ohearn_categorical_2015,
	location = {Washington, {DC}, {USA}},
	title = {From Categorical Logic to Facebook Engineering},
	isbn = {978-1-4799-8875-4},
	url = {https://doi.org/10.1109/LICS.2015.11},
	doi = {10.1109/LICS.2015.11},
	series = {{LICS} '15},
	pages = {17--20},
	booktitle = {Proceedings of the 2015 30th Annual {ACM}/{IEEE} Symposium on Logic in Computer Science ({LICS})},
	publisher = {{IEEE} Computer Society},
	author = {O'Hearn, Peter},
	urldate = {2019-01-31},
	date = {2015},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/TX6UGV37/O'Hearn - 2015 - From Categorical Logic to Facebook Engineering.pdf:application/pdf}
}

@inreference{wikipedia_category:formal_2017,
	title = {Category:Formal methods people},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Category:Formal_methods_people&oldid=812800009},
	shorttitle = {Category},
	abstract = {People involved with formal methods.},
	booktitle = {Wikipedia},
	author = {Wikipedia},
	urldate = {2019-01-31},
	date = {2017-11-29},
	langid = {english},
	note = {Page Version {ID}: 812800009},
	file = {Snapshot:/Users/richardford/Zotero/storage/652994AH/index.html:text/html}
}

@article{qureshi_formal_nodate,
	title = {Formal Modelling and Analysis of Mission-Critical Software in Military Avionics Systems},
	url = {http://crpit.com/confpapers/CRPITV69Qureshi.pdf},
	abstract = {A typical avionics mission system of a military aircraft is a complex real-time system consisting of a mission control computer, different kinds of sensors, navigation and communication subsystems, and various displays and stores; all interconnected by a number of serial data buses. The mission capability is increasingly implemented in the mission-critical software and the robustness of this software is vital for mission success. The complexity and real-time requirements of mission systems represent major challenges to the Australian Defence Force during new acquisitions, upgrades and maintenance. This paper describes the experiences on a joint research project between the University of South Australia and Australia’s Defence Science and Technology Organisation into the modelling and analysis of avionics mission systems. The paper provides a summary of the key aspects of our previous research work on the modelling of a generic mission system using Coloured Petri Nets and the analysis of task scheduling on the mission computer. Finally, the paper briefly discusses the extension of the generic model to obtain a formal model of the mission system of the {AP}3C Orion maritime surveillance aircraft..},
	pages = {11},
	journaltitle = {11th Australian Workshop on Safety Related Programmable Systems ({SCS}’06)},
	author = {Qureshi, Zahid H},
	langid = {english},
	file = {Qureshi - Formal Modelling and Analysis of Mission-Critical .pdf:/Users/richardford/Zotero/storage/9N3AY53T/Qureshi - Formal Modelling and Analysis of Mission-Critical .pdf:application/pdf}
}

@inproceedings{conchon_alt-ergo_2018,
	location = {Oxford, United Kingdom},
	title = {Alt-Ergo 2.2},
	url = {https://hal.inria.fr/hal-01960203},
	abstract = {Alt-Ergo is an {SMT} solver jointly developed by Université Paris-Sud and the {OCamlPro} company. The first version was released in 2006. Since then, its architecture has been continuously adapted for proving formulas generated by software development frameworks. As type systems with polymorphism arise naturally is such platforms, the design of Alt-Ergo has been guided (and constrained) by a native-and non {SMT}-{LIB} compliant-input language for a polymorphic first-order logic. In this paper, we present the last version of Alt-Ergo, its architecture and main features. The main recent work is a support for a conservative polymorphic extension of the {SMT}-{LIB} 2 standard. We measure Alt-Ergo's performances with this new frontend on a set of benchmarks coming from the deductive program verification systems Frama-C, {SPARK} 2014, Why3 and Atelier-B, as well as from the {SMT}-{LIB} benchmarks library.},
	booktitle = {{SMT} Workshop: International Workshop on Satisfiability Modulo Theories},
	author = {Conchon, Sylvain and Coquereau, Albin and Iguernlala, Mohamed and Mebsout, Alain},
	urldate = {2019-01-31},
	date = {2018-07},
	note = {alt-ergo/Alt-Ergo-2.2--{SMT}-Workshop-2018.pdf},
	file = {HAL PDF Full Text:/Users/richardford/Zotero/storage/WC8K3BIA/Conchon et al. - 2018 - Alt-Ergo 2.2.pdf:application/pdf}
}

@inproceedings{conchon_increasing_2016,
	title = {Increasing Proofs Automation Rate of Atelier-B Thanks to Alt-Ergo},
	isbn = {978-3-319-33951-1},
	series = {Lecture Notes in Computer Science},
	abstract = {In this paper, we report on our recent improvements in the Alt-Ergo {SMT} solver to make it effective in discharging proof obligations ({POs}) translated from the Atelier-B framework. In particular, we made important modifications in its internal data structures to boost performances of its core decision procedures, we improved quantifiers instantiation heuristics, and enhanced the interaction between the {SAT} solver and the decision procedures. We also introduced a new plugin architecture to facilitate experiments with different {SAT} engines, and implemented a profiling plugin to track and identify “bottlenecks” when a formula requires a long time to be discharged, or makes the solver timeout. Experiments made with more than 10,000 {POs} generated from real industrial B projects show significant improvements compared to both previous versions of Alt-Ergo and Atelier-B’s automatic main prover.},
	pages = {243--253},
	booktitle = {Reliability, Safety, and Security of Railway Systems. Modelling, Analysis, Verification, and Certification},
	publisher = {Springer International Publishing},
	author = {Conchon, Sylvain and Iguernlala, Mohamed},
	editor = {Lecomte, Thierry and Pinger, Ralf and Romanovsky, Alexander},
	date = {2016},
	langid = {english},
	note = {alt-ergo/Alt-Ergo--Atelier-B--{RSSR}-2016.pdf},
	keywords = {B method, B proof obligations, {SMT} solvers},
	file = {Conchon and Iguernlala - Increasing Proofs Automation Rate of Thanks to Ate.pdf:/Users/richardford/Zotero/storage/RG6FY56C/Conchon and Iguernlala - Increasing Proofs Automation Rate of Thanks to Ate.pdf:application/pdf}
}

@article{altenkirch_quotient_2018,
	title = {Quotient inductive-inductive types},
	volume = {10803},
	url = {http://arxiv.org/abs/1612.02346},
	doi = {10.1007/978-3-319-89366-2_16},
	abstract = {Higher inductive types ({HITs}) in Homotopy Type Theory ({HoTT}) allow the definition of datatypes which have constructors for equalities over the defined type. {HITs} generalise quotient types and allow to define types which are not sets in the sense of {HoTT} (i.e. do not satisfy uniqueness of equality proofs) such as spheres, suspensions and the torus. However, there are also interesting uses of {HITs} to define sets, such as the Cauchy reals, the partiality monad, and the internal, total syntax of type theory. In each of these examples we define several types that depend on each other mutually, i.e. they are inductive-inductive definitions. We call those {HITs} quotient inductive-inductive types ({QIITs}). Although there has been recent progress on the general theory of {HITs}, there isn't yet a theoretical foundation of the combination of equality constructors and induction-induction, despite having many interesting applications. In the present paper we present a first step towards a semantic definition of {QIITs}. In particular, we give an initial-algebra semantics and show that this is equivalent to the section induction principle, which justifies the intuitively expected elimination rules.},
	pages = {293--310},
	journaltitle = {{arXiv}:1612.02346 [cs]},
	author = {Altenkirch, Thorsten and Capriotti, Paolo and Dijkstra, Gabe and Kraus, Nicolai and Forsberg, Fredrik Nordvall},
	urldate = {2019-01-31},
	date = {2018},
	eprinttype = {arxiv},
	eprint = {1612.02346,},
	note = {altenkirch/Quotient\_inductive-inductive\_types.pdf},
	keywords = {03B15 (Primary) 18C10 (Secondary), Computer Science - Logic in Computer Science},
	file = {arXiv\:1612.02346 PDF:/Users/richardford/Zotero/storage/I6YHMRQZ/Altenkirch et al. - 2018 - Quotient inductive-inductive types.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/BQTKDAZL/1612.html:text/html}
}

@inproceedings{hritcu_micro-policies:_2015,
	location = {Prague, Czech Republic},
	title = {Micro-Policies: Formally Verified, Tag-Based Security Monitors},
	isbn = {978-1-4503-3661-1},
	url = {http://dl.acm.org/citation.cfm?doid=2786558.2786560},
	doi = {10.1145/2786558.2786560},
	shorttitle = {Micro-Policies},
	eventtitle = {the 10th {ACM} Workshop},
	pages = {1--1},
	booktitle = {Proceedings of the 10th {ACM} Workshop on Programming Languages and Analysis for Security - {PLAS}'15},
	publisher = {{ACM} Press},
	author = {Hriţcu, Cǎtǎlin},
	urldate = {2019-01-31},
	date = {2015},
	langid = {english},
	note = {amorim/nicro-policies.pdf}
}

@inproceedings{hobor_theory_2010,
	location = {New York, {NY}, {USA}},
	title = {A Theory of Indirection via Approximation},
	isbn = {978-1-60558-479-9},
	url = {http://doi.acm.org/10.1145/1706299.1706322},
	doi = {10.1145/1706299.1706322},
	series = {{POPL} '10},
	abstract = {Building semantic models that account for various kinds of indirect reference has traditionally been a difficult problem. Indirect reference can appear in many guises, such as heap pointers, higher-order functions, object references, and shared-memory mutexes. We give a general method to construct models containing indirect reference by presenting a "theory of indirection". Our method can be applied in a wide variety of settings and uses only simple, elementary mathematics. In addition to various forms of indirect reference, the resulting models support powerful features such as impredicative quantification and equirecursion; moreover they are compatible with the kind of powerful substructural accounting required to model (higher-order) separation logic. In contrast to previous work, our model is easy to apply to new settings and has a simple axiomatization, which is complete in the sense that all models of it are isomorphic. Our proofs are machine-checked in Coq.},
	pages = {171--184},
	booktitle = {Proceedings of the 37th Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Hobor, Aquinas and Dockins, Robert and Appel, Andrew W.},
	urldate = {2019-01-31},
	date = {2010},
	keywords = {indirection theory, step-indexed models},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/LDZGVN4K/Hobor et al. - 2010 - A Theory of Indirection via Approximation.pdf:application/pdf}
}

@article{cao_vst-floyd:_2018,
	title = {{VST}-Floyd: A Separation Logic Tool to Verify Correctness of C Programs},
	volume = {61},
	issn = {0168-7433},
	url = {https://doi.org/10.1007/s10817-018-9457-5},
	doi = {10.1007/s10817-018-9457-5},
	shorttitle = {{VST}-Floyd},
	abstract = {The Verified Software Toolchain builds foundational machine-checked proofs of the functional correctness of C programs. Its program logic, Verifiable C, is a shallowly embedded higher-order separation Hoare logic which is proved sound in Coq with respect to the operational semantics of {CompCert} Clight. This paper introduces {VST}-Floyd, a verification assistant which offers a set of semiautomatic tactics helping users build functional correctness proofs for C programs using Verifiable C.},
	pages = {367--422},
	number = {1},
	journaltitle = {J. Autom. Reason.},
	author = {Cao, Qinxiang and Beringer, Lennart and Gruetter, Samuel and Dodds, Josiah and Appel, Andrew W.},
	urldate = {2019-01-31},
	date = {2018-06},
	keywords = {Program verification, Proof automation, Separation logic, Symbolic execution},
	file = {Cao et al. - 2018 - VST-Floyd A Separation Logic Tool to Verify Corre.pdf:/Users/richardford/Zotero/storage/FCBL8RIJ/Cao et al. - 2018 - VST-Floyd A Separation Logic Tool to Verify Corre.pdf:application/pdf}
}

@incollection{hutchison_verified_2014,
	location = {Berlin, Heidelberg},
	title = {Verified Compilation for Shared-Memory C},
	volume = {8410},
	isbn = {978-3-642-54832-1 978-3-642-54833-8},
	url = {http://link.springer.com/10.1007/978-3-642-54833-8_7},
	pages = {107--127},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Beringer, Lennart and Stewart, Gordon and Dockins, Robert and Appel, Andrew W.},
	editor = {Shao, Zhong},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2019-01-31},
	date = {2014},
	doi = {10.1007/978-3-642-54833-8_7,},
	note = {appel/shmemc.pdf is a preview},
	file = {Full Text:/Users/richardford/Zotero/storage/TXJ95W6N/Beringer et al. - 2014 - Verified Compilation for Shared-Memory C.pdf:application/pdf}
}

@book{appel_verifiabble_2014,
	location = {Cambridge},
	title = {Verifiabble C, Version 2.2},
	isbn = {978-1-107-25655-2},
	url = {http://ebooks.cambridge.org/ref/id/CBO9781107256552},
	publisher = {Cambridge University Press},
	author = {Appel, Andrew W. and Dockins, Robert and Hobor, Aquinas and Beringer, Lennart and Dodds, Josiah and Stewart, Gordon and Blazy, Sandrine and Leroy, Xavier},
	urldate = {2019-01-31},
	date = {2014},
	langid = {english},
	doi = {10.1017/CBO9781107256552},
	file = {Verifiable C Version 2.2:/Users/richardford/Zotero/storage/GRBISGXR/Appel et al. - 2014 - Program Logics for Certified Compilers.pdf:application/pdf}
}

@article{appel_verification_2015,
	title = {Verification of a Cryptographic Primitive: {SHA}-256},
	volume = {37},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/2701415},
	doi = {10.1145/2701415},
	shorttitle = {Verification of a Cryptographic Primitive},
	abstract = {This article presents a full formal machine-checked verification of a C program: the {OpenSSL} implementation of {SHA}-256. This is an interactive proof of functional correctness in the Coq proof assistant, using the Verifiable C program logic. Verifiable C is a separation logic for the C language, proved sound with respect to the operational semantics for C, connected to the {CompCert} verified optimizing C compiler.},
	pages = {7:1--7:31},
	number = {2},
	journaltitle = {{ACM} Trans. Program. Lang. Syst.},
	author = {Appel, Andrew W.},
	urldate = {2019-01-31},
	date = {2015-04},
	keywords = {Cryptography},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/8N6RDMZK/Appel - 2015 - Verification of a Cryptographic Primitive SHA-256.pdf:application/pdf}
}

@incollection{jouannaud_verismall:_2011,
	location = {Berlin, Heidelberg},
	title = {{VeriSmall}: Verified Smallfoot Shape Analysis},
	volume = {7086},
	isbn = {978-3-642-25378-2 978-3-642-25379-9},
	url = {http://link.springer.com/10.1007/978-3-642-25379-9_18},
	shorttitle = {{VeriSmall}},
	pages = {231--246},
	booktitle = {Certified Programs and Proofs},
	publisher = {Springer Berlin Heidelberg},
	author = {Appel, Andrew W.},
	editor = {Jouannaud, Jean-Pierre and Shao, Zhong},
	urldate = {2019-01-31},
	date = {2011},
	doi = {10.1007/978-3-642-25379-9_18},
	file = {Submitted Version:/Users/richardford/Zotero/storage/98T3SKZJ/Appel - 2011 - VeriSmall Verified Smallfoot Shape Analysis.pdf:application/pdf}
}

@inproceedings{stewart_verified_2012,
	location = {New York, {NY}, {USA}},
	title = {Verified Heap Theorem Prover by Paramodulation},
	isbn = {978-1-4503-1054-3},
	url = {http://doi.acm.org/10.1145/2364527.2364531},
	doi = {10.1145/2364527.2364531},
	series = {{ICFP} '12},
	abstract = {We present {VeriStar}, a verified theorem prover for a decidable subset of separation logic. Together with {VeriSmall} [3], a proved-sound Smallfoot-style program analysis for C minor, {VeriStar} demonstrates that fully machine-checked static analyses equipped with efficient theorem provers are now within the reach of formal methods. As a pair, {VeriStar} and {VeriSmall} represent the first application of the Verified Software Toolchain [4], a tightly integrated collection of machine-verified program logics and compilers giving foundational correctness guarantees. {VeriStar} is (1) purely functional, (2) machine-checked, (3) end-to-end, (4) efficient and (5) modular. By purely functional, we mean it is implemented in Gallina, the pure functional programming language embedded in the Coq theorem prover. By machine-checked, we mean it has a proof in Coq that when the prover says "valid", the checked entailment holds in a proved-sound separation logic for C minor. By end-to-end, we mean that when the static analysis+theorem prover says a C minor program is safe, the program will be compiled to a semantically equivalent assembly program that runs on real hardware. By efficient, we mean that the prover implements a state-of-the-art algorithm for deciding heap entailments and uses highly tuned verified functional data structures. By modular, we mean that {VeriStar} can be retrofitted to other static analyses as a plug-compatible entailment checker and its soundness proof can easily be ported to other separation logics.},
	pages = {3--14},
	booktitle = {Proceedings of the 17th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {Stewart, Gordon and Beringer, Lennart and Appel, Andrew W.},
	urldate = {2019-01-31},
	date = {2012},
	keywords = {paramodulation, separation logic, theorem proving},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/99IVRGUA/Stewart et al. - 2012 - Verified Heap Theorem Prover by Paramodulation.pdf:application/pdf}
}

@inproceedings{appel_verified_2012,
	location = {Berlin, Heidelberg},
	title = {Verified Software Toolchain},
	isbn = {978-3-642-28890-6},
	url = {http://dx.doi.org/10.1007/978-3-642-28891-3_2},
	doi = {10.1007/978-3-642-28891-3_2},
	series = {{NFM}'12},
	abstract = {The software toolchain includes static analyzers to check assertions about programs; optimizing compilers to translate programs to machine language; operating systems and libraries to supply context for programs. Our Verified Software Toolchain verifies with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context, on a weakly-consistent-shared-memory machine. Our verification approach is modular, in that proofs about operating systems or concurrency libraries are oblivious of the programming language or machine language, proofs about compilers are oblivious of the program logic used to verify static analyzers, and so on. The approach is scalable, in that each component is verified in the semantic idiom most natural for that component. Finally, the verification is foundational: the trusted base for proofs of observable properties of the machine-language program includes only the operational semantics of the machine language, not the source language, the compiler, the program logic, or any other part of the toolchain--even when these proofs are carried out by source-level static analyzers. In this paper I explain the construction of a a verified toolchain, using the Coq proof assistant. I will illustrate with shape analysis for C programs based on separation logic.},
	pages = {2--2},
	booktitle = {Proceedings of the 4th International Conference on {NASA} Formal Methods},
	publisher = {Springer-Verlag},
	author = {Appel, Andrew W.},
	urldate = {2019-01-31},
	date = {2012},
	file = {Submitted Version:/Users/richardford/Zotero/storage/I5S7W94U/Appel - 2012 - Verified Software Toolchain.pdf:application/pdf}
}

@inproceedings{kastner_program_2015,
	location = {Paris, France},
	title = {Program Analysis on Evolving Software},
	url = {https://hal.archives-ouvertes.fr/hal-01192985},
	abstract = {Static analysis is well-suited for continuous verification during the software development stage since it only works on the source code and does not require a running system for testing. However, applying the program analysis during software development means that the analysis has to cope with evolving software and evolving analyzer configurations, especially in a model-based development process. In this article we present a unique history-aware concept for program analysis that has been developed for the static analyzer Astrée. It not only provides the ability to backtrack and access previous versions of the analysis configuration, it can also automatically determine the differences between two analysis configurations and relate them to the correct source code versions. Users can explicitly create a revision, i.e. a snapshot of the analysis project; changes of the source code, analysis options, analysis directives and results in different revisions are automatically detected and highlighted. The analyzer provides automatic correctness checks for all specified analysis directives, e.g., to tune the precision of the analyzer or provide information about the environment. This makes software verification applicable during the implementation stage, significantly reduces the effort to adapt the analyzer configuration to new source code versions, and makes analysis results on previous software versions easily reproducible.},
	booktitle = {{CARS} 2015 - Critical Automotive applications: Robustness \& Safety},
	author = {Kästner, Daniel and Pohland, Jan},
	editor = {Roy, Matthieu},
	urldate = {2019-01-31},
	date = {2015-09},
	file = {HAL PDF Full Text:/Users/richardford/Zotero/storage/LEVP5BEU/Kästner and Pohland - 2015 - Program Analysis on Evolving Software.pdf:application/pdf}
}

@article{monniaux_parallel_2005,
	title = {The parallel implementation of the Astr{\textbackslash}'\{e\}e static analyzer},
	volume = {3780},
	url = {http://arxiv.org/abs/cs/0701191},
	doi = {10.1007/11575467_7},
	abstract = {The Astr{\textbackslash}'\{e\}e static analyzer is a specialized tool that can prove the absence of runtime errors, including arithmetic overflows, in large critical programs. Keeping analysis times reasonable for industrial use is one of the design objectives. In this paper, we discuss the parallel implementation of the analysis.},
	pages = {86--96},
	journaltitle = {{arXiv}:cs/0701191},
	author = {Monniaux, David},
	urldate = {2019-01-31},
	date = {2005},
	eprinttype = {arxiv},
	eprint = {cs/0701191},
	keywords = {Computer Science - Performance, Computer Science - Programming Languages, D.2.4},
	file = {arXiv\:cs/0701191 PDF:/Users/richardford/Zotero/storage/XJI5L7X9/Monniaux - 2005 - The parallel implementation of the Astr'\{e\}e stat.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/M3ZXKGYR/0701191.html:text/html}
}

@article{kastner_astree:_nodate,
	title = {Astree: Proving the Absence of Runtime Errors},
	url = {https://www.di.ens.fr/~rival/papers/erts10.pdf},
	abstract = {Safety-critical embedded software has to satisfy stringent quality requirements. Testing and validation consumes a large – and growing – fraction of development cost. The last years have seen the emergence of semantics-based static analysis tools in various application areas, from runtime error analysis to worst-case execution time prediction. Their appeal is that they have the potential to reduce testing eﬀort while providing 100\% coverage, thus enhancing safety. Static runtime error analysis is applicable to large industryscale projects and produces a list of deﬁnite runtime errors and of potential runtime errors which might be true errors or false alarms. In the past, often only the deﬁnite errors were ﬁxed because manually inspecting each alarm was too time-consuming due to a large number of false alarms. Therefore no proof of the absence of runtime errors could be given. In this article the parameterizable static analyzer Astr´ee is presented. By specialization and parameterization Astr´ee can be adapted to the software under analysis. This enables Astr´ee to eﬃciently compute precise results. Astr´ee has successfully been used to analyze large-scale safety-critical avionics software with zero false alarms.},
	pages = {9},
	author = {Kästner, D and Wilhelm, S and Nenova, S and Miné, A and Rival, X and Mauborgne, L and Feret, J and Cousot, P and Cousot, R},
	langid = {english},
	note = {astree/astee-proving-absence-rte.pdf},
	file = {Kästner et al. - Astree Proving the Absence of Runtime Errors.pdf:/Users/richardford/Zotero/storage/USSVMPAS/Kästner et al. - Astree Proving the Absence of Runtime Errors.pdf:application/pdf}
}

@inproceedings{mine_taking_2016,
	location = {Toulouse, France},
	title = {Taking Static Analysis to the Next Level: Proving the Absence of Run-Time Errors and Data Races with Astrée},
	url = {https://hal.archives-ouvertes.fr/hal-01271552},
	shorttitle = {Taking Static Analysis to the Next Level},
	abstract = {We present an extension of Astrée to concurrent C software. Astrée is a sound static analyzer for run-time errors previously limited to sequential C software. Our extension employs a scalable abstraction which covers all possible thread interleavings, and soundly reports all run-time errors and data races: when the analyzer does not report any alarm, the program is proven free from those classes of errors. We show how this extension is able to support a variety of operating systems (such as {POSIX} threads, {ARINC} 653, {OSEK}/{AUTOSAR}) and report on experimental results obtained on concurrent software from different domains, including large industrial software.},
	booktitle = {8th European Congress on Embedded Real Time Software and Systems ({ERTS} 2016)},
	author = {Miné, Antoine and Mauborgne, Laurent and Rival, Xavier and Feret, Jerome and Cousot, Patrick and Kästner, Daniel and Wilhelm, Stephan and Ferdinand, Christian},
	urldate = {2019-01-31},
	date = {2016-01},
	file = {HAL PDF Full Text:/Users/richardford/Zotero/storage/76NS6CAS/Miné et al. - 2016 - Taking Static Analysis to the Next Level Proving .pdf:application/pdf}
}

@article{bedford_coqatoo:_nodate,
	title = {Coqatoo: Generating Natural Language Versions of Coq Proofs - Slides},
	pages = {16},
	author = {Bedford, Andrew},
	langid = {english},
	file = {Bedford - Generating Natural Language Versions of Coq Proofs.pdf:/Users/richardford/Zotero/storage/NKL4736M/Bedford - Generating Natural Language Versions of Coq Proofs.pdf:application/pdf}
}

@article{bedford_coqatoo:_2017,
	title = {Coqatoo: Generating Natural Language Versions of Coq Proofs},
	url = {http://arxiv.org/abs/1712.03894},
	shorttitle = {Coqatoo},
	abstract = {Due to their numerous advantages, formal proofs and proof assistants, such as Coq, are becoming increasingly popular. However, one disadvantage of using proof assistants is that the resulting proofs can sometimes be hard to read and understand, particularly for less-experienced users. To address this issue, we have implemented a tool capable of generating natural language versions of Coq proofs called Coqatoo, which we present in this paper.},
	journaltitle = {{arXiv}:1712.03894 [cs]},
	author = {Bedford, Andrew},
	urldate = {2019-01-31},
	date = {2017-12-11},
	eprinttype = {arxiv},
	eprint = {1712.03894},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv\:1712.03894 PDF:/Users/richardford/Zotero/storage/HUTDVY7Z/Bedford - 2017 - Coqatoo Generating Natural Language Versions of C.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/UBK7X3KY/1712.html:text/html}
}

@thesis{sherman_making_2017,
	location = {Cambridge, {MA}},
	title = {Making Discrete Decisions Based on Continuous Values},
	url = {http://adam.chlipala.net/theses/sherman_sm.pdf},
	abstract = {Many safety-critical software systems are cyber-physical systems that compute with continuous values; confirming their safety requires guaranteeing the accuracy of their computations. It is impossible for these systems to compute (total and deterministic) discrete computations (e.g., decisions) based on connected input spaces such as R. We propose a programming language based on constructive topology, whose types are spaces and programs are executable continuous maps, that facilitates making formal guarantees of accuracy of computed results. We demonstrate that discrete decisions can be made based on continuous values by permitting nondeterminism. This thesis describes variants of the programming language allowing nondeterminism and/or partiality, and introduces two tools for creating nondeterministic programs on spaces. Overlapping pattern matching is a generalization of pattern matching in functional programming, where patterns need not represent decidable predicates and also may overlap, allowing potentially nondeterministic behavior in overlapping regions. Binary covers, which are pairs of predicates such that at least one of them holds, yield a formal logic for constructing approximate decision procedures.},
	pagetotal = {105},
	institution = {{MIT}},
	type = {Master of Science},
	author = {Sherman, Benjamin},
	date = {2017-06},
	langid = {english},
	note = {ben-sherman/sm-thesis.pdf},
	file = {Sherman - Making Discrete Decisions Based on Continuous Valu.pdf:/Users/richardford/Zotero/storage/KF9N82CU/Sherman - Making Discrete Decisions Based on Continuous Valu.pdf:application/pdf}
}

@inproceedings{boulier_next_2017,
	title = {The next 700 syntactical models of type theory},
	url = {https://hal.inria.fr/hal-01445835/document},
	doi = {10.1145/3018610.3018620},
	abstract = {A family of syntactic models for the calculus of construction with universes ({CC} ω) is described, all of them preserving conversion of the calculus definitionally, and thus giving rise directly to a program transformation of {CC} ω into itself. Those models are based on the remark that negative type constructors (e.g., dependent product, coinductive types or universes) are underspecified in type theory—which leaves some freedom on extra intensional specifications. The model construction can be seen as a compilation phase from a complex type theory into a simpler type theory. Such models can be used to derive (the negative part of) independence results with respect to {CC} ω , such as functional extensional-ity, propositional extensionality, univalence or the fact that bisimulation on a coinductive type may not coincide with equality. They can also be used to add new principles to the theory, which we illustrate by defining a version of {CC} ω with ad-hoc polymorphism that shows in particular that para-metricity is not an implicit requirement of type theory. The correctness of some of the models/program transformations have been checked in the {COQ} proof assistant and have been instrumented as a {COQ} plugin.},
	eventtitle = {Certified Programs and Proofs ({CPP} 2017)},
	pages = {182 -- 194},
	author = {Boulier, Simon and Pédrot, Pierre-Marie and Tabareau, Nicolas},
	urldate = {2019-01-31},
	date = {2017-01-16},
	langid = {english},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/63IAMKPN/Boulier et al. - 2017 - The next 700 syntactical models of type theory.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/VKLAKHTH/hal-01445835.html:text/html}
}

@book{bowman_j1:_nodate,
	title = {J1: a small Forth {CPU} Core for {FPGAs}},
	shorttitle = {J1},
	abstract = {Abstract—This paper describes a 16-bit Forth {CPU} core, intended for {FPGAs}. The instruction set closely matches the Forth programming language, simplifying cross-compilation. Because it has higher throughput than comparable {CPU} cores, it can stream uncompressed video over Ethernet using a simple software loop.The entire system (source Verilog,cross compiler, and {TCP}/{IP} networking code) is published under the {BSD} license. The core is less than 200 lines of Verilog, and operates reliably at 80 {MHz} in a Xilinx Spartan R○-3E {FPGA}, delivering approximately 100 {ANS} Forth {MIPS}. I.},
	author = {Bowman, James},
	file = {Citeseer - Full Text PDF:/Users/richardford/Zotero/storage/T8LQY54B/Bowman - J1 a small Forth CPU Core for FPGAs.pdf:application/pdf;Citeseer - Snapshot:/Users/richardford/Zotero/storage/W6VSU9EW/summary.html:text/html}
}

@inproceedings{gu_deep_2015,
	location = {New York, {NY}, {USA}},
	title = {Deep Specifications and Certified Abstraction Layers},
	isbn = {978-1-4503-3300-9},
	url = {http://doi.acm.org/10.1145/2676726.2676975},
	doi = {10.1145/2676726.2676975},
	series = {{POPL} '15},
	abstract = {Modern computer systems consist of a multitude of abstraction layers (e.g., {OS} kernels, hypervisors, device drivers, network protocols), each of which defines an interface that hides the implementation details of a particular set of functionality. Client programs built on top of each layer can be understood solely based on the interface, independent of the layer implementation. Despite their obvious importance, abstraction layers have mostly been treated as a system concept; they have almost never been formally specified or verified. This makes it difficult to establish strong correctness properties, and to scale program verification across multiple layers. In this paper, we present a novel language-based account of abstraction layers and show that they correspond to a strong form of abstraction over a particularly rich class of specifications which we call deep specifications. Just as data abstraction in typed functional languages leads to the important representation independence property, abstraction over deep specification is characterized by an important implementation independence property: any two implementations of the same deep specification must have contextually equivalent behaviors. We present a new layer calculus showing how to formally specify, program, verify, and compose abstraction layers. We show how to instantiate the layer calculus in realistic programming languages such as C and assembly, and how to adapt the {CompCert} verified compiler to compile certified C layers such that they can be linked with assembly layers. Using these new languages and tools, we have successfully developed multiple certified {OS} kernels in the Coq proof assistant, the most realistic of which consists of 37 abstraction layers, took less than one person year to develop, and can boot a version of Linux as a guest.},
	pages = {595--608},
	booktitle = {Proceedings of the 42Nd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Gu, Ronghui and Koenig, Jérémie and Ramananandro, Tahina and Shao, Zhong and Wu, Xiongnan (Newman) and Weng, Shu-Chun and Zhang, Haozhong and Guo, Yu},
	urldate = {2019-01-31},
	date = {2015},
	keywords = {abstraction layer, certified compilers, certified os kernels, deep specification, modularity, program verification},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/7DPCTJMC/Gu et al. - 2015 - Deep Specifications and Certified Abstraction Laye.pdf:application/pdf}
}

@article{murawski_invitation_2016,
	title = {An Invitation to Game Semantics},
	volume = {3},
	issn = {2372-3491},
	url = {http://doi.acm.org/10.1145/2948896.2948902},
	doi = {10.1145/2948896.2948902},
	abstract = {Game semantics is a flexible semantic theory that has led in recent years to an unprecedented number of full abstraction results for various programming paradigms. We present a gentle introduction to the subject, focussing on high-level ideas and examples with a view to providing a bridge to more technical literature.},
	pages = {56--67},
	number = {2},
	journaltitle = {{ACM} {SIGLOG} News},
	author = {Murawski, Andrzej S. and Tzevelekos, Nikos},
	urldate = {2019-01-31},
	date = {2016-05},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/ITYEIVIF/Murawski and Tzevelekos - 2016 - An Invitation to Game Semantics.pdf:application/pdf}
}

@article{herlihy_linearizability:_1990,
	title = {Linearizability: A Correctness Condition for Concurrent Objects},
	volume = {12},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/78969.78972},
	doi = {10.1145/78969.78972},
	shorttitle = {Linearizability},
	abstract = {A concurrent object is a data object shared by concurrent processes. Linearizability is a correctness condition for concurrent objects that exploits the semantics of abstract data types. It permits a high degree of concurrency, yet it permits programmers to specify and reason about concurrent objects using known techniques from the sequential domain. Linearizability provides the illusion that each operation applied by concurrent processes takes effect instantaneously at some point between its invocation and its response, implying that the meaning of a concurrent object's operations can be given by pre- and post-conditions. This paper defines linearizability, compares it to other correctness conditions, presents and demonstrates a method for proving the correctness of implementations, and shows how to reason about concurrent objects, given they are linearizable.},
	pages = {463--492},
	number = {3},
	journaltitle = {{ACM} Trans. Program. Lang. Syst.},
	author = {Herlihy, Maurice P. and Wing, Jeannette M.},
	urldate = {2019-01-31},
	date = {1990-07},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/XCLSDXNI/Herlihy and Wing - 1990 - Linearizability A Correctness Condition for Concu.pdf:application/pdf}
}

@inproceedings{gu_certikos:_2016,
	location = {Berkeley, {CA}, {USA}},
	title = {{CertiKOS}: An Extensible Architecture for Building Certified Concurrent {OS} Kernels},
	isbn = {978-1-931971-33-1},
	url = {http://dl.acm.org/citation.cfm?id=3026877.3026928},
	series = {{OSDI}'16},
	shorttitle = {{CertiKOS}},
	abstract = {Complete formal verification of a non-trivial concurrent {OS} kernel is widely considered a grand challenge. We present a novel compositional approach for building certified concurrent {OS} kernels. Concurrency allows interleaved execution of kernel/user modules across different layers of abstraction. Each such layer can have a different set of observable events. We insist on formally specifying these layers and their observable events, and then verifying each kernel module at its proper abstraction level. To support certified linking with other {CPUs} or threads, we prove a strong contextual refinement property for every kernel function, which states that the implementation of each such function will behave like its specification under any kernel/user context with any valid interleaving. We have successfully developed a practical concurrent {OS} kernel and verified its (contextual) functional correctness in Coq. Our certified kernel is written in 6500 lines of C and x86 assembly and runs on stock x86 multicore machines. To our knowledge, this is the first proof of functional correctness of a complete, general-purpose concurrent {OS} kernel with fine-grained locking.},
	pages = {653--669},
	booktitle = {Proceedings of the 12th {USENIX} Conference on Operating Systems Design and Implementation},
	publisher = {{USENIX} Association},
	author = {Gu, Ronghui and Shao, Zhong and Chen, Hao and Wu, Xiongnan and Kim, Jieung and Sjöberg, Vilhelm and Costanzo, David},
	urldate = {2019-01-31},
	date = {2016},
	file = {Gu et al. - 2016 - CertiKOS An Extensible Architecture for Building .pdf:/Users/richardford/Zotero/storage/A928RE7F/Gu et al. - 2016 - CertiKOS An Extensible Architecture for Building .pdf:application/pdf}
}

@article{costanzo_end--end_nodate,
	title = {End-to-End Veriﬁcation of Information-Flow Security for C and Assembly Programs - Tech Report},
	url = {http://flint.cs.yale.edu/certikos/publications/security-tr.pdf},
	abstract = {Protecting the conﬁdentiality of information manipulated by a computing system is one of the most important challenges facing today’s cybersecurity community. A promising step toward conquering this challenge is to formally verify that the end-to-end behavior of the computing system really satisﬁes various information-ﬂow policies. Unfortunately, because today’s system software still consists of both C and assembly programs, the end-to-end veriﬁcation necessarily requires that we not only prove the security properties of individual components, but also carefully preserve these properties through compilation and cross-language linking.},
	pages = {21},
	author = {Costanzo, David and Shao, Zhong and Gu, Ronghui},
	langid = {english},
	note = {certikos/pldi16-certikos-security-tr.pdf},
	file = {Costanzo et al. - End-to-End Veriﬁcation of Information-Flow Securit.pdf:/Users/richardford/Zotero/storage/L2E38WJM/Costanzo et al. - End-to-End Veriﬁcation of Information-Flow Securit.pdf:application/pdf}
}

@inproceedings{costanzo_end--end_2016,
	location = {New York, {NY}, {USA}},
	title = {End-to-end Verification of Information-flow Security for C and Assembly Programs},
	isbn = {978-1-4503-4261-2},
	url = {http://doi.acm.org/10.1145/2908080.2908100},
	doi = {10.1145/2908080.2908100},
	series = {{PLDI} '16},
	abstract = {Protecting the confidentiality of information manipulated by a computing system is one of the most important challenges facing today's cybersecurity community. A promising step toward conquering this challenge is to formally verify that the end-to-end behavior of the computing system really satisfies various information-flow policies. Unfortunately, because today's system software still consists of both C and assembly programs, the end-to-end verification necessarily requires that we not only prove the security properties of individual components, but also carefully preserve these properties through compilation and cross-language linking. In this paper, we present a novel methodology for formally verifying end-to-end security of a software system that consists of both C and assembly programs. We introduce a general definition of observation function that unifies the concepts of policy specification, state indistinguishability, and whole-execution behaviors. We show how to use different observation functions for different levels of abstraction, and how to link different security proofs across abstraction levels using a special kind of simulation that is guaranteed to preserve state indistinguishability. To demonstrate the effectiveness of our new methodology, we have successfully constructed an end-to-end security proof, fully formalized in the Coq proof assistant, of a nontrivial operating system kernel (running on an extended {CompCert} x86 assembly machine model). Some parts of the kernel are written in C and some are written in assembly; we verify all of the code, regardless of language.},
	pages = {648--664},
	booktitle = {Proceedings of the 37th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Costanzo, David and Shao, Zhong and Gu, Ronghui},
	urldate = {2019-01-31},
	date = {2016},
	keywords = {Certified {OS} Kernels, Information Flow Control, Program Verification, Security Policy Specification, Security-Preserving Simulation},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/HCL3RZNR/Costanzo et al. - 2016 - End-to-end Verification of Information-flow Securi.pdf:application/pdf}
}

@inproceedings{gu_certified_2018,
	location = {New York, {NY}, {USA}},
	title = {Certified Concurrent Abstraction Layers},
	isbn = {978-1-4503-5698-5},
	url = {http://doi.acm.org/10.1145/3192366.3192381},
	doi = {10.1145/3192366.3192381},
	series = {{PLDI} 2018},
	abstract = {Concurrent abstraction layers are ubiquitous in modern computer systems because of the pervasiveness of multithreaded programming and multicore hardware. Abstraction layers are used to hide the implementation details (e.g., fine-grained synchronization) and reduce the complex dependencies among components at different levels of abstraction. Despite their obvious importance, concurrent abstraction layers have not been treated formally. This severely limits the applicability of layer-based techniques and makes it difficult to scale verification across multiple concurrent layers.   In this paper, we present {CCAL}---a fully mechanized programming toolkit developed under the {CertiKOS} project---for specifying, composing, compiling, and linking certified concurrent abstraction layers. {CCAL} consists of three technical novelties: a new game-theoretical, strategy-based compositional semantic model for concurrency (and its associated program verifiers), a set of formal linking theorems for composing multithreaded and multicore concurrent layers, and a new {CompCertX} compiler that supports certified thread-safe compilation and linking. The {CCAL} toolkit is implemented in Coq and supports layered concurrent programming in both C and assembly. It has been successfully applied to build a fully certified concurrent {OS} kernel with fine-grained locking.},
	pages = {646--661},
	booktitle = {Proceedings of the 39th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Gu, Ronghui and Shao, Zhong and Kim, Jieung and Wu, Xiongnan (Newman) and Koenig, Jérémie and Sjöberg, Vilhelm and Chen, Hao and Costanzo, David and Ramananandro, Tahina},
	urldate = {2019-01-31},
	date = {2018},
	keywords = {abstraction layer, certified compilers, certified {OS} kernels, concurrency, modularity, Verification},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/84F5S82K/Gu et al. - 2018 - Certified Concurrent Abstraction Layers.pdf:application/pdf}
}

@inproceedings{chargueraud_program_2010,
	location = {New York, {NY}, {USA}},
	title = {Program Verification Through Characteristic Formulae},
	isbn = {978-1-60558-794-3},
	url = {http://doi.acm.org/10.1145/1863543.1863590},
	doi = {10.1145/1863543.1863590},
	series = {{ICFP} '10},
	abstract = {This paper describes {CFML}, the first program verification tool based on characteristic formulae. Given the source code of a pure Caml program, this tool generates a logical formula that implies any valid post-condition for that program. One can then prove that the program satisfies a given specification by reasoning interactively about the characteristic formula using a proof assistant such as Coq. Our characteristic formulae improve over Honda et al's total characteristic assertion pairs in that they are expressible in standard higher-order logic, allowing to exploit them in practice to verify programs using existing proof assistants. Our technique has been applied to formally verify more than half of the content of Okasaki's Purely Functional Data Structures reference book},
	pages = {321--332},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {Charguéraud, Arthur},
	urldate = {2019-01-31},
	date = {2010},
	keywords = {characteristic formula, functional program, total correctness},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/LP9W7JLK/Charguéraud - 2010 - Program Verification Through Characteristic Formul.pdf:application/pdf}
}

@inproceedings{chargueraud_characteristic_2011,
	location = {New York, {NY}, {USA}},
	title = {Characteristic Formulae for the Verification of Imperative Programs},
	isbn = {978-1-4503-0865-6},
	url = {http://doi.acm.org/10.1145/2034773.2034828},
	doi = {10.1145/2034773.2034828},
	series = {{ICFP} '11},
	abstract = {In previous work, we introduced an approach to program verification based on characteristic formulae. The approach consists of generating a higher-order logic formula from the source code of a program. This characteristic formula is constructed in such a way that it gives a sound and complete description of the semantics of that program. The formula can thus be exploited in an interactive proof assistant to formally verify that the program satisfies a particular specification. This previous work was, however, only concerned with purely-functional programs. In the present paper, we describe the generalization of characteristic formulae to an imperative programming language. In this setting, characteristic formulae involve specifications expressed in the style of Separation Logic. They also integrate the frame rule, which enables local reasoning. We have implemented a tool based on characteristic formulae. This tool, called {CFML}, supports the verification of imperative Caml programs using the Coq proof assistant. Using {CFML}, we have formally verified nontrivial imperative algorithms, as well as {CPS} functions, higher-order iterators, and programs involving higher-order stores.},
	pages = {418--430},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {Charguéraud, Arthur},
	urldate = {2019-01-31},
	date = {2011},
	keywords = {characteristic formula, interactive verification, total correctness},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/2GURSGU7/Charguéraud - 2011 - Characteristic Formulae for the Verification of Im.pdf:application/pdf}
}

@thesis{chargueraud_characteristic_2010,
	location = {Paris, France},
	title = {Characteristic Formulae for Mechanized Program Verification},
	abstract = {This dissertation describes a new approach to program veri cation,
based on characteristic formulae. The characteristic formula of a program
is a higher-order logic formula that describes the behavior of that
program, in the sense that it is sound and complete with respect to
the semantics. This formula can be exploited in an interactive theorem
prover to establish that the program satis es a speci cation expressed
in the style of Separation Logic, with respect to total correctness.
The characteristic formula of a program is automatically generated
from its source code alone. In particular, there is no need to annotate the
source code with speci cations or loop invariants, as such information
can be given in interactive proof scripts. One key feature of characteristic
formulae is that they are of linear size and that they can be prettyprinted
in a way that closely resemble the source code they describe, even
though they do not refer to the syntax of the programming language.
Characteristic formulae serve as a basis for a tool, called {CFML}, that
supports the veri cation of Caml programs using the Coq proof assistant.
{CFML} has been employed to verify about half of the content of
Okasaki's book on purely functional data structures, and to verify several
imperative data structures such as mutable lists, sparse arrays and
union- nd. {CFML} also supports reasoning on higher-order imperative
functions, such as functions in {CPS} form and higher-order iterators},
	pagetotal = {185},
	institution = {{UNIVERSITÉ} {PARIS}.{DIDEROT}},
	type = {phdthesis},
	author = {Charguéraud, Arthur},
	date = {2010-12-16},
	langid = {english},
	note = {chargueraud/chargueraud\_thesis\_final.pdf},
	file = {Charguéraud - Characteristic Formulae for Mechanized Program Ver.pdf:/Users/richardford/Zotero/storage/PZZIGKPW/Charguéraud - Characteristic Formulae for Mechanized Program Ver.pdf:application/pdf}
}

@article{chlipala_introduction_nodate,
	title = {An Introduction to Programming and Proving with Dependent Types in Coq},
	volume = {3},
	abstract = {Computer proof assistants vary along many dimensions. Among the mature implementations, the Coq system is distinguished by two key features. First, we have support for programming with
dependent types in the tradition of type theory, based on dependent function types and inductive type families. Second, we have a domain-specific language for coding correct-by-construction proof automation. Though the Coq user community has grown quite large, neither of the aspects
I highlight is widely used. In this tutorial, I aim to provide a pragmatic introduction to both, showing how they can bring significant improvements in productivity.},
	pages = {93},
	number = {2},
	journaltitle = {Journal of Formalized Reasoning},
	author = {Chlipala, Adam},
	langid = {english},
	note = {chlipala/1978-4445-1-{PB}.pdf},
	file = {Chlipala - An Introduction to Programming and Proving with De.pdf:/Users/richardford/Zotero/storage/KS4N39J7/Chlipala - An Introduction to Programming and Proving with De.pdf:application/pdf}
}

@book{chlipala_certified_2013,
	location = {Cambridge, {MA}},
	title = {Certified programming with dependent types: a pragmatic introduction to the Coq proof assistant},
	isbn = {978-0-262-02665-9},
	url = {http://adam.chlipala.net/cpdt/},
	shorttitle = {Certified programming with dependent types},
	pagetotal = {424},
	publisher = {The {MIT} Press},
	author = {Chlipala, Adam},
	date = {2013},
	keywords = {Automatic theorem proving, Computer programming, Computer programs, Coq (Electronic resource)}
}

@article{chlipala_certied_nodate,
	title = {Certiﬁed Programming with Dependent Types},
	pages = {369},
	author = {Chlipala, Adam},
	langid = {english},
	file = {Chlipala - Certiﬁed Programming with Dependent Types.pdf:/Users/richardford/Zotero/storage/DYCT99N4/Chlipala - Certiﬁed Programming with Dependent Types.pdf:application/pdf}
}

@software{chlipala_formal_2019,
	title = {Formal Reasoning About Programs - Github},
	url = {https://github.com/achlipala/frap},
	author = {Chlipala, Adam},
	urldate = {2019-01-31},
	date = {2019-01-31},
	note = {original-date: 2016-02-02T18:43:56Z},
	file = {frap_book.pdf:/Users/richardford/Zotero/storage/W5SBG74C/frap_book.pdf:application/pdf}
}

@article{pit-claudel_extensible_nodate,
	title = {Extensible Extraction of Efﬁcient Imperative Programs with Foreign Functions, Manually Managed Memory, and Proofs},
	url = {http://pit-claudel.fr/clement/papers/fiat-to-facade.pdf},
	abstract = {We present an original approach to sound program extraction in a proof assistant, using syntax-driven automation to derive correct-by-construction imperative programs from nondeterministic functional source code. Our approach does not require committing to a single inﬂexible compilation strategy and instead makes it straightforward to create domainspeciﬁc code translators. In addition to a small set of core definitions, our framework is a large, user-extensible collection of compilation rules each phrased to handle speciﬁc language constructs, code patterns, or data manipulations. By mixing and matching these pieces of logic, users can easily tailor extraction to their own domains and programs, getting maximum performance and ensuring correctness of the resulting assembly code. Using this approach, we complete the ﬁrst proof-generating pipeline that goes automatically from high-level speciﬁcations to assembly code. In our main case study, the original speciﬁcations are phrased to resemble {SQL}-style queries, while the ﬁnal assembly code does manual memory management, calls out to foreign data structures and functions, and is suitable to deploy on resource-constrained platforms. The pipeline runs entirely within the Coq proof assistant, leading to ﬁnal, linked assembly code inside Coq with overall full-functional-correctness proofs in separation logic.},
	pages = {14},
	author = {Pit-Claudel, Clément and Wang, Peng and Delaware, Benjamin and Gross, Jason and Chlipala, Adam},
	langid = {english},
	note = {clement/fiat-to-facade.pdg},
	file = {Pit-Claudel et al. - Extensible Extraction of Efﬁcient Imperative Progr.pdf:/Users/richardford/Zotero/storage/PBAPDPGG/Pit-Claudel et al. - Extensible Extraction of Efﬁcient Imperative Progr.pdf:application/pdf}
}

@incollection{feng_correct-by-construction_2018,
	location = {Cham},
	title = {Correct-by-Construction Implementation of Runtime Monitors Using Stepwise Refinement},
	volume = {10998},
	isbn = {978-3-319-99932-6 978-3-319-99933-3},
	url = {http://link.springer.com/10.1007/978-3-319-99933-3_3},
	pages = {31--49},
	booktitle = {Dependable Software Engineering. Theories, Tools, and Applications},
	publisher = {Springer International Publishing},
	author = {Zhang, Teng and Wiegley, John and Giannakopoulos, Theophilos and Eakman, Gregory and Pit-Claudel, Clément and Lee, Insup and Sokolsky, Oleg},
	editor = {Feng, Xinyu and Müller-Olm, Markus and Yang, Zijiang},
	urldate = {2019-01-31},
	date = {2018},
	doi = {10.1007/978-3-319-99933-3_3},
	file = {Zhang et al. - 2018 - Correct-by-Construction Implementation of Runtime .pdf:/Users/richardford/Zotero/storage/TFNK7T59/Zhang et al. - 2018 - Correct-by-Construction Implementation of Runtime .pdf:application/pdf}
}

@book{martin_mastering_2013,
	location = {Clifton Park, {NY}},
	edition = {6. ed},
	title = {Mastering {CMake}: a cross-platform build system ; covers installing and running {CMake} ; details converting existing build processes to {CMake} ; create powerful cross-platform build scripts},
	isbn = {978-1-930934-26-9},
	shorttitle = {Mastering {CMake}},
	pagetotal = {640},
	publisher = {Kitware},
	author = {Martin, Ken and Hoffman, Bill and Cedilnik, Andy},
	date = {2013},
	note = {{OCLC}: 869872480},
	file = {mastering-cmake.pdf:/Users/richardford/Zotero/storage/ZJ8TN7IN/mastering-cmake.pdf:application/pdf;Table of Contents PDF:/Users/richardford/Zotero/storage/J9EPKEK2/Martin et al. - 2013 - Mastering CMake a cross-platform build system \; c.pdf:application/pdf}
}

@online{absint_compcert_nodate,
	title = {{CompCert} - Publications},
	url = {http://compcert.inria.fr/publi.html},
	author = {Absint},
	urldate = {2019-01-31},
	file = {CompCert - Publications:/Users/richardford/Zotero/storage/98Y2B9GJ/publi.html:text/html}
}

@incollection{chaudhuri_trigger_2016,
	location = {Cham},
	title = {Trigger Selection Strategies to Stabilize Program Verifiers},
	volume = {9779},
	isbn = {978-3-319-41527-7 978-3-319-41528-4},
	url = {http://link.springer.com/10.1007/978-3-319-41528-4_20},
	pages = {361--381},
	booktitle = {Computer Aided Verification},
	publisher = {Springer International Publishing},
	author = {Leino, K. R. M. and Pit-Claudel, Clément},
	editor = {Chaudhuri, Swarat and Farzan, Azadeh},
	urldate = {2019-01-31},
	date = {2016},
	doi = {10.1007/978-3-319-41528-4_20},
	file = {Leino and Pit-Claudel - 2016 - Trigger Selection Strategies to Stabilize Program .pdf:/Users/richardford/Zotero/storage/455BEULC/Leino and Pit-Claudel - 2016 - Trigger Selection Strategies to Stabilize Program .pdf:application/pdf}
}

@online{pit-claudel_clement_nodate,
	title = {Clément Pit-Claudel},
	url = {http://pit-claudel.fr/clement/},
	author = {Pit-Claudel, Clément},
	urldate = {2019-01-31},
	file = {Clément Pit-Claudel:/Users/richardford/Zotero/storage/DKTZXDT7/clement.html:text/html}
}

@book{bertot_interactive_2004,
	location = {Berlin ; New York},
	title = {Interactive theorem proving and program development: Coq'Art: the calculus of inductive constructions},
	isbn = {978-3-540-20854-9},
	url = {http://www.labri.fr/perso/casteran/CoqArt/index.html},
	series = {Texts in theoretical computer science},
	shorttitle = {Interactive theorem proving and program development},
	pagetotal = {469},
	publisher = {Springer},
	author = {Bertot, Yves and Castéran, P.},
	date = {2004},
	note = {{OCLC}: ocm55514299},
	keywords = {Automatic theorem proving, Computer programming}
}

@online{casteran_pierre_nodate,
	title = {Pierre Castéran's Home page},
	url = {http://www.labri.fr/perso/casteran/index.html},
	author = {Castéran, Pierre},
	urldate = {2019-01-31},
	file = {Pierre Castéran's Home page:/Users/richardford/Zotero/storage/DYKI8IUV/index.html:text/html}
}

@online{bertot_yves_nodate,
	title = {Yves Bertot},
	url = {http://www-sop.inria.fr/members/Yves.Bertot/index.html},
	author = {Bertot, Yves},
	urldate = {2019-01-31},
	file = {Yves Bertot:/Users/richardford/Zotero/storage/XCTTX2DV/index.html:text/html}
}

@online{inria_inria_nodate,
	title = {Inria - Inventors for the digital world},
	url = {https://www.inria.fr/en},
	abstract = {Inria is a public research body dedicated to digital science and technology.},
	titleaddon = {Inria},
	author = {Inria},
	urldate = {2019-01-31},
	langid = {english},
	file = {Snapshot:/Users/richardford/Zotero/storage/7PRHEUQG/en.html:text/html}
}

@inproceedings{crary_modules_2017,
	location = {New York, {NY}, {USA}},
	title = {Modules, Abstraction, and Parametric Polymorphism},
	isbn = {978-1-4503-4660-3},
	url = {http://doi.acm.org/10.1145/3009837.3009892},
	doi = {10.1145/3009837.3009892},
	series = {{POPL} 2017},
	abstract = {Reynolds's Abstraction theorem forms the mathematical foundation for data abstraction. His setting was the polymorphic lambda calculus. Today, many modern languages, such as the {ML} family, employ rich module systems designed to give more expressive support for data abstraction than the polymorphic lambda calculus, but analogues of the Abstraction theorem for such module systems have lagged far behind.   We give an account of the Abstraction theorem for a modern module calculus supporting generative and applicative functors, higher-order functors, sealing, and translucent signatures. The main issues to be overcome are: (1) the fact that modules combine both types and terms, so they must be treated as both simultaneously, (2) the effect discipline that models the distinction between transparent and opaque modules, and (3) a very rich language of type constructors supporting singleton kinds. We define logical equivalence for modules and show that it coincides with contextual equivalence. This substantiates the folk theorem that modules are good for data abstraction. All our proofs are formalized in Coq.},
	pages = {100--113},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Crary, Karl},
	urldate = {2019-01-31},
	date = {2017},
	note = {crary/crary-mapp.pdf},
	keywords = {Abstraction, logical relations, modules, parametricity},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/NL7K5PQH/Crary - 2017 - Modules, Abstraction, and Parametric Polymorphism.pdf:application/pdf}
}

@inbook{platzer_differential_2018,
	location = {Cham},
	title = {Differential Equations \& Differential Invariants},
	isbn = {978-3-319-63587-3 978-3-319-63588-0},
	url = {http://link.springer.com/10.1007/978-3-319-63588-0_10},
	pages = {287--322},
	booktitle = {Logical Foundations of Cyber-Physical Systems},
	publisher = {Springer International Publishing},
	author = {Platzer, André},
	bookauthor = {Platzer, André},
	urldate = {2019-01-31},
	date = {2018},
	langid = {english},
	doi = {10.1007/978-3-319-63588-0_10},
	file = {Platzer - 2018 - Differential Equations & Differential Invariants.pdf:/Users/richardford/Zotero/storage/PS8YT9GP/Platzer - 2018 - Differential Equations & Differential Invariants.pdf:application/pdf}
}

@article{platzer_differential_2015,
	title = {Differential Game Logic},
	volume = {17},
	issn = {1529-3785},
	url = {http://doi.acm.org/10.1145/2817824},
	doi = {10.1145/2817824},
	abstract = {Differential game logic ({dGL}) is a logic for specifying and verifying properties of hybrid games, i.e., games that combine discrete, continuous, and adversarial dynamics. Unlike hybrid systems, hybrid games allow choices in the system dynamics to be resolved adversarially by different players with different objectives. The logic {dGL} can be used to study the existence of winning strategies for such hybrid games, i.e., ways of resolving the player’s choices in some way so that he wins by achieving his objective for all choices of the opponent. Hybrid games are determined, i.e., from each state, one player has a winning strategy, yet computing their winning regions may take transfinitely many steps. The logic {dGL}, nevertheless, has a sound and complete axiomatization relative to any expressive logic. Separating axioms are identified that distinguish hybrid games from hybrid systems. Finally, {dGL} is proved to be strictly more expressive than the corresponding logic of hybrid systems by characterizing the expressiveness of both.},
	pages = {1:1--1:51},
	number = {1},
	journaltitle = {{ACM} Trans. Comput. Logic},
	author = {Platzer, André},
	urldate = {2019-01-31},
	date = {2015-11},
	keywords = {axiomatization, expressiveness, Game logic, hybrid games},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/35WLKIMB/Platzer - 2015 - Differential Game Logic.pdf:application/pdf}
}

@article{platzer_differential_2008,
	title = {Differential Dynamic Logic for Hybrid Systems},
	volume = {41},
	issn = {0168-7433, 1573-0670},
	url = {http://link.springer.com/10.1007/s10817-008-9103-8},
	doi = {10.1007/s10817-008-9103-8},
	pages = {143--189},
	number = {2},
	journaltitle = {Journal of Automated Reasoning},
	author = {Platzer, André},
	urldate = {2019-01-31},
	date = {2008-08},
	langid = {english},
	file = {Submitted Version:/Users/richardford/Zotero/storage/RNX9KZZM/Platzer - 2008 - Differential Dynamic Logic for Hybrid Systems.pdf:application/pdf}
}

@incollection{hutchison_verifying_2007,
	location = {Berlin, Heidelberg},
	title = {Verifying Object-Oriented Programs with {KeY}: A Tutorial},
	volume = {4709},
	isbn = {978-3-540-74791-8 978-3-540-74792-5},
	url = {http://link.springer.com/10.1007/978-3-540-74792-5_4},
	shorttitle = {Verifying Object-Oriented Programs with {KeY}},
	abstract = {This paper is a tutorial on performing formal speciﬁcation and semi-automatic veriﬁcation of Java programs with the formal software development tool {KeY}. This tutorial aims to ﬁll the gap between elementary introductions using toy examples and state-of-art case studies by going through a self-contained, yet non-trivial, example. It is hoped that this contributes to explain the problems encountered in veriﬁcation of imperative, object-oriented programs to a readership outside the limited community of active researchers.},
	pages = {70--101},
	booktitle = {Formal Methods for Components and Objects},
	publisher = {Springer Berlin Heidelberg},
	author = {Ahrendt, Wolfgang and Beckert, Bernhard and Hähnle, Reiner and Rümmer, Philipp and Schmitt, Peter H.},
	editor = {de Boer, Frank S. and Bonsangue, Marcello M. and Graf, Susanne and de Roever, Willem-Paul},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2019-01-31},
	date = {2007},
	langid = {english},
	doi = {10.1007/978-3-540-74792-5_4},
	file = {Ahrendt et al. - 2007 - Verifying Object-Oriented Programs with KeY A Tut.pdf:/Users/richardford/Zotero/storage/DYP7E6HN/Ahrendt et al. - 2007 - Verifying Object-Oriented Programs with KeY A Tut.pdf:application/pdf}
}

@book{platzer_logical_2018,
	title = {Logical Foundations of Cyber-Physical Systems},
	isbn = {978-3-319-63587-3},
	url = {https://www.springer.com/gp/book/9783319635873},
	abstract = {Cyber-physical systems ({CPSs}) combine cyber capabilities, such as computation or communication, with physical capabilities, such as motion or other physical processes. Cars, aircraft, and robots are prime examples, because they move physically in space in a way that is determined by discrete computerized control algorithms. Designing these algorithms is challenging due to their tight coupling with physical behavior, while it is vital that these algorithms be correct because we rely on them for safety-critical tasks. This textbook teaches undergraduate students the core principles behind {CPSs}. It shows them how to develop models and controls; identify safety specifications and critical properties; reason rigorously about {CPS} models; leverage multi-dynamical systems compositionality to tame {CPS} complexity; identify required control constraints; verify {CPS} models of appropriate scale in logic; and develop an intuition for operational effects. The book is supported with homework exercises, lecture videos, and slides.},
	publisher = {Springer International Publishing},
	author = {Platzer, Andre},
	urldate = {2019-01-31},
	date = {2018},
	langid = {english},
	file = {Snapshot:/Users/richardford/Zotero/storage/TA7J9P9Y/9783319635873.html:text/html}
}

@online{platzer_keymaera_nodate,
	title = {{KeYmaera} X: Documentation},
	url = {http://www.ls.cs.cmu.edu/KeYmaeraX/documentation.html},
	author = {Platzer, André},
	urldate = {2019-01-31},
	file = {KeYmaera X\: Documentation:/Users/richardford/Zotero/storage/YGNHU67P/documentation.html:text/html}
}

@incollection{felty_keymaera_2015,
	location = {Cham},
	title = {{KeYmaera} X: An Axiomatic Tactical Theorem Prover for Hybrid Systems},
	volume = {9195},
	isbn = {978-3-319-21400-9 978-3-319-21401-6},
	url = {http://link.springer.com/10.1007/978-3-319-21401-6_36},
	shorttitle = {{KeYmaera} X},
	abstract = {{KeYmaera} X is a theorem prover for differential dynamic logic ({dL}), a logic for specifying and verifying properties of hybrid systems. Reasoning about complicated hybrid systems models requires support for sophisticated proof techniques, efﬁcient computation, and a user interface that crystallizes salient properties of the system. {KeYmaera} X allows users to specify custom proof search techniques as tactics, execute these tactics in parallel, and interface with partial proofs via an extensible user interface.},
	pages = {527--538},
	booktitle = {Automated Deduction - {CADE}-25},
	publisher = {Springer International Publishing},
	author = {Fulton, Nathan and Mitsch, Stefan and Quesel, Jan-David and Völp, Marcus and Platzer, André},
	editor = {Felty, Amy P. and Middeldorp, Aart},
	urldate = {2019-01-31},
	date = {2015},
	langid = {english},
	doi = {10.1007/978-3-319-21401-6_36},
	file = {Fulton et al. - 2015 - KeYmaera X An Axiomatic Tactical Theorem Prover f.pdf:/Users/richardford/Zotero/storage/WHPK2YJR/Fulton et al. - 2015 - KeYmaera X An Axiomatic Tactical Theorem Prover f.pdf:application/pdf}
}

@book{platzer_logical_2018-1,
	location = {Cham},
	title = {Logical Foundations of Cyber-Physical Systems - Slides},
	isbn = {978-3-319-63587-3 978-3-319-63588-0},
	url = {http://link.springer.com/10.1007/978-3-319-63588-0},
	publisher = {Springer International Publishing},
	author = {Platzer, André},
	urldate = {2019-01-31},
	date = {2018},
	langid = {english},
	doi = {10.1007/978-3-319-63588-0},
	file = {Platzer - 2018 - Logical Foundations of Cyber-Physical Systems.pdf:/Users/richardford/Zotero/storage/XG3XYH4A/Platzer - 2018 - Logical Foundations of Cyber-Physical Systems.pdf:application/pdf}
}

@article{platzer_complete_2017,
	title = {A Complete Uniform Substitution Calculus for Differential Dynamic Logic},
	volume = {59},
	issn = {0168-7433, 1573-0670},
	url = {http://arxiv.org/abs/1601.06183},
	doi = {10.1007/s10817-016-9385-1},
	abstract = {This article introduces a relatively complete proof calculus for differential dynamic logic ({dL}) that is entirely based on uniform substitution, a proof rule that substitutes a formula for a predicate symbol everywhere. Uniform substitutions make it possible to use axioms instead of axiom schemata, thereby substantially simplifying implementations. Instead of subtle schema variables and soundness-critical side conditions on the occurrence patterns of logical variables to restrict infinitely many axiom schema instances to sound ones, the resulting calculus adopts only a finite number of ordinary {dL} formulas as axioms, which uniform substitutions instantiate soundly. The static semantics of differential dynamic logic and the soundness-critical restrictions it imposes on proof steps is captured exclusively in uniform substitutions and variable renamings as opposed to being spread in delicate ways across the prover implementation. In addition to sound uniform substitutions, this article introduces differential forms for differential dynamic logic that make it possible to internalize differential invariants, differential substitutions, and derivatives as first-class axioms to reason about differential equations axiomatically. The resulting axiomatization of differential dynamic logic is proved to be sound and relatively complete.},
	pages = {219--265},
	number = {2},
	journaltitle = {Journal of Automated Reasoning},
	author = {Platzer, André},
	urldate = {2019-01-31},
	date = {2017-08},
	eprinttype = {arxiv},
	eprint = {1601.06183},
	keywords = {03F03, 03B70, 34A38, Computer Science - Logic in Computer Science, Computer Science - Programming Languages, F.3.1, F.3.2, F.4.1, I.2.3, Mathematics - Logic},
	file = {arXiv\:1601.06183 PDF:/Users/richardford/Zotero/storage/8URQWUMX/Platzer - 2017 - A Complete Uniform Substitution Calculus for Diffe.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/R9XNPMRW/1601.html:text/html}
}

@collection{beckert_verification_2006,
	location = {Berlin, Heidelberg},
	title = {Verification of Object-Oriented Software. The {KeY} Approach},
	volume = {4334},
	isbn = {978-3-540-68977-5},
	url = {http://link.springer.com/10.1007/978-3-540-69061-0},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer Berlin Heidelberg},
	editor = {Beckert, Bernhard and Hähnle, Reiner and Schmitt, Peter H.},
	urldate = {2019-01-31},
	date = {2006},
	langid = {english},
	doi = {10.1007/978-3-540-69061-0},
	file = {Beckert et al. - 2006 - Verification of Object-Oriented Software. The KeY .pdf:/Users/richardford/Zotero/storage/BRH2UR4H/Beckert et al. - 2006 - Verification of Object-Oriented Software. The KeY .pdf:application/pdf}
}

@inproceedings{bohrer_veriphy:_2018,
	location = {Philadelphia, {PA}, {USA}},
	title = {{VeriPhy}: verified controller executables from verified cyber-physical system models},
	isbn = {978-1-4503-5698-5},
	url = {http://dl.acm.org/citation.cfm?doid=3192366.3192406},
	doi = {10.1145/3192366.3192406},
	shorttitle = {{VeriPhy}},
	eventtitle = {the 39th {ACM} {SIGPLAN} Conference},
	pages = {617--630},
	booktitle = {Proceedings of the 39th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation  - {PLDI} 2018},
	publisher = {{ACM} Press},
	author = {Bohrer, Brandon and Tan, Yong Kiam and Mitsch, Stefan and Myreen, Magnus O. and Platzer, André},
	urldate = {2019-01-31},
	date = {2018},
	langid = {english}
}

@online{ahrendt_deductive_nodate,
	title = {Deductive Software Verification – The {KeY} {BookFrom} Theory to Practice – The {KeY} Project},
	url = {https://www.key-project.org/thebook2/},
	author = {Ahrendt, Wolfgang},
	urldate = {2019-01-31},
	langid = {american},
	note = {cyber-physical/{KeY} directory has pdfs for the chapters.},
	file = {Snapshot:/Users/richardford/Zotero/storage/S6JS29Q6/thebook2.html:text/html}
}

@online{czajka_coqhammer:_nodate,
	title = {{CoqHammer}: Strong Automation for Program Verification - {CoqPL} 2018},
	url = {https://popl18.sigplan.org/event/coqpl-2018-coqhammer-strong-automation-for-program-verification},
	abstract = {We present {CoqHammer}: the first full hammer system for
the Coq proof assistant. The system translates Coq logic
to untyped first-order logic and uses external automated
theorem provers ({ATPs}) to prove the translations of user
given conjectures. Based on the output of the {ATPs}, the
conjecture is then re-proved in the logic of Coq using an
eauto-type proof search algorithm. Together with machinelearning
based selection of relevant premises this constitutes
a full hammer system.
The performance of the overall procedure has been evaluated
in a bootstrapping scenario emulating the development
of the Coq standard library. Over 40\% of the theorems in
the Coq standard library can be proved in a push-button
mode in about 40 seconds of real time on a 8-{CPU} system.
This offers a huge saving of human work in programming
language formalizations.},
	author = {Czajka, Lukasz and Kaliszyk, Cezary},
	urldate = {2019-01-31},
	file = {CoqHammer\: Strong Automation for Program Verification - POPL 2018:/Users/richardford/Zotero/storage/QP8A5J8F/coqpl-2018-coqhammer-strong-automation-for-program-verification.html:text/html;Czajka-Kaliszyk-CoqPL18-Slides.pdf:/Users/richardford/Zotero/storage/9XNB7DCK/Czajka-Kaliszyk-CoqPL18-Slides.pdf:application/pdf;CzajkaKaliszyk-CoqPL18-coqhammer.pdf:/Users/richardford/Zotero/storage/E9SCXEBU/CzajkaKaliszyk-CoqPL18-coqhammer.pdf:application/pdf}
}

@online{acm_coqpl_nodate,
	title = {{CoqPL} 2019 The Fifth International Workshop on Coq for Programming Languages - {POPL} 2019},
	url = {https://popl19.sigplan.org/track/CoqPL-2019#program},
	author = {acm},
	urldate = {2019-01-31},
	file = {CoqPL 2019 The Fifth International Workshop on Coq for Programming Languages - POPL 2019:/Users/richardford/Zotero/storage/CMD6KF5K/CoqPL-2019.html:text/html}
}

@online{acm_coqpl_nodate-1,
	title = {{CoqPL} 2018 The Fourth International Workshop on Coq for Programming Languages - {POPL} 2018},
	url = {https://popl18.sigplan.org/track/CoqPL-2018},
	author = {acm},
	urldate = {2019-01-31},
	file = {CoqPL 2018 The Fourth International Workshop on Coq for Programming Languages - POPL 2018:/Users/richardford/Zotero/storage/H23PH3DM/CoqPL-2018.html:text/html;CoqPL 2018 The Fourth International Workshop on Coq for Programming Languages - POPL 2018:/Users/richardford/Zotero/storage/53TLPA9U/CoqPL-2018.html:text/html}
}

@online{acm_coq_nodate,
	title = {Coq for {PL} conference series - {CoqPL} 2019},
	url = {https://popl18.sigplan.org/series/CoqPL},
	author = {acm},
	urldate = {2019-01-31},
	file = {Coq for PL conference series - CoqPL 2019:/Users/richardford/Zotero/storage/82G7Q28U/CoqPL.html:text/html}
}

@online{acm_popl_nodate,
	title = {{POPL} conference series - {POPL} 2020},
	url = {https://popl18.sigplan.org/series/POPL},
	author = {acm},
	urldate = {2019-01-31},
	file = {POPL conference series - POPL 2020:/Users/richardford/Zotero/storage/WXNCFC9B/POPL.html:text/html}
}

@article{cousot_$^2$i:_2019,
	title = {A\${\textasciicircum}2\$I: Abstract\${\textasciicircum}2\$ Interpretation},
	volume = {3},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3290355},
	doi = {10.1145/3290355},
	shorttitle = {A\${\textasciicircum}2\$I},
	abstract = {The fundamental idea of Abstract2 Interpretation (A2I), also called meta-abstract interpretation, is to apply abstract interpretation to abstract interpretation-based static program analyses. A2I is generally meant to use abstract interpretation to analyse properties of program analysers. A2I can be either offline or online. Offline A2I is performed either before the program analysis, such as variable packing used by the Astrée program analyser, or after the program analysis, such as in alarm diagnosis. Online A2I is performed during the program analysis, such as Venet’s cofibred domains or Halbwachs et al.’s and Singh et al.’s variable partitioning techniques for fast polyhedra/numerical abstract domains. We formalize offline and online meta-abstract interpretation and illustrate this notion with the design of widenings and the decomposition of relational abstract domains to speed-up program analyses. This shows how novel static analyses can be extracted as meta-abstract interpretations to design efficient and precise program analysis algorithms.},
	pages = {42:1--42:31},
	issue = {{POPL}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	author = {Cousot, Patrick and Giacobazzi, Roberto and Ranzato, Francesco},
	urldate = {2019-01-31},
	date = {2019-01},
	keywords = {Abstract interpretation, meta-abstract interpretation, program analysis},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/ZVG3RMZK/Cousot et al. - 2019 - A\$^2\$I Abstract\$^2\$ Interpretation.pdf:application/pdf}
}

@article{polikarpova_structuring_2019,
	title = {Structuring the Synthesis of Heap-manipulating Programs},
	volume = {3},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3290385},
	doi = {10.1145/3290385},
	abstract = {This paper describes a deductive approach to synthesizing imperative programs with pointers from declarative specifications expressed in Separation Logic. Our synthesis algorithm takes as input a pair of assertions—a pre- and a postcondition—which describe two states of the symbolic heap, and derives a program that transforms one state into the other, guided by the shape of the heap. Our approach to program synthesis is grounded in proof theory: we introduce the novel framework of Synthetic Separation Logic ({SSL}), which generalises the classical notion of heap entailment P ⊢ Q to incorporate a possibility of transforming a heap satisfying an assertion P into a heap satisfying an assertion Q. A synthesized program represents a proof term for a transforming entailment statement P ↝ Q, and the synthesis procedure corresponds to a proof search. The derived programs are, thus, correct by construction, in the sense that they satisfy the ascribed pre/postconditions, and are accompanied by complete proof derivations, which can be checked independently.  We have implemented a proof search engine for {SSL} in a form of the program synthesizer called {SuSLik}. For efficiency, the engine exploits properties of {SSL} rules, such as invertibility and commutativity of rule applications on separate heaps, to prune the space of derivations it has to consider. We explain and showcase the use of {SSL} on characteristic examples, describe the design of {SuSLik}, and report on our experience of using it to synthesize a series of benchmark programs manipulating heap-based linked data structures.},
	pages = {72:1--72:30},
	issue = {{POPL}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	author = {Polikarpova, Nadia and Sergey, Ilya},
	urldate = {2019-01-31},
	date = {2019-01},
	keywords = {Program Synthesis, Proof Systems, Separation Logic, Type Theory},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/LR6EKQYG/Polikarpova and Sergey - 2019 - Structuring the Synthesis of Heap-manipulating Pro.pdf:application/pdf}
}

@article{leino_assertional_2015,
	title = {An Assertional Proof of the Stability and Correctness of Natural Mergesort},
	volume = {17},
	issn = {1529-3785},
	url = {http://doi.acm.org/10.1145/2814571},
	doi = {10.1145/2814571},
	abstract = {We present a mechanically verified implementation of the sorting algorithm Natural Mergesort that consists of a few methods specified by their contracts of pre/post conditions. Methods are annotated with assertions that allow the automatic verification of the contract satisfaction. This program-proof is made using the state-of-the-art verifier Dafny. We verify not only the standard sortedness property, but also that the algorithm performs a stable sort. Throughout the article, we provide and explain the complete text of the program-proof.},
	pages = {6:1--6:22},
	number = {1},
	journaltitle = {{ACM} Trans. Comput. Logic},
	author = {Leino, K. Rustan M. and Lucio, Paqui},
	urldate = {2019-01-31},
	date = {2015-11},
	keywords = {dafny, formal methods, natural mergesort, software engineering, sorting, stability, theorem proving, Verification},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/KNJPYQ9I/Leino and Lucio - 2015 - An Assertional Proof of the Stability and Correctn.pdf:application/pdf}
}

@inproceedings{christakis_collaborative_2012,
	title = {Collaborative Verification and Testing with Explicit Assumptions},
	isbn = {978-3-642-32759-9},
	series = {Lecture Notes in Computer Science},
	abstract = {Many mainstream static code checkers make a number of compromises to improve automation, performance, and accuracy. These compromises include not checking certain program properties as well as making implicit, unsound assumptions. Consequently, the results of such static checkers do not provide definite guarantees about program correctness, which makes it unclear which properties remain to be tested. We propose a technique for collaborative verification and testing that makes compromises of static checkers explicit such that they can be compensated for by complementary checkers or testing. Our experiments suggest that our technique finds more errors and proves more properties than static checking alone, testing alone, and combinations that do not explicitly document the compromises made by static checkers. Our technique is also useful to obtain small test suites for partially-verified programs.},
	pages = {132--146},
	booktitle = {{FM} 2012: Formal Methods},
	publisher = {Springer Berlin Heidelberg},
	author = {Christakis, Maria and Müller, Peter and Wüstholz, Valentin},
	editor = {Giannakopoulou, Dimitra and Méry, Dominique},
	date = {2012},
	langid = {english},
	keywords = {Static Checker, Symbolic Execution, Test Case Generation, Testing Tool, Tool Chain},
	file = {Christakis et al. - 2012 - Collaborative Verification and Testing with Explic.pdf:/Users/richardford/Zotero/storage/N3T6EIWH/Christakis et al. - 2012 - Collaborative Verification and Testing with Explic.pdf:application/pdf}
}

@article{leino_co-induction_2013,
	title = {Co-Induction Simply: Automatic Co-Inductive Proofs in a Program Verifier},
	url = {https://www.microsoft.com/en-us/research/publication/co-induction-simply-automatic-co-inductive-proofs-in-a-program-verifier/},
	shorttitle = {Co-Induction Simply},
	abstract = {Program verification relies heavily on induction, which has received decades of attention in mechanical verification tools. When program correctness is best described by infinite structures, program verification is usefully aided also by co-induction, which has not benefited from the same degree of tool support. Co-induction is complicated to work with in interactive proof assistants and …},
	author = {Leino, Rustan and Moskal, Michal},
	urldate = {2019-01-31},
	date = {2013-07-12},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/UEL7SVLY/Leino and Moskal - 2013 - Co-Induction Simply Automatic Co-Inductive Proofs.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/DXHEKVNI/co-induction-simply-automatic-co-inductive-proofs-in-a-program-verifier.html:text/html}
}

@article{amin_computing_2016,
	title = {Computing with an {SMT} Solver},
	volume = {8570},
	url = {https://www.microsoft.com/en-us/research/publication/computing-smt-solver/},
	abstract = {Satisfiability modulo theories ({SMT}) solvers that support quantifier instantiations via matching triggers can be programmed to give practical support for user-defined theories. Care must be taken to avoid so-called matching loops, which may prevent termination of the solver. By design, such avoidance limits the extent to which the {SMT} solver is able to apply the …},
	author = {Amin, Nada and Leino, Rustan and Rompf, Tiark},
	urldate = {2019-01-31},
	date = {2016-12-28},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/TD5DRRJV/Amin et al. - 2016 - Computing with an SMT Solver.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/PMXMDKIE/computing-smt-solver.html:text/html}
}

@article{hatcliff_behavioral_2012,
	title = {Behavioral Interface Specification Languages},
	volume = {44},
	issn = {0360-0300},
	url = {http://doi.acm.org/10.1145/2187671.2187678},
	doi = {10.1145/2187671.2187678},
	abstract = {Behavioral interface specification languages provide formal code-level annotations, such as preconditions, postconditions, invariants, and assertions that allow programmers to express the intended behavior of program modules. Such specifications are useful for precisely documenting program behavior, for guiding implementation, and for facilitating agreement between teams of programmers in modular development of software. When used in conjunction with automated analysis and program verification tools, such specifications can support detection of common code vulnerabilities, capture of light-weight application-specific semantic properties, generation of test cases and test oracles, and full formal program verification. This article surveys behavioral interface specification languages with a focus toward automatic program verification and with a view towards aiding the Verified Software Initiative—a fifteen-year, cooperative, international project directed at the scientific challenges of large-scale software verification.},
	pages = {16:1--16:58},
	number = {3},
	journaltitle = {{ACM} Comput. Surv.},
	author = {Hatcliff, John and Leavens, Gary T. and Leino, K. Rustan M. and Müller, Peter and Parkinson, Matthew},
	urldate = {2019-01-31},
	date = {2012-06},
	keywords = {Abstraction, assertion, behavioral subtyping, frame conditions, interface specification language, invariant, {JML}, postcondition, precondition, separation logic, {SPARK}, Spec\#},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/F4MQHIJH/Hatcliff et al. - 2012 - Behavioral Interface Specification Languages.pdf:application/pdf}
}

@article{leino_verification_2016,
	title = {Verification of Concurrent Programs with Chalice},
	url = {https://www.microsoft.com/en-us/research/publication/verification-concurrent-programs-chalice/},
	abstract = {A program verifier is a tool that allows developers to prove that their code satisfies its specification for every possible input and every thread schedule. These lecture notes describe a verifier for concurrent programs called Chalice. Chalice’s verification methodology centers around permissions and permission transfer. In particular, a memory location may be accessed by a …},
	author = {Leino, Rustan and Müller, Peter and Smans, Jan},
	urldate = {2019-01-31},
	date = {2016-12-29},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/ZMNMZ55Z/Leino et al. - 2016 - Verification of Concurrent Programs with Chalice.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/C9ZBR9ZX/verification-concurrent-programs-chalice.html:text/html}
}

@article{leino_stepwise_2016,
	title = {Stepwise Refinement of Heap-Manipulating Code in Chalice},
	url = {https://www.microsoft.com/en-us/research/publication/stepwise-refinement-heap-manipulating-code-chalice/},
	abstract = {Stepwise refinement is a well-studied technique for developing a program from an abstract description to a concrete implementation. This paper describes a system with automated tool support for refinement, powered by a stateof-the-art verification engine that uses an {SMT} solver. Unlike previous refinement systems, users of the presented system interact only via declarations in the …},
	author = {Leino, Rustan and Yessenov, Kuat},
	urldate = {2019-01-31},
	date = {2016-12-29},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/8RNI6Q8U/Leino and Yessenov - 2016 - Stepwise Refinement of Heap-Manipulating Code in C.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/6YWHWCEJ/stepwise-refinement-heap-manipulating-code-chalice.html:text/html}
}

@article{leino_fine-grained_2016,
	title = {Fine-grained Caching of Verification Results},
	volume = {9206},
	url = {https://www.microsoft.com/en-us/research/publication/fine-grained-caching-verification-results/},
	abstract = {Developing provably correct programs is an incremental process that often involves a series of interactions with a program verifier. To increase the responsiveness of the program verifier during such interactions, we designed a system for fine-grained caching of verification results. The caching system uses the program’s call graph and control-flow graph to focus the verification …},
	author = {Leino, Rustan and Wüstholz, Valentin},
	urldate = {2019-01-31},
	date = {2016-12-28},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/4WMA66J9/Leino and Wüstholz - 2016 - Fine-grained Caching of Verification Results.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/DCH5FZKS/fine-grained-caching-verification-results.html:text/html}
}

@article{koenig_programming_2016,
	title = {Programming Language Features for Refinement},
	url = {https://www.microsoft.com/en-us/research/publication/programming-language-features-refinement/},
	abstract = {Algorithmic and data refinement are well studied topics that provide a mathematically rigorous approach to gradually introducing details in the implementation of software. Program refinements are performed in the context of some programming language, but mainstream languages lack features for recording the sequence of refinement steps in the program text. To experiment with the combination …},
	author = {Koenig, Jason and Leino, Rustan},
	urldate = {2019-01-31},
	date = {2016-12-28},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/2F7P595B/Koenig and Leino - 2016 - Programming Language Features for Refinement.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/MF44ARJ2/programming-language-features-refinement.html:text/html}
}

@article{leino_compiling_2016,
	title = {Compiling Hilbert's epsilon Operator},
	volume = {35},
	url = {https://www.microsoft.com/en-us/research/publication/compiling-hilberts-%cf%b5-operator/},
	abstract = {Hilbert’s epsilon (ϵ) operator is a binder that picks an arbitrary element from a nonempty set. The operator is typically used in logics and proof engines. This paper contributes a discussion of considerations in supporting this operator in a programming language. More specifically, the paper presents the design choices made around supporting this operator in …},
	journaltitle = {{LPAR}-20. 20th International Conferences on Logic for Programming, Artificial Intelligence and Reasoning},
	author = {Leino, Rustan},
	urldate = {2019-01-31},
	date = {2016-12-28},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/WIX4KMWE/Leino - 2016 - Compiling Hilbert's Ïµ Operator.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/NMJWCA8C/compiling-hilberts-ϵ-operator.html:text/html}
}

@article{parkinson_relationship_nodate,
	title = {The Relationship between Separation Logic and Implicit Dynamic Frames},
	volume = {6602},
	abstract = {Separation logic is a concise method for specifying programs that manipulate dynamically allocated storage. Partially inspired by separation logic, Implicit Dynamic Frames has recently been proposed, aiming at ﬁrst-order tool support. In this paper, we provide a total heap semantics for a standard separation logic, and prove it equivalent to the standard model. With small adaptations, we then show how to give a direct semantics to implicit dynamic frames and show this semantics correctly captures the existing deﬁnitions. This precisely connects the two logics. As a consequence of this connection, we show that a fragment of separation logic can be faithfully encoded in a ﬁrst-order automatic veriﬁcation tool (Chalice).},
	pages = {439--458},
	journaltitle = {{LNCS}},
	author = {Parkinson, Matthew J and Summers, Alexander J},
	langid = {english},
	note = {{ESOP} 2011},
	file = {Parkinson and Summers - The Relationship between Separation Logic and Impl.pdf:/Users/richardford/Zotero/storage/LMRQWFDB/Parkinson and Summers - The Relationship between Separation Logic and Impl.pdf:application/pdf}
}

@article{leino_verified_2016,
	title = {Verified Calculations},
	url = {https://www.microsoft.com/en-us/research/publication/verified-calculations/},
	abstract = {Calculational proofs—proofs by stepwise formula manipulation—are praised for their rigor, readability, and elegance. It seems desirable to reuse this style, often employed on paper, in the context of mechanized reasoning, and in particular, program verification. This work leverages the power of {SMT} solvers to machine-check calculational proofs at the level of detail they are usually …},
	author = {Leino, Rustan and Polikarpova, Nadia},
	urldate = {2019-01-31},
	date = {2016-12-28},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/E2KFJ246/Leino and Polikarpova - 2016 - Verified Calculations.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/HHI48KJD/verified-calculations.html:text/html}
}

@article{leino_well-founded_2016,
	title = {Well-Founded Functions and Extreme Predicates in Dafny: A Tutorial},
	volume = {40},
	url = {https://www.microsoft.com/en-us/research/publication/well-founded-functions-extreme-predicates-dafny-tutorial/},
	shorttitle = {Well-Founded Functions and Extreme Predicates in Dafny},
	abstract = {A recursive function is well defined if its every recursive call corresponds a decrease in some well-founded order. Such well-founded functions are useful for example in computer programs when computing a value from some input. A boolean function can also be defined as an extreme solution to a recurrence relation, that is, as a least …},
	author = {Leino, Rustan},
	urldate = {2019-01-31},
	date = {2016-12-28},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/55G4TL2T/Leino - 2016 - Well-Founded Functions and Extreme Predicates in D.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/L5BADAPF/well-founded-functions-extreme-predicates-dafny-tutorial.html:text/html}
}

@online{acm_acm_nodate,
	title = {{ACM} Classification Codes},
	url = {https://cran.r-project.org/web/classifications/ACM.html},
	author = {acm},
	urldate = {2019-02-01},
	file = {ACM Classification Codes:/Users/richardford/Zotero/storage/Q64UNUSQ/ACM.html:text/html}
}

@online{acm_msc2010_nodate,
	title = {{MSC}2010 database},
	url = {https://mathscinet.ams.org/msc/msc2010.html},
	author = {acm},
	urldate = {2019-02-01},
	file = {MSC2010 database:/Users/richardford/Zotero/storage/D2RWK6JM/msc2010.html:text/html}
}

@online{sozeau_typed_nodate,
	title = {Typed Template Coq - {POPL} 2018},
	url = {https://popl18.sigplan.org/event/coqpl-2018-typed-template-coq},
	author = {Sozeau, Matthieu},
	urldate = {2019-02-01},
	file = {Typed Template Coq - POPL 2018:/Users/richardford/Zotero/storage/YNUW6KVH/coqpl-2018-typed-template-coq.html:text/html}
}

@article{anand_typed_nodate,
	title = {Typed Template Coq},
	abstract = {Template-Coq1 is a plugin for Coq, originally implemented by Malecha [7], which provides a reifier for Coq terms and global declarations, as represented in the Coq kernel, as well as a denotation command. Initially, it was developed for the purpose of writing functions on Coq’s {AST} in Gallina. Recently, its use was extended for the needs of the {CertiCoq} certified compiler project [2], which uses it as its front-end language and to derive parametricity properties [1], and the work of [5] on extracting Coq terms to a {CBV} λ-calculus. However, the syntax currently lacks semantics, be it typing semantics or operational semantics, which should reflect, as formal specifications in Coq, the semantics of Coq itself. This is an issue for {CertiCoq} where both a non-deterministic small step semantics and a deterministic call-by-value big step semantics had to be defined and preserved, without an “official” reference specification to refer to. Our hope with this work is to remedy this situation and provide a formal semantics of Coq’s implemented type theory, that can independently be refined and studied. By implementing a (partial) independent checker in Coq, we can also help formalize certified translations from Coq to Coq (Section 3).},
	pages = {2},
	author = {Anand, Abhishek and Tabareau, Simon Boulier Nicolas and Sozeau, Matthieu},
	langid = {english},
	file = {Anand et al. - Typed Template Coq.pdf:/Users/richardford/Zotero/storage/3GZEWLIT/Anand et al. - Typed Template Coq.pdf:application/pdf}
}

@article{sozeau_typed_nodate-1,
	title = {Typed Template Coq - Slides},
	pages = {11},
	author = {Sozeau, Matthieu},
	langid = {english},
	file = {Typed Template Coq.pdf:/Users/richardford/Zotero/storage/4PGZZ48U/Typed Template Coq.pdf:application/pdf}
}

@online{appel_certicoq:_nodate,
	title = {{CertiCoq}: A verified compiler for Coq - {POPL} 2017},
	url = {https://popl17.sigplan.org/event/main-certicoq-a-verified-compiler-for-coq},
	author = {Appel, Andrew W.},
	urldate = {2019-02-01},
	file = {CertiCoq A verified compiler for Coq - POPL 2017.pdf:/Users/richardford/Zotero/storage/FPWSH4GR/CertiCoq A verified compiler for Coq - POPL 2017.pdf:application/pdf;CertiCoq\: A verified compiler for Coq - POPL 2017:/Users/richardford/Zotero/storage/E3YEVA9B/main-certicoq-a-verified-compiler-for-coq.html:text/html}
}

@online{adewale_implementing_nodate,
	title = {Implementing a high-performance key-value store using a trie of B+-Trees with cursors {\textbar} Computer Science Department at Princeton University},
	url = {https://www.cs.princeton.edu/research/techreps/TR-004-18},
	abstract = {Abstract
In this paper, we discuss the implementation of a serial main-memory key-value store based on Masstree[6]. Similar to Masstree, the key-value store is implemented as a trie-like tree of B+-Trees, where each B+-Tree is responsible for a xed-length slice of a variable-length key. However, one of the major dierences between our key-value store and Masstree is that our B+-tree implementation (a component of the key-value store) takes linear time to insert a set of sorted records. This is compared to a traditional B+-tree implementation that would take linearithmic time. Moreover, partially sorting a sequence of operation leads to substantial performance gains. This is made possible using a data structure for navigating B+-trees called a B+-tree cursor. As our next operation is amortized constant time, our B+-tree does not need to maintain cross links between leaf nodes. We also briefy show that this same data structure can be extended to the trie of B+-Trees to ensure amortized linear time for bulk insertion of key-value pairs in the key-value store. We were inspired with this idea of B+-Tree cursors from the {SQLite} [5] B-tree source code.},
	author = {Adewale, Oluwatosin},
	urldate = {2019-02-01},
	file = {Implementing a high-performance key-value store us.pdf:/Users/richardford/Zotero/storage/HAARNTAN/Implementing a high-performance key-value store us.pdf:application/pdf;Implementing a high-performance key-value store using a trie of B+-Trees with cursors | Computer Science Department at Princeton University:/Users/richardford/Zotero/storage/ZNDWIDJ3/TR-004-18.html:text/html}
}

@article{barriere_vst_nodate,
	title = {{VST} Veriﬁcation of B+Trees with Cursors},
	abstract = {The {DeepSpecDB} project aims to deﬁne, specify and verify a high-performance concurrent in-memory database system. Based on {MassTree}, it uses B+Trees, a well-studied key-value data structure. Our sequential B+Trees library uses cursors, introduced in the database engine {SQLite}. Such cursors reduce the complexity of operations when dealing with partially sorted data. We deﬁne a Coq formal model for such trees, then use it to specify and prove the correctness of the C implementation using the Veriﬁed Software Toolchain.},
	pages = {19},
	author = {Barriere, Aurele and Appel, Andrew},
	langid = {english},
	file = {Barriere and Appel - VST Veriﬁcation of B+Trees with Cursors.pdf:/Users/richardford/Zotero/storage/8NTCGXZV/Barriere and Appel - VST Veriﬁcation of B+Trees with Cursors.pdf:application/pdf}
}

@software{appel_deepspecdb_2019,
	title = {{DeepSpecDB} - github},
	rights = {View license},
	url = {https://github.com/PrincetonUniversity/DeepSpecDB},
	publisher = {{PrincetonUniversity}},
	author = {Appel, Andrew W.},
	urldate = {2019-02-01},
	date = {2019-01-31},
	note = {original-date: 2017-11-30T14:24:30Z}
}

@article{chen_project_nodate,
	title = {Project Report on {DeepSpecDB}},
	abstract = {Recent years have witnessed a rapid development of mainmemory database systems thanks to the growingly aﬀordable memory. {DeepSpecDB} is another main-memory database management system implemented in C with deep speciﬁcation and end-to-end veriﬁcation guaranteeing the correctness of the system.},
	pages = {35},
	author = {Chen, Yixuan},
	langid = {english},
	file = {Chen - Project Report on DeepSpecDB.pdf:/Users/richardford/Zotero/storage/HNLI2SEC/Chen - Project Report on DeepSpecDB.pdf:application/pdf}
}

@inproceedings{sozeau_equations:_2010,
	title = {Equations: A Dependent Pattern-Matching Compiler},
	isbn = {978-3-642-14052-5},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Equations},
	abstract = {We present a compiler for definitions made by pattern matching on inductive families in the Coq system. It allows to write structured, recursive dependently-typed functions as a set of equations, automatically find their realization in the core type theory and generate proofs to ease reasoning on them. It provides a complete package to define and reason on functions in the proof assistant, substantially reducing the boilerplate code and proofs one usually has to write, also hiding the intricacies related to the use of dependent types and complex recursion schemes.},
	pages = {419--434},
	booktitle = {Interactive Theorem Proving},
	publisher = {Springer Berlin Heidelberg},
	author = {Sozeau, Matthieu},
	editor = {Kaufmann, Matt and Paulson, Lawrence C.},
	date = {2010},
	langid = {english},
	keywords = {Proof Assistant, Recursive Call, Split Node, Type Theory, User Node},
	file = {Sozeau - 2010 - Equations A Dependent Pattern-Matching Compiler.pdf:/Users/richardford/Zotero/storage/FSGZK8IK/Sozeau - 2010 - Equations A Dependent Pattern-Matching Compiler.pdf:application/pdf}
}

@inproceedings{delaware_fiat:_2015,
	location = {New York, {NY}, {USA}},
	title = {Fiat: Deductive Synthesis of Abstract Data Types in a Proof Assistant},
	isbn = {978-1-4503-3300-9},
	url = {http://doi.acm.org/10.1145/2676726.2677006},
	doi = {10.1145/2676726.2677006},
	series = {{POPL} '15},
	shorttitle = {Fiat},
	abstract = {We present Fiat, a library for the Coq proof assistant supporting refinement of declarative specifications into efficient functional programs with a high degree of automation. Each refinement process leaves a proof trail, checkable by the normal Coq kernel, justifying its soundness. We focus on the synthesis of abstract data types that package methods with private data. We demonstrate the utility of our framework by applying it to the synthesis of query structures -- abstract data types with {SQL}-like query and insert operations. Fiat includes a library for writing specifications of query structures in {SQL}-inspired notation, expressing operations over relations (tables) in terms of mathematical sets. This library includes a suite of tactics for automating the refinement of specifications into efficient, correct-by-construction {OCaml} code. Using these tactics, a programmer can generate such an implementation completely automatically by only specifying the equivalent of {SQL} indexes, data structures capturing useful views of the abstract data. Throughout we speculate on the new programming modularity possibilities enabled by an automated refinement system with proved-correct rules.},
	pages = {689--700},
	booktitle = {Proceedings of the 42Nd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Delaware, Benjamin and Pit-Claudel, Clément and Gross, Jason and Chlipala, Adam},
	urldate = {2019-02-01},
	date = {2015},
	keywords = {deductive synthesis, mechanized derivation of abstract data types},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/N7HNG7DV/Delaware et al. - 2015 - Fiat Deductive Synthesis of Abstract Data Types i.pdf:application/pdf}
}

@online{chlipala_end_nodate,
	title = {{THE} {END} {OF} {HISTORY}? {USING} A {PROOF} {ASSISTANT} {TO} {REPLACE} {LANGUAGE} {DESIGN} {WITH} {LIBRARY} {DESIGN}},
	url = {https://snapl.org/2017/abstracts/Chlipala.html},
	abstract = {Functionality of software systems has exploded in part because of advances in programming-language support for packaging reusable functionality as libraries. Developers benefit from the uniformity that comes of exposing many interfaces in the same language, as opposed to stringing together hodgepodges of command-line tools. Domain-specific languages may be viewed as an evolution of the power of reusable interfaces, when those interfaces become so flexible as to deserve to be called programming languages. However, common approaches to domain-specific languages give up many of the hard-won advantages of library-building in a rich common language, and even the traditional approach poses significant challenges in learning new {APIs}. We suggest that instead of continuing to develop new domain-specific languages, our community should embrace library-based ecosystems within very expressive languages that mix programming and theorem proving. Our prototype framework Fiat, a library for the Coq proof assistant, turns languages into easily comprehensible libraries via the key idea of modularizing functionality and performance away from each other, the former via macros that desugar into higher-order logic and the latter via optimization scripts that derive efficient code from logical programs.},
	author = {Chlipala, Adam and Delaware, Benjamin and Duchovni, Samuel and Gross, Jason and Pit-Claudel, Clément and Suriyakarn, Sorawit and Wang, Peng and ye, Katherine},
	urldate = {2019-02-01},
	file = {SNAPL 2017:/Users/richardford/Zotero/storage/2SE673GH/Chlipala.html:text/html;SNAPL 2017.pdf:/Users/richardford/Zotero/storage/M7L2Z5GW/SNAPL 2017.pdf:application/pdf}
}

@article{gonthier_formal_2008,
	title = {Formal Proof—The Four- Color Theorem},
	volume = {55},
	pages = {12},
	number = {11},
	author = {Gonthier, Georges},
	date = {2008},
	langid = {english},
	file = {Gonthier - 2008 - Formal Proof—The Four- Color Theorem.pdf:/Users/richardford/Zotero/storage/2DIXM75Q/Gonthier - 2008 - Formal Proof—The Four- Color Theorem.pdf:application/pdf}
}

@article{wiedijk_formal_2008,
	title = {Formal Proof—Getting Started},
	volume = {55},
	pages = {7},
	number = {11},
	author = {Wiedijk, Freek},
	date = {2008},
	langid = {english},
	file = {Wiedijk - 2008 - Formal Proof—Getting Started.pdf:/Users/richardford/Zotero/storage/J3KGYSKG/Wiedijk - 2008 - Formal Proof—Getting Started.pdf:application/pdf}
}

@article{harrison_formal_2008,
	title = {Formal Proof—Theory and Practice},
	volume = {55},
	pages = {12},
	number = {11},
	author = {Harrison, John},
	date = {2008},
	langid = {english},
	file = {Harrison - 2008 - Formal Proof—Theory and Practice.pdf:/Users/richardford/Zotero/storage/AUC8R3WS/Harrison - 2008 - Formal Proof—Theory and Practice.pdf:application/pdf}
}

@inproceedings{petcher_foundational_2015,
	title = {The Foundational Cryptography Framework},
	isbn = {978-3-662-46666-7},
	url = {http://www.cs.cornell.edu/~jgm/papers/FCF.pdf},
	series = {Lecture Notes in Computer Science},
	abstract = {We present the Foundational Cryptography Framework ({FCF}) for developing and checking complete proofs of security for cryptographic schemes within a proof assistant. This is a general-purpose framework that is capable of modeling and reasoning about a wide range of cryptographic schemes, security definitions, and assumptions. Security is proven in the computational model, and the proof provides concrete bounds as well as asymptotic conclusions. {FCF} provides a language for probabilistic programs, a theory that is used to reason about programs, and a library of tactics and definitions that are useful in proofs about cryptography. The framework is designed to leverage fully the existing theory and capabilities of the Coq proof assistant in order to reduce the effort required to develop proofs.},
	pages = {53--72},
	booktitle = {Principles of Security and Trust},
	publisher = {Springer Berlin Heidelberg},
	author = {Petcher, Adam and Morrisett, Greg},
	editor = {Focardi, Riccardo and Myers, Andrew},
	date = {2015},
	langid = {english},
	keywords = {Coq, Cryptography, Proof Assistant, Protocol Verification},
	file = {Petcher and Morrisett - 2015 - The Foundational Cryptography Framework.pdf:/Users/richardford/Zotero/storage/8JFX6AUD/Petcher and Morrisett - 2015 - The Foundational Cryptography Framework.pdf:application/pdf}
}

@article{fisher_kathleen_hacms_2017,
	title = {The {HACMS} program: using formal methods to eliminate exploitable bugs},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0401},
	doi = {10.1098/rsta.2015.0401},
	shorttitle = {The {HACMS} program},
	abstract = {For decades, formal methods have offered the promise of verified software that does not have exploitable bugs. Until recently, however, it has not been possible to verify software of sufficient complexity to be useful. Recently, that situation has changed. {SeL}4 is an open-source operating system microkernel efficient enough to be used in a wide range of practical applications. Its designers proved it to be fully functionally correct, ensuring the absence of buffer overflows, null pointer exceptions, use-after-free errors, etc., and guaranteeing integrity and confidentiality. The {CompCert} Verifying C Compiler maps source C programs to provably equivalent assembly language, ensuring the absence of exploitable bugs in the compiler. A number of factors have enabled this revolution, including faster processors, increased automation, more extensive infrastructure, specialized logics and the decision to co-develop code and correctness proofs rather than verify existing artefacts. In this paper, we explore the promise and limitations of current formal-methods techniques. We discuss these issues in the context of {DARPA}’s {HACMS} program, which had as its goal the creation of high-assurance software for vehicles, including quadcopters, helicopters and automobiles.This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20150401},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{Fisher Kathleen} and {Launchbury John} and {Richards Raymond}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/P6Z2SRJK/Fisher Kathleen et al. - 2017 - The HACMS program using formal methods to elimina.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/Z7N5TJNE/rsta.2015.html:text/html}
}

@online{royalsociety_philosophical_nodate,
	title = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	url = {https://royalsocietypublishing.org/journal/rsta},
	author = {royalsociety},
	urldate = {2019-02-01},
	file = {Home | Philosophical Transactions of the Royal Society A\: Mathematical, Physical and Engineering Sciences:/Users/richardford/Zotero/storage/UL78NAHS/rsta.html:text/html}
}

@online{royalsociety_proceedings_nodate,
	title = {Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	url = {https://royalsocietypublishing.org/journal/rspa},
	author = {royalsociety},
	urldate = {2019-02-01},
	file = {Home | Proceedings of the Royal Society A\: Mathematical, Physical and Engineering Sciences:/Users/richardford/Zotero/storage/M8HSK2QL/rspa.html:text/html}
}

@article{choi_kami:_2017,
	title = {Kami: A Platform for High-level Parametric Hardware Specification and Its Modular Verification},
	volume = {1},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3110268},
	doi = {10.1145/3110268},
	shorttitle = {Kami},
	abstract = {It has become fairly standard in the programming-languages research world to verify functional programs in proof assistants using induction, algebraic simplification, and rewriting. In this paper, we introduce Kami, a Coq library that enables similar expressive and modular reasoning for hardware designs expressed in the style of the Bluespec language. We can specify, implement, and verify realistic designs entirely within Coq, ending with automatic extraction into a pipeline that bottoms out in {FPGAs}. Our methodology, using labeled transition systems, has been evaluated in a case study verifying an infinite family of multicore systems, with cache-coherent shared memory and pipelined cores implementing (the base integer subset of) the {RISC}-V instruction set.},
	pages = {24:1--24:30},
	issue = {{ICFP}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	author = {Choi, Joonwon and Vijayaraghavan, Muralidaran and Sherman, Benjamin and Chlipala, Adam and {Arvind}},
	urldate = {2019-02-01},
	date = {2017-08},
	keywords = {formal verification, hardware, proof assistants},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/MC26D45K/Choi et al. - 2017 - Kami A Platform for High-level Parametric Hardwar.pdf:application/pdf}
}

@article{delaware_narcissus:_nodate,
	title = {Narcissus: Correct-By-Construction Derivation of Decoders and Encoders from Binary Formats},
	abstract = {It is a neat result from functional programming that libraries of parser combinators can support rapid construction of decoders for quite a range of formats. With a little more work, the same combinator program can denote both a decoder and an encoder. Unfortunately, the real world is full of gnarly formats, as with the packet formats that make up the standard Internet protocol stack. Most past parser-combinator approaches cannot handle these formats, and the few exceptions require redundancy – one part of the natural grammar needs to be hand-translated into hints in multiple parts of a parser program. We show how to recover very natural and nonredundant format specifications, covering all popular network packet formats and generating both decoders and encoders automatically. The catch is that we use the Coq proof assistant to derive both kinds of artifacts using tactics, automatically, in a way that guarantees that they form inverses of each other. We used our approach to reimplement packet processing for a full Internet protocol stack, inserting our replacement into the {OCaml}-based {MirageOS} unikernel, resulting in minimal performance degradation.},
	pages = {14},
	author = {Delaware, Benjamin and Suriyakarn, Sorawit and Pit-Claudel, Clément and Ye, Qianchuan and Chlipala, Adam},
	langid = {english},
	file = {Delaware et al. - Narcissus Correct-By-Construction Derivation of D.pdf:/Users/richardford/Zotero/storage/6NNY3UA7/Delaware et al. - Narcissus Correct-By-Construction Derivation of D.pdf:application/pdf}
}

@article{delaware_narcissus:_2018,
	title = {Narcissus: Deriving Correct-By-Construction Decoders and Encoders from Binary Formats},
	url = {https://arxiv.org/abs/1803.04870v2},
	shorttitle = {Narcissus},
	abstract = {It is a neat result from functional programming that libraries of parser
combinators can support rapid construction of decoders for quite a range of
formats. With a little more work, the same combinator program can denote both a
decoder and an encoder. Unfortunately, the real world is full of gnarly
formats, as with the packet formats that make up the standard Internet protocol
stack. Most past parser-combinator approaches cannot handle these formats, and
the few exceptions require redundancy -- one part of the natural grammar needs
to be hand-translated into hints in multiple parts of a parser program. We show
how to recover very natural and nonredundant format specifications, covering
all popular network packet formats and generating both decoders and encoders
automatically. The catch is that we use the Coq proof assistant to derive both
kinds of artifacts using tactics, automatically, in a way that guarantees that
they form inverses of each other. We used our approach to reimplement packet
processing for a full Internet protocol stack, inserting our replacement into
the {OCaml}-based {MirageOS} unikernel, resulting in minimal performance
degradation.},
	author = {Delaware, Benjamin and Suriyakarn, Sorawit and Pit--Claudel, Clément and Ye, Qianchuan and Chlipala, Adam},
	urldate = {2019-02-01},
	date = {2018-03-13},
	langid = {english},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/HPDJVDBJ/Delaware et al. - 2018 - Narcissus Deriving Correct-By-Construction Decode.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/JEN8SSZV/1803.html:text/html}
}

@article{klein_gerwin_provably_2017,
	title = {Provably trustworthy systems},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0404},
	doi = {10.1098/rsta.2015.0404},
	abstract = {We present recent work on building and scaling trustworthy systems with formal, machine-checkable proof from the ground up, including the operating system kernel, at the level of binary machine code. We first give a brief overview of the {seL}4 microkernel verification and how it can be used to build verified systems. We then show two complementary techniques for scaling these methods to larger systems: proof engineering, to estimate verification effort; and code/proof co-generation, for scalable development of provably trustworthy applications.This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20150404},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{Klein Gerwin} and {Andronick June} and {Keller Gabriele} and {Matichuk Daniel} and {Murray Toby} and {O'Connor Liam}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/5NUUJ5IV/Klein Gerwin et al. - 2017 - Provably trustworthy systems.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/XR76Z7EA/rsta.2015.html:text/html}
}

@article{batty_mark_compositional_2017,
	title = {Compositional relaxed concurrency},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0406},
	doi = {10.1098/rsta.2015.0406},
	abstract = {There is a broad design space for concurrent computer processors: they can be optimized for low power, low latency or high throughput. This freedom to tune each processor design to its niche has led to an increasing diversity of machines, from powerful pocketable devices to those responsible for complex and critical tasks, such as car guidance systems. Given this context, academic concurrency research sounds notes of both caution and optimism. Caution because recent work has uncovered flaws in the way we explain the subtle memory behaviour of concurrent systems: specifications have been shown to be incorrect, leading to bugs throughout the many layers of the system. And optimism because our tools and methods for verifying the correctness of concurrent code—although built above an idealized model of concurrency—are becoming more mature. This paper looks at the way we specify the memory behaviour of concurrent systems and suggests a new direction. Currently, there is a siloed approach, with each processor and programming language specified separately in an incomparable way. But this does not match the structure of our programs, which may use multiple processors and languages together. Instead we propose a compositional approach, where program components carry with them a description of the sort of concurrency they rely on, and there is a mechanism for composing these. This will support not only components written for the multiple varied processors found in a modern system but also those that use idealized models of concurrency, providing a sound footing for mature verification techniques.This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20150406},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{Batty Mark}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/F3KZSHAP/Batty Mark - 2017 - Compositional relaxed concurrency.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/2VP9GJZV/rsta.2015.html:text/html}
}

@article{appel_andrew_w._position_2017,
	title = {Position paper: the science of deep specification},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2016.0331},
	doi = {10.1098/rsta.2016.0331},
	shorttitle = {Position paper},
	abstract = {We introduce our efforts within the project ‘The science of deep specification’ to work out the key formal underpinnings of industrial-scale formal specifications of software and hardware components, anticipating a world where large verified systems are routinely built out of smaller verified components that are also used by many other projects. We identify an important class of specification that has already been used in a few experiments that connect strong component-correctness theorems across the work of different teams. To help popularize the unique advantages of that style, we dub it deep specification, and we say that it encompasses specifications that are rich, two-sided, formal and live (terms that we define in the article). Our core team is developing a proof-of-concept system (based on the Coq proof assistant) whose specification and verification work is divided across largely decoupled subteams at our four institutions, encompassing hardware microarchitecture, compilers, operating systems and applications, along with cross-cutting principles and tools for effective specification. We also aim to catalyse interest in the approach, not just by basic researchers but also by users in industry.This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20160331},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{Appel Andrew W.} and {Beringer Lennart} and {Chlipala Adam} and {Pierce Benjamin C.} and {Shao Zhong} and {Weirich Stephanie} and {Zdancewic Steve}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/6IKBBI2V/Appel Andrew W. et al. - 2017 - Position paper the science of deep specification.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/492EXHEP/rsta.2016.html:text/html}
}

@article{david_cristina_program_2017,
	title = {Program synthesis: challenges and opportunities},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0403},
	doi = {10.1098/rsta.2015.0403},
	shorttitle = {Program synthesis},
	abstract = {Program synthesis is the mechanized construction of software, dubbed ‘self-writing code’. Synthesis tools relieve the programmer from thinking about how the problem is to be solved; instead, the programmer only provides a description of what is to be achieved. Given a specification of what the program should do, the synthesizer generates an implementation that provably satisfies this specification. From a logical point of view, a program synthesizer is a solver for second-order existential logic. Owing to the expressiveness of second-order logic, program synthesis has an extremely broad range of applications. We survey some of these applications as well as recent trends in the algorithms that solve the program synthesis problem. In particular, we focus on an approach that has raised the profile of program synthesis and ushered in a generation of new synthesis tools, namely counter-example-guided inductive synthesis ({CEGIS}). We provide a description of the {CEGIS} architecture, followed by recent algorithmic improvements. We conjecture that the capacity of program synthesis engines will see further step change, in a manner that is transparent to the applications, which will open up an even broader range of use-cases.This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20150403},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{David Cristina} and {Kroening Daniel}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/N5ZN828M/David Cristina and Kroening Daniel - 2017 - Program synthesis challenges and opportunities.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/IULWXC2L/rsta.2015.html:text/html}
}

@article{white_neil_formal_2017,
	title = {Formal verification: will the seedling ever flower?},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0402},
	doi = {10.1098/rsta.2015.0402},
	shorttitle = {Formal verification},
	abstract = {In one sense, formal specification and verification have been highly successful: techniques have been developed in pioneering academic research, transferred to software companies through training and partnerships, and successfully deployed in systems with national significance. Altran {UK} has been in the vanguard of this movement. This paper summarizes some of our key deployments of formal techniques over the past 20 years, including both security- and safety-critical systems. The impact of formal techniques, however, remains within an industrial niche, and while government and suppliers across industry search for solutions to the problems of poor-quality software, the wider software industry remains resistant to adoption of this proven solution. We conclude by reflecting on some of the challenges we face as a community in ensuring that formal techniques achieve their true potential impact on society.This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20150402},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{White Neil} and {Matthews Stuart} and {Chapman Roderick}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/CPL6R6HS/White Neil et al. - 2017 - Formal verification will the seedling ever flower.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/SZBRJG4C/rsta.2015.html:text/html}
}

@article{hunt_warren_a._industrial_2017,
	title = {Industrial hardware and software verification with {ACL}2},
	volume = {375},
	url = {https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0399},
	doi = {10.1098/rsta.2015.0399},
	abstract = {The {ACL}2 theorem prover has seen sustained industrial use since the mid-1990s. Companies that have used {ACL}2 regularly include {AMD}, Centaur Technology, {IBM}, Intel, Kestrel Institute, Motorola/Freescale, Oracle and Rockwell Collins. This paper introduces {ACL}2 and focuses on how and why {ACL}2 is used in industry. {ACL}2 is well-suited to its industrial application to numerous software and hardware systems, because it is an integrated programming/proof environment supporting a subset of the {ANSI} standard Common Lisp programming language. As a programming language {ACL}2 permits the coding of efficient and robust programs; as a prover {ACL}2 can be fully automatic but provides many features permitting domain-specific human-supplied guidance at various levels of abstraction. {ACL}2 specifications and models often serve as efficient execution engines for the modelled artefacts while permitting formal analysis and proof of properties. Crucially, {ACL}2 also provides support for the development and verification of other formal analysis tools. However, {ACL}2 did not find its way into industrial use merely because of its technical features. The core {ACL}2 user/development community has a shared vision of making mechanized verification routine when appropriate and has been committed to this vision for the quarter century since the Computational Logic, Inc., Verified Stack. The community has focused on demonstrating the viability of the tool by taking on industrial projects (often at the expense of not being able to publish much).This article is part of the themed issue ‘Verified trustworthy software systems’.},
	pages = {20150399},
	number = {2104},
	journaltitle = {Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
	author = {{Hunt Warren A.} and {Kaufmann Matt} and {Moore J Strother} and {Slobodova Anna}},
	urldate = {2019-02-01},
	date = {2017-10-13},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/FB2ESHYL/Hunt Warren A. et al. - 2017 - Industrial hardware and software verification with.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/VVZ2CQLI/rsta.2015.html:text/html}
}

@inproceedings{ekici_smtcoq:_2017,
	title = {{SMTCoq}: A Plug-In for Integrating {SMT} Solvers into Coq},
	isbn = {978-3-319-63390-9},
	series = {Lecture Notes in Computer Science},
	shorttitle = {{SMTCoq}},
	abstract = {This paper describes {SMTCoq}, a plug-in for the integration of external solvers into the Coq proof assistant. Based on a checker for generic first-order proof certificates fully implemented and proved correct in Coq, {SMTCoq} offers facilities to check answers from external {SAT} and {SMT} solvers and to increase Coq’s automation using such solvers, all in a safe way. The current version supports proof certificates produced by the {SAT} solver {ZChaff}, for propositional logic, and the {SMT} solvers {veriT} and {CVC}4, for the quantifier-free fragment of the combined theory of fixed-size bit vectors, functional arrays with extensionality, linear integer arithmetic, and uninterpreted function symbols.},
	pages = {126--133},
	booktitle = {Computer Aided Verification},
	publisher = {Springer International Publishing},
	author = {Ekici, Burak and Mebsout, Alain and Tinelli, Cesare and Keller, Chantal and Katz, Guy and Reynolds, Andrew and Barrett, Clark},
	editor = {Majumdar, Rupak and Kunčak, Viktor},
	date = {2017},
	langid = {english},
	file = {Ekici et al. - 2017 - SMTCoq A Plug-In for Integrating SMT Solvers into.pdf:/Users/richardford/Zotero/storage/HR5VZETR/Ekici et al. - 2017 - SMTCoq A Plug-In for Integrating SMT Solvers into.pdf:application/pdf}
}

@online{anand_towards_nodate,
	title = {Towards Certified Meta-Programming with Typed Template-Coq {\textbar} {SpringerLink}},
	url = {https://link.springer.com/chapter/10.1007%2F978-3-319-94821-8_2},
	abstract = {Template-Coq (https://template-coq.github.io/template-coq) is a plugin for Coq, originally implemented by Malecha [18], which provides a reifier for Coq terms and global declarations, as represented in the Coq kernel, as well as a denotation command. Initially, it was developed for the purpose of writing functions on Coq’s {AST} in Gallina. Recently, it was used in the {CertiCoq} certified compiler project [4], as its front-end language, to derive parametricity properties [3], and to extract Coq terms to a {CBV}   𝜆 -calculus [13]. However, the syntax lacked semantics, be it typing semantics or operational semantics, which should reflect, as formal specifications in Coq, the semantics of Coq’s type theory itself. The tool was also rather bare bones, providing only rudimentary quoting and unquoting commands. We generalize it to handle the entire Calculus of Inductive Constructions ({CIC}), as implemented by Coq, including the kernel’s declaration structures for definitions and inductives, and implement a monad for general manipulation of Coq’s logical environment. We demonstrate how this setup allows Coq users to define many kinds of general purpose plugins, whose correctness can be readily proved in the system itself, and that can be run efficiently after extraction. We give a few examples of implemented plugins, including a parametricity translation. We also advocate the use of Template-Coq as a foundation for higher-level tools.},
	author = {Anand, Abhishek and Boulier, Simon and Cohen, Cyril and Sozeau, Matthieu and Tabareau, Nicolas},
	urldate = {2019-02-01},
	file = {Towards Certified Meta-Programming with Typed T em.pdf:/Users/richardford/Zotero/storage/2SRA4KVS/Towards Certified Meta-Programming with Typed T em.pdf:application/pdf;Towards Certified Meta-Programming with Typed T emplate-C oq | SpringerLink:/Users/richardford/Zotero/storage/8VTIEBSI/10.html:text/html}
}

@software{malecha_reflection_2018,
	title = {Reflection library for Coq. Contribute to gmalecha/template-coq development by creating an account on {GitHub}},
	rights = {{MIT}},
	url = {https://github.com/gmalecha/template-coq},
	author = {Malecha, Gregory},
	urldate = {2019-02-01},
	date = {2018-03-02},
	note = {original-date: 2014-07-09T20:13:52Z}
}

@software{sozeau_metacoq_2019,
	title = {{MetaCoq} - Metaprogramming in Coq (Was template-coq)},
	rights = {{MIT}},
	url = {https://github.com/MetaCoq/metacoq},
	publisher = {{MetaCoq}},
	author = {Sozeau, Matthieu},
	urldate = {2019-02-01},
	date = {2019-01-22},
	note = {original-date: 2017-10-19T11:10:54Z}
}

@book{parigot_logic_2000,
	location = {Berlin, Heidelberg},
	title = {Logic for Programming and Automated Reasoning: 7th International Conference, {LPAR} 2000 Reunion Island, France, November 6-10, 2000 Proceedings},
	isbn = {978-3-540-41285-4 978-3-540-44404-6},
	shorttitle = {Logic for Programming and Automated Reasoning},
	abstract = {This book constitutes the refereed proceedings of the 7th International Conference on Logic for Programming and Automated Reasoning, {LPAR} 2000, held in Reunion Island, France in November 2000. The 26 revised full papers presented together with four invited contributions were carefully reviewed and selected from 65 submissions. The papers are organized in topical sections on nonmonotonic reasoning, descriptive complexity, specification and automatic proof-assistants, theorem proving, verification, logic programming and constraint logic programming, nonclassical logics and the lambda calculus, logic and databases, program analysis, mu-calculus, planning and reasoning about actions.},
	publisher = {Springer Berlin Heidelberg},
	author = {Parigot, Michel and Voronkov, Andrei},
	date = {2000},
	note = {{OCLC}: 851805469}
}

@incollection{parigot_tactic_2000,
	location = {Berlin, Heidelberg},
	title = {A Tactic Language for the System Coq},
	volume = {1955},
	isbn = {978-3-540-41285-4},
	url = {http://link.springer.com/10.1007/3-540-44404-1_7},
	pages = {85--95},
	booktitle = {Logic for Programming and Automated Reasoning},
	publisher = {Springer Berlin Heidelberg},
	author = {Delahaye, David},
	editor = {Parigot, Michel and Voronkov, Andrei},
	urldate = {2019-02-01},
	date = {2000},
	langid = {english},
	doi = {10.1007/3-540-44404-1_7},
	file = {Submitted Version:/Users/richardford/Zotero/storage/7N982YMB/Delahaye - 2000 - A Tactic Language for the System Coq.pdf:application/pdf}
}

@book{bate_fundamentals_1971,
	location = {New York},
	title = {Fundamentals of astrodynamics},
	isbn = {978-0-486-60061-1},
	pagetotal = {455},
	publisher = {Dover Publications},
	author = {Bate, Roger R. and Mueller, Donald D. and White, Jerry E.},
	date = {1971},
	keywords = {Astrodynamics},
	file = {Bate et al. - 1971 - Fundamentals of astrodynamics.pdf:/Users/richardford/Zotero/storage/BPLR2VUG/Bate et al. - 1971 - Fundamentals of astrodynamics.pdf:application/pdf}
}

@online{fowler_deriving_nodate,
	title = {Deriving Kepler’s Laws from the Inverse-Square Law},
	url = {http://galileo.phys.virginia.edu/classes/152.mf1i.spring02/KeplersLaws.htm},
	author = {Fowler, Michael},
	urldate = {2019-02-01},
	file = {Deriving Kepler’s Laws from the Inverse-Square Law:/Users/richardford/Zotero/storage/AETWJHIJ/KeplersLaws.html:text/html}
}

@article{lancaster_unified_1969,
	title = {A unified form of lambert's theorem},
	volume = {{TN} D-5368},
	pages = {18},
	journaltitle = {{NASA} Technical Note},
	author = {Lancaster, E R and Blanchard, R C},
	date = {1969-09},
	langid = {english},
	file = {Lancaster and Blanchard - A unified form of lambert's theorem.pdf:/Users/richardford/Zotero/storage/SHT4J5E2/Lancaster and Blanchard - A unified form of lambert's theorem.pdf:application/pdf}
}

@article{protzenko_verified_2017,
	title = {Verified Low-level Programming Embedded in F*},
	volume = {1},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3110261},
	doi = {10.1145/3110261},
	abstract = {We present Low*, a language for low-level programming and verification, and its application to high-assurance optimized cryptographic libraries. Low* is a shallow embedding of a small, sequential, well-behaved subset of C in F*, a dependently- typed variant of {ML} aimed at program verification. Departing from {ML}, Low* does not involve any garbage collection or implicit heap allocation; instead, it has a structured memory model à la {CompCert}, and it provides the control required for writing efficient low-level security-critical code.   By virtue of typing, any Low* program is memory safe. In addition, the programmer can make full use of the verification power of F* to write high-level specifications and verify the functional correctness of Low* code using a combination of {SMT} automation and sophisticated manual proofs. At extraction time, specifications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove that this translation preserves semantics and side-channel resistance.   We provide a new compiler back-end from Low* to C and, to evaluate our approach, we implement and verify various cryptographic algorithms, constructions, and tools for a total of about 28,000 lines of code. We show that our Low* code delivers performance competitive with existing (unverified) C cryptographic libraries, suggesting our approach may be applicable to larger-scale low-level software.},
	pages = {17:1--17:29},
	issue = {{ICFP}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	author = {Protzenko, Jonathan and Zinzindohoué, Jean-Karim and Rastogi, Aseem and Ramananandro, Tahina and Wang, Peng and Zanella-Béguelin, Santiago and Delignat-Lavaud, Antoine and Hriţcu, Cătălin and Bhargavan, Karthikeyan and Fournet, Cédric and Swamy, Nikhil},
	urldate = {2019-02-01},
	date = {2017-08},
	keywords = {Compilers, Functional languages, Semantics, Software verifcation, Source code generation, Type theory, źSoftware and its engineering ź Correctness, źTheory of computation ź Hoare logic},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/BG9T92IN/Protzenko et al. - 2017 - Verified Low-level Programming Embedded in F.pdf:application/pdf}
}

@article{delignat-lavaud_implementing_2017,
	title = {Implementing and Proving the {TLS} 1.3 Record Layer},
	url = {https://www.microsoft.com/en-us/research/publication/implementing-proving-tls-1-3-record-layer/},
	abstract = {The record layer is the main bridge between {TLS} applications and internal sub-protocols. Its core functionality is an elaborate form of authenticated encryption: streams of messages for each sub-protocol (handshake, alert, and application data) are fragmented, multiplexed, and encrypted with optional padding to hide their lengths. Conversely, the sub-protocols may provide fresh keys or signal …},
	author = {Delignat-Lavaud, Antoine and Fournet, Cédric and Kohlweiss, Markulf and Protzenko, Jonathan and Rastogi, Aseem and Swamy, Nikhil and Zanella-Beguelin, Santiago and Bhargavan, Karthikeyan and Pan, Jianyang and Zinzindohoue, Jean Karim},
	urldate = {2019-02-01},
	date = {2017-08-17},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/DB23BSB5/Delignat-Lavaud et al. - 2017 - Implementing and Proving the TLS 1.3 Record Layer.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/HYVJCGU9/implementing-proving-tls-1-3-record-layer.html:text/html}
}

@online{cea_frama-c_nodate,
	title = {Frama-C},
	url = {https://frama-c.com/},
	author = {cea},
	urldate = {2019-02-01},
	file = {Frama-C:/Users/richardford/Zotero/storage/8D695LDW/frama-c.com.html:text/html}
}

@inproceedings{brahmi_formalise_2018,
	location = {Toulouse, France},
	title = {Formalise to automate: deployment of a safe and cost-efficient process for avionics software},
	url = {https://hal.archives-ouvertes.fr/hal-01708332},
	shorttitle = {Formalise to automate},
	abstract = {For over a decade, Airbus have been introducing formal techniques into the verification processes of some of their avionics software products, to cope with the steady increase of the size and complexity of related avionics systems. These techniques have come of age for large-scale industrial deployment. All design and verification processes are currently being revised to take maximum advantage from them, i.e. improve industrial efficiency while maintaining the safety and reliability of avionics systems. To achieve this goal, all human-engineered design artefacts are being formalised using languages with well-defined syntaxes and semantics, in order to allow for the automatic generation of all subsequent, computable design or verification artefacts, and the preparation of the input data for non computable activities. To this aim, several domain-specific languages and related compilers have been developed internally, which cover all design activities, and bridge the gaps to integrate external tools into the overall development processes, e.g. sound, semantics-based, static analysis tools. For instance, the formalisation of detailed designs in the form of function contracts expressed in a first-order logic-based language allows for a hybrid approach to unit verification. Designs may be compiled down to {ACSL} [5] contracts, allowing for program proof with Frama-C [22], or they may be compiled down to test contracts, allowing for semi-automatic unit tests.},
	booktitle = {9th European Congress on Embedded Real Time Software and Systems ({ERTS} 2018)},
	author = {Brahmi, Abderrahmane and Delmas, David and Essoussi, Mohamed Habib and Randimbivololona, Famantanantsoa and Atki, Abdellatif and Marie, Thomas},
	urldate = {2019-02-01},
	date = {2018-01},
	keywords = {avionics software, compilation, design, development process, {DO}-178C, domain-specific languages, formal methods, formalisation, industrial application, static analysis},
	file = {HAL PDF Full Text:/Users/richardford/Zotero/storage/3NK7R5HC/Brahmi et al. - 2018 - Formalise to automate deployment of a safe and co.pdf:application/pdf}
}

@article{brahmi_formalise_nodate,
	title = {Formalise to automate: deployment of a safe and cost-efﬁcient process for avionics software -Extended},
	abstract = {For over a decade, Airbus have been introducing formal techniques into the veriﬁcation processes of some of their avionics software products, to cope with the steady increase of the size and complexity of related avionics systems. These techniques have come of age for large-scale industrial deployment. All design and veriﬁcation processes are currently being revised to take maximum advantage from them, i.e. improve industrial efﬁciency while maintaining the safety and reliability of avionics systems.},
	pages = {17},
	author = {Brahmi, Abderrahmane and Delmas, David and Essoussi, Mohamed Habib and Randimbivololona, Famantanantsoa and Informatics, {CEPRESY} and Nauzere, La and Atki, Abdellatif and Marie, Thomas},
	langid = {english},
	file = {Brahmi et al. - Formalise to automate deployment of a safe and co.pdf:/Users/richardford/Zotero/storage/TDP2UBY6/Brahmi et al. - Formalise to automate deployment of a safe and co.pdf:application/pdf}
}

@online{jeannet_apron_nodate,
	title = {{APRON} numerical abstract domain library},
	url = {http://apron.cri.ensmp.fr/library/},
	author = {Jeannet, Bertrand and Miné, Antoine},
	urldate = {2019-02-01},
	file = {APRON numerical abstract domain library:/Users/richardford/Zotero/storage/KPYS6U8G/library.html:text/html;APRON numerical abstract domain library.pdf:/Users/richardford/Zotero/storage/EN24RJTG/APRON numerical abstract domain library.pdf:application/pdf}
}

@article{blanchard_concurrent_2017,
	title = {From Concurrent Programs to Simulating Sequential Programs: Correctness of a Transformation},
	volume = {253},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1708.07226},
	doi = {10.4204/EPTCS.253.9},
	shorttitle = {From Concurrent Programs to Simulating Sequential Programs},
	abstract = {Frama-C is a software analysis framework that provides a common infrastructure and a common behavioral specification language to plugins that implement various static and dynamic analyses of C programs. Most plugins do not support concurrency. We have proposed Conc2Seq, a Frama-C plugin based on program transformation, capable to leverage the existing huge code base of plugins and to handle concurrent C programs. In this paper we formalize and sketch the proof of correctness of the program transformation principle behind Conc2Seq, and present an effort towards the full mechanization of both the formalization and proofs with the proof assistant Coq.},
	pages = {109--123},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	author = {Blanchard, Allan and Loulergue, Frédéric and Kosmatov, Nikolai},
	urldate = {2019-02-01},
	date = {2017-08-23},
	eprinttype = {arxiv},
	eprint = {1708.07226},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv\:1708.07226 PDF:/Users/richardford/Zotero/storage/DKA444GJ/Blanchard et al. - 2017 - From Concurrent Programs to Simulating Sequential .pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/E2K4HQ84/1708.html:text/html}
}

@article{petiot_how_2018,
	title = {How testing helps to diagnose proof failures},
	volume = {30},
	issn = {1433-299X},
	url = {https://doi.org/10.1007/s00165-018-0456-4},
	doi = {10.1007/s00165-018-0456-4},
	abstract = {Applying deductive verification to formally prove that a program respects its formal specification is a very complex and time-consuming task due in particular to the lack of feedback in case of proof failures. Along with a non-compliance between the code and its specification (due to an error in at least one of them), possible reasons of a proof failure include a missing or too weak specification for a called function or a loop, and lack of time or simply incapacity of the prover to finish a particular proof. This work proposes a methodology where test generation helps to identify the reason of a proof failure and to exhibit a counterexample clearly illustrating the issue. We define the categories of proof failures, introduce two subcategories of contract weaknesses (single and global ones), and examine their properties. We describe how to transform a C program formally specified in an executable specification language into C code suitable for testing, and illustrate the benefits of the method on comprehensive examples. The method has been implemented in {StaDy}, a plugin of the software analysis platform Frama-C. Initial experiments show that detecting non-compliances and contract weaknesses allows to precisely diagnose most proof failures.},
	pages = {629--657},
	number = {6},
	journaltitle = {Form Asp Comp},
	author = {Petiot, Guillaume and Kosmatov, Nikolai and Botella, Bernard and Giorgetti, Alain and Julliand, Jacques},
	urldate = {2019-02-01},
	date = {2018-11-01},
	langid = {english},
	keywords = {Deductive verification, Frama-C, Proof debugging, Specification, Test generation},
	file = {Submitted Version:/Users/richardford/Zotero/storage/7PS4JCYI/Petiot et al. - 2018 - How testing helps to diagnose proof failures.pdf:application/pdf}
}

@article{petiot_your_2015,
	title = {Your Proof Fails? Testing Helps to Find the Reason},
	url = {http://arxiv.org/abs/1508.01691},
	shorttitle = {Your Proof Fails?},
	abstract = {Applying deductive verification to formally prove that a program respects its formal specification is a very complex and time-consuming task due in particular to the lack of feedback in case of proof failures. Along with a non-compliance between the code and its specification (due to an error in at least one of them), possible reasons of a proof failure include a missing or too weak specification for a called function or a loop, and lack of time or simply incapacity of the prover to finish a particular proof. This work proposes a new methodology where test generation helps to identify the reason of a proof failure and to exhibit a counter-example clearly illustrating the issue. We describe how to transform an annotated C program into C code suitable for testing and illustrate the benefits of the method on comprehensive examples. The method has been implemented in {STADY}, a plugin of the software analysis platform {FRAMA}-C. Initial experiments show that detecting non-compliances and contract weaknesses allows to precisely diagnose most proof failures.},
	journaltitle = {{arXiv}:1508.01691 [cs]},
	author = {Petiot, Guillaume and Kosmatov, Nikolai and Botella, Bernard and Giorgetti, Alain and Julliand, Jacques},
	urldate = {2019-02-01},
	date = {2015-08-07},
	eprinttype = {arxiv},
	eprint = {1508.01691},
	keywords = {Computer Science - Software Engineering, D.2.4, D.2.5},
	file = {arXiv\:1508.01691 PDF:/Users/richardford/Zotero/storage/HKJL6G88/Petiot et al. - 2015 - Your Proof Fails Testing Helps to Find the Reason.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/QZ7UD9YV/1508.html:text/html}
}

@inproceedings{blatter_static_2018,
	title = {Static and Dynamic Verification of Relational Properties on Self-composed C Code},
	isbn = {978-3-319-92994-1},
	series = {Lecture Notes in Computer Science},
	abstract = {Function contracts are a well-established way of formally specifying the intended behavior of a function. However, they usually only describe what should happen during a single call. Relational properties, on the other hand, link several function calls. They include such properties as non-interference, continuity and monotonicity. Other examples relate sequences of function calls, for instance, to show that decrypting an encrypted message with the appropriate key gives back the original message. Such properties cannot be expressed directly in the traditional setting of modular deductive verification, but are amenable to verification through self-composition. This paper presents a verification technique dedicated to relational properties in C programs and its implementation in the form of a Frama-C plugin called {RPP} and based on self-composition. It supports functions with side effects and recursive functions. The proposed approach makes it possible to prove a relational property, to check it at runtime, to generate a counterexample using testing and to use it as a hypothesis in the subsequent verification. Our initial experiments on existing benchmarks confirm that the proposed technique is helpful for static and dynamic analysis of relational properties.},
	pages = {44--62},
	booktitle = {Tests and Proofs},
	publisher = {Springer International Publishing},
	author = {Blatter, Lionel and Kosmatov, Nikolai and Le Gall, Pascale and Prevosto, Virgile and Petiot, Guillaume},
	editor = {Dubois, Catherine and Wolff, Burkhart},
	date = {2018},
	langid = {english},
	keywords = {Deductive verification, Dynamic verification, Frama-C, Relational properties, Self-composition, Specification},
	file = {Blatter et al. - 2018 - Static and Dynamic Verification of Relational Prop.pdf:/Users/richardford/Zotero/storage/4HABAVL9/Blatter et al. - 2018 - Static and Dynamic Verification of Relational Prop.pdf:application/pdf}
}

@online{melquiond_why3_nodate,
	title = {Why3},
	url = {http://why3.lri.fr/},
	author = {Melquiond, Guillaume},
	urldate = {2019-02-01},
	file = {Why3:/Users/richardford/Zotero/storage/RE6KJZXJ/why3.lri.fr.html:text/html}
}

@article{dijkstra_guarded_1975,
	title = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
	volume = {18},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/360933.360975},
	doi = {10.1145/360933.360975},
	abstract = {So-called “guarded commands” are introduced as a building block for alternative and repetitive constructs that allow nondeterministic program components for which at least the activity evoked, but possibly even the final state, is not necessarily uniquely determined by the initial state. For the formal derivation of programs expressed in terms of these constructs, a calculus will be be shown.},
	pages = {453--457},
	number = {8},
	journaltitle = {Commun. {ACM}},
	author = {Dijkstra, Edsger W.},
	urldate = {2019-02-01},
	date = {1975-08},
	keywords = {case-construction, correctness proof, derivation of programs, nondeterminancy, program semantics, programming language semantics, programming languages, programming methodology, repetition, sequencing primitives, termination},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/4XF5W5ZR/Dijkstra - 1975 - Guarded Commands, Nondeterminacy and Formal Deriva.pdf:application/pdf}
}

@article{swamy_verifying_2013,
	title = {Verifying Higher-order Programs with the Dijkstra Monad},
	url = {https://www.microsoft.com/en-us/research/publication/verifying-higher-order-programs-with-the-dijkstra-monad/},
	abstract = {Modern programming languages, ranging from Haskell and {ML}, to {JavaScript}, C\# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of benefits. First, the monad …},
	author = {Swamy, Nikhil and Chen, Juan and Livshits, Ben},
	urldate = {2019-02-01},
	date = {2013-06-01},
	langid = {american},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/DTN54LGK/Swamy et al. - 2013 - Verifying Higher-order Programs with the Dijkstra .pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/NVGHR97J/verifying-higher-order-programs-with-the-dijkstra-monad.html:text/html}
}

@inproceedings{swamy_dependent_2016,
	location = {New York, {NY}, {USA}},
	title = {Dependent Types and Multi-monadic Effects in F*},
	isbn = {978-1-4503-3549-2},
	url = {http://doi.acm.org/10.1145/2837614.2837655},
	doi = {10.1145/2837614.2837655},
	series = {{POPL} '16},
	abstract = {We present a new, completely redesigned, version of F*, a language that works both as a proof assistant as well as a general-purpose, verification-oriented, effectful programming language. In support of these complementary roles, F* is a dependently typed, higher-order, call-by-value language with \_primitive\_ effects including state, exceptions, divergence and {IO}. Although primitive, programmers choose the granularity at which to specify effects by equipping each effect with a monadic, predicate transformer semantics. F* uses this to efficiently compute weakest preconditions and discharges the resulting proof obligations using a combination of {SMT} solving and manual proofs. Isolated from the effects, the core of F* is a language of pure functions used to write specifications and proof terms---its consistency is maintained by a semantic termination check based on a well-founded order. We evaluate our design on more than 55,000 lines of F* we have authored in the last year, focusing on three main case studies. Showcasing its use as a general-purpose programming language, F* is programmed (but not verified) in F*, and bootstraps in both {OCaml} and F\#. Our experience confirms F*'s pay-as-you-go cost model: writing idiomatic {ML}-like code with no finer specifications imposes no user burden. As a verification-oriented language, our most significant evaluation of F* is in verifying several key modules in an implementation of the {TLS}-1.2 protocol standard. For the modules we considered, we are able to prove more properties, with fewer annotations using F* than in a prior verified implementation of {TLS}-1.2. Finally, as a proof assistant, we discuss our use of F* in mechanizing the metatheory of a range of lambda calculi, starting from the simply typed lambda calculus to System F-omega and even micro-F*, a sizeable fragment of F* itself---these proofs make essential use of F*'s flexible combination of {SMT} automation and constructive proofs, enabling a tactic-free style of programming and proving at a relatively large scale.},
	pages = {256--270},
	booktitle = {Proceedings of the 43rd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Swamy, Nikhil and Hriţcu, Cătălin and Keller, Chantal and Rastogi, Aseem and Delignat-Lavaud, Antoine and Forest, Simon and Bhargavan, Karthikeyan and Fournet, Cédric and Strub, Pierre-Yves and Kohlweiss, Markulf and Zinzindohoue, Jean-Karim and Zanella-Béguelin, Santiago},
	urldate = {2019-02-01},
	date = {2016},
	keywords = {effectful programming, proof assistants, verification},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/X6CZXAKM/Swamy et al. - 2016 - Dependent Types and Multi-monadic Effects in F.pdf:application/pdf}
}

@inproceedings{ahman_dijkstra_2017,
	location = {New York, {NY}, {USA}},
	title = {Dijkstra Monads for Free},
	isbn = {978-1-4503-4660-3},
	url = {http://doi.acm.org/10.1145/3009837.3009878},
	doi = {10.1145/3009837.3009878},
	series = {{POPL} 2017},
	abstract = {Dijkstra monads enable a dependent type theory to be enhanced with support for specifying and verifying effectful code via weakest preconditions. Together with their closely related counterparts, Hoare monads, they provide the basis on which verification tools like F*, Hoare Type Theory ({HTT}), and Ynot are built. We show that Dijkstra monads can be derived "for free" by applying a continuation-passing style ({CPS}) translation to the standard monadic definitions of the underlying computational effects. Automatically deriving Dijkstra monads in this way provides a correct-by-construction and efficient way of reasoning about user-defined effects in dependent type theories. We demonstrate these ideas in {EMF}*, a new dependently typed calculus, validating it via both formal proof and a prototype implementation within F*. Besides equipping F* with a more uniform and extensible effect system, {EMF}* enables a novel mixture of intrinsic and extrinsic proofs within F*.},
	pages = {515--529},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Ahman, Danel and Hriţcu, Cătălin and Maillard, Kenji and Martínez, Guido and Plotkin, Gordon and Protzenko, Jonathan and Rastogi, Aseem and Swamy, Nikhil},
	urldate = {2019-02-01},
	date = {2017},
	keywords = {dependent types, effectful programming, proof assistants, verification},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/79A2MM4V/Ahman et al. - 2017 - Dijkstra Monads for Free.pdf:application/pdf}
}

@article{hritcu_quest_nodate,
	title = {The Quest for Formally Secure Compartmentalizing Compilation},
	abstract = {Severe low-level vulnerabilities abound in today’s computer systems, allowing cyber-attackers to remotely gain full control. This happens in big part because our programming languages, compilation chains, and architectures too often trade o security for e ciency. The semantics of mainstream low-level languages like C is inherently insecure, and even for safer languages, all guarantees are lost when interacting with low-level code, for instance when using low-level libraries. This habilitation presents my ongoing quest to build formally secure compartmentalizing compilation chains that defend against such attacks. In particular, we propose several formal de nitions that characterize what it means for a compartmentalizing compilation chain to be secure, both in the case of safe and of unsafe source languages.},
	pages = {96},
	author = {Hriţcu, Cătălin},
	langid = {english},
	file = {Hriţcu - The Quest for Formally Secure Compartmentalizing Com.pdf:/Users/richardford/Zotero/storage/GGGX8C7Q/Hriţcu - The est for Formally Secure Compartmentalizing Com.pdf:application/pdf}
}

@article{ahman_recalling_2017,
	title = {Recalling a Witness: Foundations and Applications of Monotonic State},
	volume = {2},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3158153},
	doi = {10.1145/3158153},
	shorttitle = {Recalling a Witness},
	abstract = {We provide a way to ease the verification of programs whose state evolves monotonically. The main idea is that a property witnessed in a prior state can be soundly recalled in the current state, provided (1) state evolves according to a given preorder, and (2) the property is preserved by this preorder. In many scenarios, such monotonic reasoning yields concise modular proofs, saving the need for explicit program invariants. We distill our approach into the monotonic-state monad, a general yet compact interface for Hoare-style reasoning about monotonic state in a dependently typed language. We prove the soundness of the monotonic-state monad and use it as a unified foundation for reasoning about monotonic state in the F⋆ verification system. Based on this foundation, we build libraries for various mutable data structures like monotonic references and apply these libraries at scale to the verification of several distributed applications.},
	pages = {65:1--65:30},
	issue = {{POPL}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	author = {Ahman, Danel and Fournet, Cédric and Hriţcu, Cătălin and Maillard, Kenji and Rastogi, Aseem and Swamy, Nikhil},
	urldate = {2019-02-01},
	date = {2017-12},
	keywords = {Formal Foundations, Hoare Logic, Modular Reasoning, Monotonic References, Monotonic-State Monad, Program Verification, Secure File Transfer, State Continuity},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/T2Z4NUBR/Ahman et al. - 2017 - Recalling a Witness Foundations and Applications .pdf:application/pdf}
}

@software{syme_fsharp_2019,
	title = {Fsharp design: {RFCs} and docs related to the F\# language design process,},
	url = {https://github.com/fsharp/fslang-design},
	shorttitle = {{RFCs} and docs related to the F\# language design process, see https},
	publisher = {F\# Software Foundation Repositories},
	author = {Syme, Don},
	urldate = {2019-02-01},
	date = {2019-01-29},
	note = {original-date: 2014-06-25T13:07:35Z}
}

@software{syme_fsharp_2019-1,
	title = {The Fsharp Compiler, Core Library \& Tools (F\# Software Foundation Repository): fsharp/fsharp},
	rights = {{MIT}},
	url = {https://github.com/fsharp/fsharp},
	shorttitle = {The F\# Compiler, Core Library \& Tools (F\# Software Foundation Repository)},
	publisher = {F\# Software Foundation Repositories},
	author = {Syme, Don},
	urldate = {2019-02-01},
	date = {2019-01-30},
	note = {original-date: 2010-12-13T00:19:52Z}
}

@article{martinez_meta-f*:_2018,
	title = {Meta-F*: Proof Automation with {SMT}, Tactics, and Metaprograms},
	url = {http://arxiv.org/abs/1803.06547},
	shorttitle = {Meta-F*},
	abstract = {We introduce Meta-F*, a tactics and metaprogramming framework for the F* program verifier. The main novelty of Meta-F* is allowing to use tactics and metaprogramming to discharge assertions not solvable by {SMT}, or to just simplify them into well-behaved {SMT} fragments. Plus, Meta-F* can be used to generate verified code automatically. Meta-F* is implemented as an F* effect, which, given the powerful effect system of F*, heavily increases code reuse and even enables the lightweight verification of metaprograms. Metaprograms can be either interpreted, or compiled to efficient native code that can be dynamically loaded into the F* type-checker and can interoperate with interpreted code. Evaluation on realistic case studies shows that Meta-F* provides substantial gains in proof development, efficiency, and robustness.},
	journaltitle = {{arXiv}:1803.06547 [cs]},
	author = {Martínez, Guido and Ahman, Danel and Dumitrescu, Victor and Giannarakis, Nick and Hawblitzel, Chris and Hritcu, Catalin and Narasimhamurthy, Monal and Paraskevopoulou, Zoe and Pit-Claudel, Clément and Protzenko, Jonathan and Ramananandro, Tahina and Rastogi, Aseem and Swamy, Nikhil},
	urldate = {2019-02-01},
	date = {2018-03-17},
	eprinttype = {arxiv},
	eprint = {1803.06547},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
	file = {arXiv\:1803.06547 PDF:/Users/richardford/Zotero/storage/D6VDW32P/Martínez et al. - 2018 - Meta-F Proof Automation with SMT, Tactics, and M.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/4UGPV8V2/1803.html:text/html}
}

@inproceedings{filinski_representing_1994,
	location = {New York, {NY}, {USA}},
	title = {Representing Monads},
	isbn = {978-0-89791-636-3},
	url = {http://doi.acm.org/10.1145/174675.178047},
	doi = {10.1145/174675.178047},
	series = {{POPL} '94},
	abstract = {We show that any monad whose unit and extension operations are expressible as purely functional terms can be embedded in a call-by-value language with “composable continuations”. As part of the development, we extend Meyer and Wand's characterization of the relationship between continuation-passing and direct style to one for continuation-passing vs. general “monadic” style. We further show that the composable-continuations construct can itself be represented using ordinary, non-composable first-class continuations and a single piece of state. Thus, in the presence of two specific computational effects - storage and escapes - any expressible monadic structure (e.g., nondeterminism as represented by the list monad) can be added as a purely definitional extension, without requiring a reinterpretation of the whole language. The paper includes an implementation of the construction (in Standard {ML} with some New Jersey extensions) and several examples.},
	pages = {446--457},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Filinski, Andrzej},
	urldate = {2019-02-01},
	date = {1994},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/474UWRAK/Filinski - 1994 - Representing Monads.pdf:application/pdf}
}

@inproceedings{filinski_representing_1999,
	location = {New York, {NY}, {USA}},
	title = {Representing Layered Monads},
	isbn = {978-1-58113-095-9},
	url = {http://doi.acm.org/10.1145/292540.292557},
	doi = {10.1145/292540.292557},
	series = {{POPL} '99},
	abstract = {There has already been considerable research on constructing modular, monad-based specifications of computational effects (state, exceptions, nondeterminism, etc.) in programming languages. We present a simple framework in this tradition, based on a Church-style effect-typing system for an {ML}-like language. The semantics of this language is formally defined by a series of monadic translations, each one expanding away a layer of effects. Such a layered specification is easy to reason about, but its direct implementation (whether by parameterized interpretation or by actual translation) is often prohibitively inefficient.By exploiting deeper semantic properties of monads, however, it is also possible to derive a vastly more efficient implementation: we show that each layer of effects can be uniformly simulated by continuation-passing, and further that multiple such layers can themselves be simulated by a standard semantics for call/cc and mutable state. Thus, even multi-effect programs can be executed in Scheme or {SML}/{NJ} at full native speed, generalizing an earlier single-effect result. As an example, we show how a simple resumption-based semantics of concurrency allows us to directly simulate a shared-state program across all possible dynamic interleavings of execution threads.},
	pages = {175--188},
	booktitle = {Proceedings of the 26th {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Filinski, Andrzej},
	urldate = {2019-02-01},
	date = {1999},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/973MQ2DE/Filinski - 1999 - Representing Layered Monads.pdf:application/pdf}
}

@article{gonthier_introduction_2010,
	title = {An introduction to small scale reflection in Coq},
	volume = {3},
	rights = {Copyright (c) 2010 Georges Gonthier, Assia Mahboubi},
	issn = {1972-5787},
	url = {https://jfr.unibo.it/article/view/1979},
	doi = {10.6092/issn.1972-5787/1979},
	abstract = {This tutorial presents the {SSReflect} extension to the Coq system. This extension consists of an extension to the Coq language of script, and of a set of libraries, originating from the formal proof of the Four Color theorem. This tutorial proposes a guided tour in some of the basic libraries distributed in the {SSReflect} package. It focuses on the application of the small scale reflection methodology to the formalization of finite objects in intuitionistic type theory.},
	pages = {95--152},
	number = {2},
	journaltitle = {Journal of Formalized Reasoning},
	author = {Gonthier, Georges and Mahboubi, Assia},
	urldate = {2019-02-01},
	date = {2010},
	langid = {english},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/GAA6PEIJ/Gonthier and Mahboubi - 2010 - An introduction to small scale reflection in Coq.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/ZX32HUEX/1979.html:text/html}
}

@inproceedings{gonthier_how_2011,
	location = {New York, {NY}, {USA}},
	title = {How to Make Ad Hoc Proof Automation Less Ad Hoc},
	isbn = {978-1-4503-0865-6},
	url = {http://doi.acm.org/10.1145/2034773.2034798},
	doi = {10.1145/2034773.2034798},
	series = {{ICFP} '11},
	abstract = {Most interactive theorem provers provide support for some form of user-customizable proof automation. In a number of popular systems, such as Coq and Isabelle, this automation is achieved primarily through tactics, which are programmed in a separate language from that of the prover's base logic. While tactics are clearly useful in practice, they can be difficult to maintain and compose because, unlike lemmas, their behavior cannot be specified within the expressive type system of the prover itself. We propose a novel approach to proof automation in Coq that allows the user to specify the behavior of custom automated routines in terms of Coq's own type system. Our approach involves a sophisticated application of Coq's canonical structures, which generalize Haskell type classes and facilitate a flexible style of dependently-typed logic programming. Specifically, just as Haskell type classes are used to infer the canonical implementation of an overloaded term at a given type, canonical structures can be used to infer the canonical proof of an overloaded lemma for a given instantiation of its parameters. We present a series of design patterns for canonical structure programming that enable one to carefully and predictably coax Coq's type inference engine into triggering the execution of user-supplied algorithms during unification, and we illustrate these patterns through several realistic examples drawn from Hoare Type Theory. We assume no prior knowledge of Coq and describe the relevant aspects of Coq type inference from first principles.},
	pages = {163--175},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {Gonthier, Georges and Ziliani, Beta and Nanevski, Aleksandar and Dreyer, Derek},
	urldate = {2019-02-01},
	date = {2011},
	keywords = {canonical structures, coq, custom proof automation, hoare type theory, interactive theorem proving, tactics, type classes},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/2TR7VDJX/Gonthier et al. - 2011 - How to Make Ad Hoc Proof Automation Less Ad Hoc.pdf:application/pdf}
}

@inproceedings{mokhov_algebraic_2017,
	location = {New York, {NY}, {USA}},
	title = {Algebraic Graphs with Class (Functional Pearl)},
	isbn = {978-1-4503-5182-9},
	url = {http://doi.acm.org/10.1145/3122955.3122956},
	doi = {10.1145/3122955.3122956},
	series = {Haskell 2017},
	abstract = {The paper presents a minimalistic and elegant approach to working with graphs in Haskell. It is built on a rigorous mathematical foundation --- an algebra of graphs --- that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms. Algebraic graphs let us avoid partial functions typically caused by `malformed graphs' that contain an edge referring to a non-existent vertex. This helps to liberate {APIs} of existing graph libraries from partial functions.   The algebra of graphs can represent directed, undirected, reflexive and transitive graphs, as well as hypergraphs, by appropriately choosing the set of underlying axioms. The flexibility of the approach is demonstrated by developing a library for constructing and transforming polymorphic graphs.},
	pages = {2--13},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} International Symposium on Haskell},
	publisher = {{ACM}},
	author = {Mokhov, Andrey},
	urldate = {2019-02-01},
	date = {2017},
	keywords = {algebra, graph theory, Haskell},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/5HHBHF8J/Mokhov - 2017 - Algebraic Graphs with Class (Functional Pearl).pdf:application/pdf}
}

@article{ramsey_applicative_2006,
	title = {An Applicative Control-Flow Graph Based on Huet's Zipper},
	volume = {148},
	issn = {1571-0661},
	url = {http://www.sciencedirect.com/science/article/pii/S1571066106001289},
	doi = {10.1016/j.entcs.2005.11.042},
	series = {Proceedings of the {ACM}-{SIGPLAN} Workshop on {ML} ({ML} 2005)},
	abstract = {We are using {ML} to build a compiler that does low-level optimization. To support optimizations in classic imperative style, we built a control-flow graph using mutable pointers and other mutable state in the nodes. This decision proved unfortunate: the mutable flow graph was big and complex, and it led to many bugs. We have replaced it by a smaller, simpler, applicative flow graph based on Huet's [Huet, Gérard, 1997. The Zipper. Journal of Functional Programming, 7(5):549–554. Functional Pearl] zipper. The new flow graph is a success; this paper presents its design and shows how it leads to a gratifyingly simple implementation of the dataflow framework developed by [Lerner, Sorin, David Grove, and Craig Chambers. 2002. Composing dataflow analyses and transformations. Conference Record of the 29th Annual {ACM} Symposium on Principles of Programming Languages, in {SIGPLAN} Notices, 31(1):270–282].},
	pages = {105--126},
	number = {2},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	author = {Ramsey, Norman and Dias, João},
	urldate = {2019-02-01},
	date = {2006-03-24},
	keywords = {applicative data structures, compilers, control-flow graphs, dataflow analysis, optimization},
	file = {ScienceDirect Full Text PDF:/Users/richardford/Zotero/storage/A52SVHPL/Ramsey and Dias - 2006 - An Applicative Control-Flow Graph Based on Huet's .pdf:application/pdf;ScienceDirect Snapshot:/Users/richardford/Zotero/storage/PT5VGVPI/S1571066106001289.html:text/html}
}

@article{harper_framework_1993,
	title = {A Framework for Defining Logics},
	volume = {40},
	issn = {0004-5411},
	url = {http://doi.acm.org/10.1145/138027.138060},
	doi = {10.1145/138027.138060},
	abstract = {The Edinburgh Logical Framework ({LF}) provides a means to define (or present) logics. It is based on a general treatment of syntax, rules, and proofs by means of a typed \&lgr;-calculus with dependent types. Syntax is treated in a style similar to, but more general than, Martin-Lo¨f's system of arities. The treatment of rules and proofs focuses on his notion of a judgment. Logics are represented in {LF} via a new principle, the judgments as types principle, whereby each judgment is identified with the type of its proofs. This allows for a smooth treatment of discharge and variable occurence conditions and leads to a uniform treatment of rules and proofs whereby rules are viewed as proofs of higher-order judgments and proof checking is reduced to type checking. The practical benefit of our treatment of formal systems is that logic-independent tools, such as proof editors and proof checkers, can be constructed.},
	pages = {143--184},
	number = {1},
	journaltitle = {J. {ACM}},
	author = {Harper, Robert and Honsell, Furio and Plotkin, Gordon},
	urldate = {2019-02-01},
	date = {1993-01},
	keywords = {formal systems, interactive theorem proving, proof checking, typed lambda calculus},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/VEYR93NU/Harper et al. - 1993 - A Framework for Defining Logics.pdf:application/pdf}
}

@article{harrison_hol_2013,
	title = {The {HOL} Light Theory of Euclidean Space},
	volume = {50},
	issn = {0168-7433, 1573-0670},
	url = {http://link.springer.com/10.1007/s10817-012-9250-9},
	doi = {10.1007/s10817-012-9250-9},
	pages = {173--190},
	number = {2},
	journaltitle = {Journal of Automated Reasoning},
	author = {Harrison, John},
	urldate = {2019-02-01},
	date = {2013-02},
	langid = {english},
	file = {Harrison - 2013 - The HOL Light Theory of Euclidean Space.pdf:/Users/richardford/Zotero/storage/65KRY862/Harrison - 2013 - The HOL Light Theory of Euclidean Space.pdf:application/pdf}
}

@inproceedings{spector-zabusky_total_2018,
	location = {New York, {NY}, {USA}},
	title = {Total Haskell is Reasonable Coq},
	isbn = {978-1-4503-5586-5},
	url = {http://doi.acm.org/10.1145/3167092},
	doi = {10.1145/3167092},
	series = {{CPP} 2018},
	abstract = {We would like to use the Coq proof assistant to mechanically verify properties of Haskell programs. To that end, we present a tool, named {\textless}tt{\textgreater}hs-to-coq{\textless}/tt{\textgreater}, that translates total Haskell programs into Coq programs via a shallow embedding. We apply our tool in three case studies – a lawful {\textless}tt{\textgreater}Monad{\textless}/tt{\textgreater} instance, “Hutton’s razor”, and an existing data structure library – and prove their correctness. These examples show that this approach is viable: both that {\textless}tt{\textgreater}hs-to-coq{\textless}/tt{\textgreater} applies to existing Haskell code, and that the output it produces is amenable to verification.},
	pages = {14--27},
	booktitle = {Proceedings of the 7th {ACM} {SIGPLAN} International Conference on Certified Programs and Proofs},
	publisher = {{ACM}},
	author = {Spector-Zabusky, Antal and Breitner, Joachim and Rizkallah, Christine and Weirich, Stephanie},
	urldate = {2019-02-01},
	date = {2018},
	keywords = {Coq, Haskell, verification},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/WVT2FG9M/Spector-Zabusky et al. - 2018 - Total Haskell is Reasonable Coq.pdf:application/pdf}
}

@incollection{hutchison_fresh_2009,
	location = {Berlin, Heidelberg},
	title = {A Fresh Look at Separation Algebras and Share Accounting},
	volume = {5904},
	isbn = {978-3-642-10671-2 978-3-642-10672-9},
	url = {http://link.springer.com/10.1007/978-3-642-10672-9_13},
	abstract = {Separation Algebras serve as models of Separation Logics; Share Accounting allows reasoning about concurrent-read/exclusive-write resources in Separation Logic. In designing a Concurrent Separation Logic and in mechanizing proofs of its soundness, we found previous axiomatizations of separation algebras and previous systems of share accounting to be useful but ﬂawed. We adjust the axioms of separation algebras; we demonstrate an operator calculus for constructing new separation algebras; we present a more powerful system of share accounting with a new, simple model; and we provide a reusable Coq development.},
	pages = {161--177},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Dockins, Robert and Hobor, Aquinas and Appel, Andrew W.},
	editor = {Hu, Zhenjiang},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2019-02-01},
	date = {2009},
	langid = {english},
	doi = {10.1007/978-3-642-10672-9_13},
	file = {Dockins et al. - 2009 - A Fresh Look at Separation Algebras and Share Acco.pdf:/Users/richardford/Zotero/storage/47RRWA4Y/Dockins et al. - 2009 - A Fresh Look at Separation Algebras and Share Acco.pdf:application/pdf}
}

@online{swamy_project_nodate,
	title = {Project Everest - Verified Secure Implementations of the {HTTPS} Ecosystem},
	url = {https://www.microsoft.com/en-us/research/project/project-everest-verified-secure-implementations-https-ecosystem/},
	abstract = {This project proposes to deﬁnitively solve the problem of a brittle {HTTPS} ecosystem by constructing a more secure, high performance, standards-compliant, veriﬁed implementation of the full {HTTPS} ecosystem. Unlike other veriﬁed software projects, our expedition aims to deploy Everest within existing software as a drop-in replacement in mainstream web browsers, servers, and other popular tools.},
	titleaddon = {Microsoft Research},
	author = {Swamy, Nikhil},
	urldate = {2019-02-01},
	langid = {american},
	file = {Snapshot:/Users/richardford/Zotero/storage/SDMUE4PX/project-everest-verified-secure-implementations-https-ecosystem.html:text/html;Snapshot:/Users/richardford/Zotero/storage/PZSK85HV/project-everest-verified-secure-implementations-https-ecosystem.html:text/html}
}

@article{fournet_deploying_nodate,
	title = {Deploying a Veriﬁed Secure Implementation of the {HTTPS} Ecosystem},
	pages = {10},
	author = {Fournet, Cedric and Hawblitzel, Chris and Parno, Bryan and Swamy, Nikhil},
	langid = {english},
	file = {Fournet et al. - Deploying a Veriﬁed Secure Implementation of the H.pdf:/Users/richardford/Zotero/storage/4TJJYC6N/Fournet et al. - Deploying a Veriﬁed Secure Implementation of the H.pdf:application/pdf}
}

@article{hawblitzel_ironclad_nodate,
	title = {Ironclad Apps: End-to-End Security via Automated Full-System Veriﬁcation},
	abstract = {An Ironclad App lets a user securely transmit her data to a remote machine with the guarantee that every instruction executed on that machine adheres to a formal abstract speciﬁcation of the app’s behavior. This does more than eliminate implementation vulnerabilities such as buffer overﬂows, parsing errors, or data leaks; it tells the user exactly how the app will behave at all times. We provide these guarantees via complete, low-level software veriﬁcation. We then use cryptography and secure hardware to enable secure channels from the veriﬁed software to remote users. To achieve such complete veriﬁcation, we developed a set of new and modiﬁed tools, a collection of techniques and engineering disciplines, and a methodology focused on rapid development of veriﬁed systems software. We describe our methodology, formal results, and lessons we learned from building a full stack of veriﬁed software. That software includes a veriﬁed kernel; veriﬁed drivers; veriﬁed system and crypto libraries including {SHA}, {HMAC}, and {RSA}; and four Ironclad Apps.},
	pages = {18},
	author = {Hawblitzel, Chris and Howell, Jon and Lorch, Jacob R and Narayan, Arjun and Parno, Bryan and Zhang, Danfeng and Zill, Brian},
	langid = {english},
	file = {Hawblitzel et al. - Ironclad Apps End-to-End Security via Automated F.pdf:/Users/richardford/Zotero/storage/W6P597PJ/Hawblitzel et al. - Ironclad Apps End-to-End Security via Automated F.pdf:application/pdf}
}

@inproceedings{hawblitzel_ironfleet:_2015,
	location = {New York, {NY}, {USA}},
	title = {{IronFleet}: Proving Practical Distributed Systems Correct},
	isbn = {978-1-4503-3834-9},
	url = {http://doi.acm.org/10.1145/2815400.2815428},
	doi = {10.1145/2815400.2815428},
	series = {{SOSP} '15},
	shorttitle = {{IronFleet}},
	abstract = {Distributed systems are notorious for harboring subtle bugs. Verification can, in principle, eliminate these bugs a priori, but verification has historically been difficult to apply at full-program scale, much less distributed-system scale. We describe a methodology for building practical and provably correct distributed systems based on a unique blend of {TLA}-style state-machine refinement and Hoare-logic verification. We demonstrate the methodology on a complex implementation of a Paxos-based replicated state machine library and a lease-based sharded key-value store. We prove that each obeys a concise safety specification, as well as desirable liveness requirements. Each implementation achieves performance competitive with a reference system. With our methodology and lessons learned, we aim to raise the standard for distributed systems from "tested" to "correct."},
	pages = {1--17},
	booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
	publisher = {{ACM}},
	author = {Hawblitzel, Chris and Howell, Jon and Kapritsos, Manos and Lorch, Jacob R. and Parno, Bryan and Roberts, Michael L. and Setty, Srinath and Zill, Brian},
	urldate = {2019-02-01},
	date = {2015},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/RP6MRQV6/Hawblitzel et al. - 2015 - IronFleet Proving Practical Distributed Systems C.pdf:application/pdf}
}

@inproceedings{hawblitzel_automated_2015,
	title = {Automated and Modular Refinement Reasoning for Concurrent Programs},
	url = {https://link.springer.com/chapter/10.1007/978-3-319-21668-3_26},
	doi = {10.1007/978-3-319-21668-3_26},
	abstract = {We present civl, a language and verifier for concurrent programs based on automated and modular refinement reasoning. civlsupports reasoning about a concurrent program at many levels of abstraction....},
	eventtitle = {International Conference on Computer Aided Verification},
	pages = {449--465},
	booktitle = {Computer Aided Verification},
	publisher = {Springer, Cham},
	author = {Hawblitzel, Chris and Petrank, Erez and Qadeer, Shaz and Tasiran, Serdar},
	urldate = {2019-02-01},
	date = {2015-07-18},
	langid = {english},
	file = {Hawblitzel et al. - 2015 - Automated and Modular Refinement Reasoning for Con.pdf:/Users/richardford/Zotero/storage/X2AJPSSW/Hawblitzel et al. - 2015 - Automated and Modular Refinement Reasoning for Con.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/89G4CJY3/10.html:text/html}
}

@inproceedings{lahiri_automatic_2015,
	title = {Automatic Rootcausing for Program Equivalence Failures in Binaries},
	isbn = {978-3-319-21690-4},
	series = {Lecture Notes in Computer Science},
	abstract = {Equivalence checking of imperative programs has several applications including compiler validation and cross-version verification. Debugging equivalence failures can be tedious for large examples, especially for low-level binary programs. In this paper, we formalize a simple yet precise notion of verifiable rootcause for equivalence failures that leverages semantic similarity between two programs. Unlike existing works on program repair, our definition of rootcause avoids the need for a template of fixes or the need for a complete repair to ensure equivalence. We show progressively weaker checks for detecting rootcauses that can be applicable even when multiple fixes are required to make the two programs equivalent. We provide optimizations based on Maximum Satisfiability ({MAXSAT}) and binary search to prune the search space of such rootcauses. We have implemented the techniques in {SymDiff} and provide an evaluation on a set of real-world compiler validation binary benchmarks.},
	pages = {362--379},
	booktitle = {Computer Aided Verification},
	publisher = {Springer International Publishing},
	author = {Lahiri, Shuvendu K. and Sinha, Rohit and Hawblitzel, Chris},
	editor = {Kroening, Daniel and Păsăreanu, Corina S.},
	date = {2015},
	langid = {english},
	file = {Lahiri et al. - 2015 - Automatic Rootcausing for Program Equivalence Fail.pdf:/Users/richardford/Zotero/storage/LJCRZ2BD/Lahiri et al. - 2015 - Automatic Rootcausing for Program Equivalence Fail.pdf:application/pdf}
}

@article{yang_safe_2011,
	title = {Safe to the last instruction: automated verification of a type-safe operating system},
	volume = {54},
	issn = {00010782},
	url = {http://dl.acm.org/citation.cfm?doid=2043174.2043197},
	doi = {10.1145/2043174.2043197},
	shorttitle = {Safe to the last instruction},
	pages = {123},
	number = {12},
	journaltitle = {Communications of the {ACM}},
	author = {Yang, Jean and Hawblitzel, Chris},
	urldate = {2019-02-01},
	date = {2011-12-01},
	langid = {english},
	file = {Full Text:/Users/richardford/Zotero/storage/NJ2ZPC4C/Yang and Hawblitzel - 2011 - Safe to the last instruction automated verificati.pdf:application/pdf}
}

@inproceedings{lahiri_symdiff:_2012,
	title = {{SYMDIFF}: A Language-Agnostic Semantic Diff Tool for Imperative Programs},
	isbn = {978-3-642-31424-7},
	series = {Lecture Notes in Computer Science},
	shorttitle = {{SYMDIFF}},
	abstract = {In this paper, we describe {SymDiff}, a language-agnostic tool for equivalence checking and displaying semantic (behavioral) differences over imperative programs. The tool operates on an intermediate verification language Boogie, for which translations exist from various source languages such as C, C\# and x86. We discuss the tool and the front-end interface to target various source languages. Finally, we provide a brief description of the front-end for C programs.},
	pages = {712--717},
	booktitle = {Computer Aided Verification},
	publisher = {Springer Berlin Heidelberg},
	author = {Lahiri, Shuvendu K. and Hawblitzel, Chris and Kawaguchi, Ming and Rebêlo, Henrique},
	editor = {Madhusudan, P. and Seshia, Sanjit A.},
	date = {2012},
	langid = {english},
	keywords = {Equivalence Check, Imperative Language, Imperative Program, Source Language, Symbolic Execution},
	file = {Springer Full Text PDF:/Users/richardford/Zotero/storage/NDSQ5WIC/Lahiri et al. - 2012 - SYMDIFF A Language-Agnostic Semantic Diff Tool fo.pdf:application/pdf}
}

@article{adams_common_2015,
	title = {The Common {HOL} Platform},
	volume = {186},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1507.08718},
	doi = {10.4204/EPTCS.186.6},
	abstract = {The Common {HOL} project aims to facilitate porting source code and proofs between members of the {HOL} family of theorem provers. At the heart of the project is the Common {HOL} Platform, which defines a standard {HOL} theory and {API} that aims to be compatible with all {HOL} systems. So far, {HOL} Light and hol90 have been adapted for conformance, and {HOL} Zero was originally developed to conform. In this paper we provide motivation for a platform, give an overview of the Common {HOL} Platform's theory and {API} components, and show how to adapt legacy systems. We also report on the platform's successful application in the hand-translation of a few thousand lines of source code from {HOL} Light to {HOL} Zero.},
	pages = {42--56},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	author = {Adams, Mark},
	urldate = {2019-02-01},
	date = {2015-07-30},
	eprinttype = {arxiv},
	eprint = {1507.08718},
	keywords = {Computer Science - Digital Libraries, Computer Science - Logic in Computer Science},
	file = {arXiv\:1507.08718 PDF:/Users/richardford/Zotero/storage/4DPSDJ3D/Adams - 2015 - The Common HOL Platform.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/T6XBJWLE/1507.html:text/html}
}

@online{shulman_hott_2013,
	title = {The {HoTT} Book},
	url = {https://homotopytypetheory.org/book/},
	abstract = {Homotopy Type Theory: Univalent Foundations of Mathematics The Univalent Foundations Program Institute for Advanced Study Buy a hardcover copy for \$22.05. [620 pages, 6″ × 9″ size, hard…},
	titleaddon = {Homotopy Type Theory},
	author = {Shulman, Mike},
	urldate = {2019-02-01},
	date = {2013-03-12},
	langid = {english},
	file = {Snapshot:/Users/richardford/Zotero/storage/TCY2DTGX/book.html:text/html}
}

@article{voevodsky_homotopy_nodate,
	title = {Homotopy Type Theory: Univalent Foundations of Mathematics},
	pages = {490},
	author = {Voevodsky, Vladimir},
	langid = {english},
	file = {Homotopy Type Theory Univalent Foundations of Mat.pdf:/Users/richardford/Zotero/storage/933KJZF5/Homotopy Type Theory Univalent Foundations of Mat.pdf:application/pdf}
}

@inproceedings{nelson_hyperkernel:_2017,
	location = {New York, {NY}, {USA}},
	title = {Hyperkernel: Push-Button Verification of an {OS} Kernel},
	isbn = {978-1-4503-5085-3},
	url = {http://doi.acm.org/10.1145/3132747.3132748},
	doi = {10.1145/3132747.3132748},
	series = {{SOSP} '17},
	shorttitle = {Hyperkernel},
	abstract = {This paper describes an approach to designing, implementing, and formally verifying the functional correctness of an {OS} kernel, named Hyperkernel, with a high degree of proof automation and low proof burden. We base the design of Hyperkernel's interface on xv6, a Unix-like teaching operating system. Hyperkernel introduces three key ideas to achieve proof automation: it finitizes the kernel interface to avoid unbounded loops or recursion; it separates kernel and user address spaces to simplify reasoning about virtual memory; and it performs verification at the {LLVM} intermediate representation level to avoid modeling complicated C semantics. We have verified the implementation of Hyperkernel with the Z3 {SMT} solver, checking a total of 50 system calls and other trap handlers. Experience shows that Hyperkernel can avoid bugs similar to those found in xv6, and that the verification of Hyperkernel can be achieved with a low proof burden.},
	pages = {252--269},
	booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
	publisher = {{ACM}},
	author = {Nelson, Luke and Sigurbjarnarson, Helgi and Zhang, Kaiyuan and Johnson, Dylan and Bornholt, James and Torlak, Emina and Wang, Xi},
	urldate = {2019-02-01},
	date = {2017},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/79Z44YVX/Nelson et al. - 2017 - Hyperkernel Push-Button Verification of an OS Ker.pdf:application/pdf}
}

@inproceedings{nelson_hyperkernel:_2017-1,
	location = {Shanghai, China},
	title = {Hyperkernel: Push-Button Verification of an {OS} Kernel - Slides},
	isbn = {978-1-4503-5085-3},
	url = {http://dl.acm.org/citation.cfm?doid=3132747.3132748},
	doi = {10.1145/3132747.3132748},
	shorttitle = {Hyperkernel},
	eventtitle = {the 26th Symposium},
	pages = {252--269},
	booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles  - {SOSP} '17},
	publisher = {{ACM} Press},
	author = {Nelson, Luke and Sigurbjarnarson, Helgi and Zhang, Kaiyuan and Johnson, Dylan and Bornholt, James and Torlak, Emina and Wang, Xi},
	urldate = {2019-02-01},
	date = {2017},
	langid = {english},
	file = {Nelson et al. - 2017 - Hyperkernel Push-Button Verification of an OS Ker.pdf:/Users/richardford/Zotero/storage/WR6NX9HN/Nelson et al. - 2017 - Hyperkernel Push-Button Verification of an OS Ker.pdf:application/pdf}
}

@online{jung_iris_nodate,
	title = {Iris Project},
	url = {https://iris-project.org/},
	author = {Jung, Ralf},
	urldate = {2019-02-01},
	file = {Iris Project:/Users/richardford/Zotero/storage/2R8EYKZ5/iris-project.org.html:text/html}
}

@online{birkedal_iris_nodate,
	title = {Iris Tutorial},
	url = {https://iris-project.org/tutorial-material.html},
	author = {Birkedal, Lars and Bizjak, Aleš},
	urldate = {2019-02-01},
	file = {Iris Tutorial:/Users/richardford/Zotero/storage/WF7L6JWA/tutorial-material.html:text/html}
}

@article{jung_iris_2018,
	title = {Iris from the ground up: A modular foundation for higher-order concurrent separation logic},
	volume = {28},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/iris-from-the-ground-up-a-modular-foundation-for-higherorder-concurrent-separation-logic/26301B518CE2C52796BFA12B8BAB5B5F},
	doi = {10.1017/S0956796818000151},
	shorttitle = {Iris from the ground up},
	abstract = {Iris is a framework for higher-order concurrent separation logic, which has been implemented in the Coq proof assistant and deployed very effectively in a wide variety of verification projects. Iris was designed with the express goal of simplifying and consolidating the foundations of modern separation logics, but it has evolved over time, and the design and semantic foundations of Iris itself have yet to be fully written down and explained together properly in one place. Here, we attempt to fill this gap, presenting a reasonably complete picture of the latest version of Iris (version 3.1), from first principles and in one coherent narrative.},
	journaltitle = {Journal of Functional Programming},
	author = {Jung, Ralf and Krebbers, Robbert and Jourdan, Jacques-Henri and Bizjak, Aleš and Birkedal, Lars and Dreyer, Derek},
	urldate = {2019-02-01},
	date = {2018},
	langid = {english},
	file = {Snapshot:/Users/richardford/Zotero/storage/3QJUK97X/26301B518CE2C52796BFA12B8BAB5B5F.html:text/html}
}

@article{paulson_foundation_2000,
	title = {The Foundation of a Generic Theorem Prover},
	url = {http://arxiv.org/abs/cs/9301105},
	abstract = {Isabelle is an interactive theorem prover that supports a variety of logics. It represents rules as propositions (not as functions) and builds proofs by combining rules. These operations constitute a meta-logic (or `logical framework') in which the object-logics are formalized. Isabelle is now based on higher-order logic -- a precise and well-understood foundation. Examples illustrate use of this meta-logic to formalize logics and proofs. Axioms for first-order logic are shown sound and complete. Backwards proof is formalized by meta-reasoning about object-level entailment. Higher-order logic has several practical advantages over other meta-logics. Many proof techniques are known, such as Huet's higher-order unification procedure.},
	journaltitle = {{arXiv}:cs/9301105},
	author = {Paulson, Lawrence C.},
	urldate = {2019-02-01},
	date = {2000-10-30},
	eprinttype = {arxiv},
	eprint = {cs/9301105},
	keywords = {Computer Science - Logic in Computer Science, F.3.1, F.4.1},
	file = {arXiv\:cs/9301105 PDF:/Users/richardford/Zotero/storage/Y5PBFBXS/Paulson - 2000 - The Foundation of a Generic Theorem Prover.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/SLUTEXCX/9301105.html:text/html}
}

@article{wenzel_isabelle/isar_2018,
	title = {The Isabelle/Isar Reference Manual},
	url = {https://core.ac.uk/display/22830292},
	abstract = {Intelligible semi-automated reasoning (Isar) is a generic approach to readable formal proof documents. It sets out to bridge the semantic gap between any internal notions of proof based on primitive inferences and tactics, and an appropriate level of abstraction for user-level work. The Isar formal proof language has been designed to satisfy quite contradictory requirements, being both \&quot;declarative\&quot; and immediately \&quot;executable\&quot;, by virtue of the Isar/{VM}  interpreter. The Isabelle/Isar system provides an interpreter for the Isar formal proof language. The input may consist either of proper document constructors, or improper auxiliary commands (for diagnostics, exploration etc.). Proof texts consisting of proper elements only admit a purely static reading, thus being intelligible later without requiring dynamic replay that is so typical for traditional proof scripts. Any of the Isabelle/Isar commands may be executed in single-steps, so basically the interpreter has a proof text debugger ..},
	author = {Wenzel, Markus},
	urldate = {2019-02-01},
	date = {2018},
	langid = {english},
	file = {Snapshot:/Users/richardford/Zotero/storage/M7HKI4WD/22830292.html:text/html;Wenzel - The IsabelleIsar Reference Manual.pdf:/Users/richardford/Zotero/storage/R6VSCXHR/Wenzel - The IsabelleIsar Reference Manual.pdf:application/pdf}
}

@article{ishtiaq_bi_2011,
	title = {{BI} As an Assertion Language for Mutable Data Structures},
	volume = {46},
	issn = {0362-1340},
	url = {http://doi.acm.org/10.1145/1988042.1988050},
	doi = {10.1145/1988042.1988050},
	abstract = {Reynolds has developed a logic for reasoning about mutable data structures in which the pre- and postconditions are written in an intuitionistic logic enriched with a spatial form of conjunction. We investigate the approach from the point of view of the logic {BI} of bunched implications of O'Hearn and Pym. We begin by giving a model in which the law of the excluded middle holds, thus showing that the approach is compatible with classical logic. The relationship between the intuitionistic and classical versions of the system is established by a translation, analogous to a translation from intuitionistic logic into the modal logic S4. We also consider the question of completeness of the axioms. {BI}'s spatial implication is used to express weakest preconditions for object-component assignments, and an axiom for allocating a cons cell is shown to be complete under an interpretation of triples that allows a command to be applied to states with dangling pointers. We make this latter a feature, by incorporating an operation, and axiom, for disposing of memory. Finally, we describe a local character enjoyed by specifications in the logic, and show how this enables a class of frame axioms, which say what parts of the heap don't change, to be inferred automatically.},
	pages = {84--96},
	number = {4},
	journaltitle = {{SIGPLAN} Not.},
	author = {Ishtiaq, Samin and O'Hearn, Peter W.},
	urldate = {2019-02-01},
	date = {2011-05},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/FT687HNC/Ishtiaq and O'Hearn - 2011 - BI As an Assertion Language for Mutable Data Struc.pdf:application/pdf}
}

@incollection{hutchison_seloger:_2013,
	location = {Berlin, Heidelberg},
	title = {{SeLoger}: A Tool for Graph-Based Reasoning in Separation Logic},
	volume = {8044},
	isbn = {978-3-642-39798-1 978-3-642-39799-8},
	url = {http://link.springer.com/10.1007/978-3-642-39799-8_55},
	shorttitle = {{SeLoger}},
	abstract = {This paper introduces the tool {SeLoger}, which is a reasoner for satisﬁability and entailment in a fragment of separation logic with pointers and linked lists. {SeLoger} builds upon and extends graphbased algorithms that have recently been introduced in order to settle both decision problems in polynomial time. Running {SeLoger} on standard benchmarks shows that the tool outperforms current state-of-theart tools by orders of magnitude.},
	pages = {790--795},
	booktitle = {Computer Aided Verification},
	publisher = {Springer Berlin Heidelberg},
	author = {Haase, Christoph and Ishtiaq, Samin and Ouaknine, Joël and Parkinson, Matthew J.},
	editor = {Sharygina, Natasha and Veith, Helmut},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2019-02-01},
	date = {2013},
	langid = {english},
	doi = {10.1007/978-3-642-39799-8_55},
	file = {Haase et al. - 2013 - SeLoger A Tool for Graph-Based Reasoning in Separ.pdf:/Users/richardford/Zotero/storage/PQPRK2IX/Haase et al. - 2013 - SeLoger A Tool for Graph-Based Reasoning in Separ.pdf:application/pdf}
}

@article{crick_share_2014,
	title = {"Share and Enjoy": Publishing Useful and Usable Scientific Models},
	url = {http://arxiv.org/abs/1409.0367},
	shorttitle = {"Share and Enjoy"},
	abstract = {The reproduction and replication of reported scientific results is a hot topic within the academic community. The retraction of numerous studies from a wide range of disciplines, from climate science to bioscience, has drawn the focus of many commentators, but there exists a wider socio-cultural problem that pervades the scientific community. Sharing code, data and models often requires extra effort; this is currently seen as a significant overhead that may not be worth the time investment. Automated systems, which allow easy reproduction of results, offer the potential to incentivise a culture change and drive the adoption of new techniques to improve the efficiency of scientific exploration. In this paper, we discuss the value of improved access and sharing of the two key types of results arising from work done in the computational sciences: models and algorithms. We propose the development of an integrated cloud-based system underpinning computational science, linking together software and data repositories, toolchains, workflows and outputs, providing a seamless automated infrastructure for the verification and validation of scientific models and in particular, performance benchmarks.},
	journaltitle = {{arXiv}:1409.0367 [cs]},
	author = {Crick, Tom and Hall, Benjamin A. and Ishtiaq, Samin and Takeda, Kenji},
	urldate = {2019-02-01},
	date = {2014-09-01},
	eprinttype = {arxiv},
	eprint = {1409.0367},
	keywords = {Computer Science - Computational Engineering, Finance, and Science},
	file = {arXiv\:1409.0367 PDF:/Users/richardford/Zotero/storage/LKKTEADA/Crick et al. - 2014 - Share and Enjoy Publishing Useful and Usable Sc.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/YWG36WKR/1409.html:text/html}
}

@inproceedings{brockschmidt_t2:_2016,
	title = {T2: Temporal Property Verification},
	isbn = {978-3-662-49674-9},
	series = {Lecture Notes in Computer Science},
	shorttitle = {T2},
	abstract = {We present the open-source tool T2, the first public release from the {TERMINATOR} project [9]. T2 has been extended over the past decade to support automatic temporal-logic proving techniques and to handle a general class of user-provided liveness and safety properties. Input can be provided in a native format and in C, via the support of the {LLVM} compiler framework. We briefly discuss T2’s architecture, its underlying techniques, and conclude with an experimental illustration of its competitiveness and directions for future extensions.},
	pages = {387--393},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Brockschmidt, Marc and Cook, Byron and Ishtiaq, Samin and Khlaaf, Heidy and Piterman, Nir},
	editor = {Chechik, Marsha and Raskin, Jean-François},
	date = {2016},
	langid = {english},
	file = {Brockschmidt et al. - 2016 - T2 Temporal Property Verification.pdf:/Users/richardford/Zotero/storage/NTYHNVUJ/Brockschmidt et al. - 2016 - T2 Temporal Property Verification.pdf:application/pdf}
}

@article{arias_jscoq:_2017,
	title = {{jsCoq}: Towards Hybrid Theorem Proving Interfaces},
	volume = {239},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1701.07125},
	doi = {10.4204/EPTCS.239.2},
	shorttitle = {{jsCoq}},
	abstract = {We describe {jsCcoq}, a new platform and user environment for the Coq interactive proof assistant. The {jsCoq} system targets the {HTML}5-{ECMAScript} 2015 specification, and it is typically run inside a standards-compliant browser, without the need of external servers or services. Targeting educational use, {jsCoq} allows the user to start interaction with proof scripts right away, thanks to its self-contained nature. Indeed, a full Coq environment is packed along the proof scripts, easing distribution and installation. Starting to use {jsCoq} is as easy as clicking on a link. The current release ships more than 10 popular Coq libraries, and supports popular books such as Software Foundations or Certified Programming with Dependent Types. The new target platform has opened up new interaction and display possibilities. It has also fostered the development of some new Coq-related technology. In particular, we have implemented a new serialization-based protocol for interaction with the proof assistant, as well as a new package format for library distribution.},
	pages = {15--27},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	author = {Arias, Emilio Jesús Gallego and Pin, Benoît and Jouvelot, Pierre},
	urldate = {2019-02-01},
	date = {2017-01-24},
	eprinttype = {arxiv},
	eprint = {1701.07125},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Logic in Computer Science, Computer Science - Machine Learning, Computer Science - Programming Languages},
	file = {arXiv\:1701.07125 PDF:/Users/richardford/Zotero/storage/KW34YHZU/Arias et al. - 2017 - jsCoq Towards Hybrid Theorem Proving Interfaces.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/6S4YQDBI/1701.html:text/html}
}

@online{kaiser_destruct_nodate,
	title = {A “destruct” Tactic for Mtac2 - {POPL} 2018},
	url = {https://popl18.sigplan.org/event/coqpl-2018-a-destruct-tactic-for-mtac2},
	author = {Kaiser, Jan-Oliver and Ziliani, Beta},
	urldate = {2019-02-01},
	file = {A “destruct” Tactic for Mtac2 - POPL 2018:/Users/richardford/Zotero/storage/P2PWXNIY/coqpl-2018-a-destruct-tactic-for-mtac2.html:text/html;A “destruct” Tactic for Mtac2 - POPL 2018.pdf:/Users/richardford/Zotero/storage/LQW2W8LV/A “destruct” Tactic for Mtac2 - POPL 2018.pdf:application/pdf}
}

@inproceedings{hathhorn_defining_2015,
	location = {New York, {NY}, {USA}},
	title = {Defining the Undefinedness of C},
	isbn = {978-1-4503-3468-6},
	url = {http://doi.acm.org/10.1145/2737924.2737979},
	doi = {10.1145/2737924.2737979},
	series = {{PLDI} '15},
	abstract = {We present a ``negative'' semantics of the C11 language---a semantics that does not just give meaning to correct programs, but also rejects undefined programs. We investigate undefined behavior in C and discuss the techniques and special considerations needed for formally specifying it. We have used these techniques to modify and extend a semantics of C into one that captures undefined behavior. The amount of semantic infrastructure and effort required to achieve this was unexpectedly high, in the end nearly doubling the size of the original semantics. From our semantics, we have automatically extracted an undefinedness checker, which we evaluate against other popular analysis tools, using our own test suite in addition to a third-party test suite. Our checker is capable of detecting examples of all 77 categories of core language undefinedness appearing in the C11 standard, more than any other tool we considered. Based on this evaluation, we argue that our work is the most comprehensive and complete semantic treatment of undefined behavior in C, and thus of the C language itself.},
	pages = {336--345},
	booktitle = {Proceedings of the 36th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Hathhorn, Chris and Ellison, Chucky and Roşu, Grigore},
	urldate = {2019-02-01},
	date = {2015},
	keywords = {C11, K Framework, Programming language semantics, Undefined behavior},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/5UX692DD/Hathhorn et al. - 2015 - Defining the Undefinedness of C.pdf:application/pdf}
}

@online{kubota_foundations_nodate,
	title = {Foundations of Mathematics – Owl of Minerva Press},
	url = {http://owlofminerva.net/foundations-of-mathematics/},
	author = {Kubota, Ken},
	urldate = {2019-02-01},
	langid = {american},
	file = {Snapshot:/Users/richardford/Zotero/storage/TBEEJ37H/foundations-of-mathematics.html:text/html}
}

@article{kubota_foundations_2016,
	title = {Foundations of Mathematics},
	url = {http://www.owlofminerva.net/doi/10.4444/100/111/},
	doi = {10.4444/100.111},
	author = {Kubota, Ken},
	urldate = {2019-02-01},
	date = {2016},
	langid = {english},
	file = {Kubota - 2016 - Foundations of Mathematics.pdf:/Users/richardford/Zotero/storage/LTUGMTBE/Kubota - 2016 - Foundations of Mathematics.pdf:application/pdf}
}

@online{lamport_specifying_nodate,
	title = {Specifying Systems},
	url = {https://lamport.azurewebsites.net/tla/book.html},
	author = {Lamport, Leslie},
	urldate = {2019-02-01},
	file = {Specifying Systems:/Users/richardford/Zotero/storage/KYBHG99K/book.html:text/html;Specifying Systems.pdf:/Users/richardford/Zotero/storage/2XZL6LR2/Specifying Systems.pdf:application/pdf}
}

@online{wikibook_latex_nodate,
	title = {{LaTeX} - Wikibooks, open books for an open world},
	url = {https://en.wikibooks.org/wiki/LaTeX},
	author = {wikibook},
	urldate = {2019-02-01},
	file = {LaTeX - Wikibooks, open books for an open world:/Users/richardford/Zotero/storage/6ML74WS9/LaTeX.html:text/html;LaTeX - Wikibooks, open books for an open world.pdf:/Users/richardford/Zotero/storage/6K57KTSZ/LaTeX - Wikibooks, open books for an open world.pdf:application/pdf}
}

@article{pakin_comprehensive_nodate,
	title = {The Comprehensive {LaTeX} Symbol List},
	abstract = {This document lists 14283 symbols and the corresponding {LATEX} commands that produce them. Some of these symbols are guaranteed to be available in every {LATEX} 2������ system; others require fonts and packages that may not accompany a given distribution and that therefore need to be installed. All of the fonts and packages used to prepare this document—as well as this document itself—are freely available from the Comprehensive {TEX} Archive Network (http://www.ctan.org/).},
	pages = {358},
	author = {Pakin, Scott},
	langid = {english},
	file = {Pakin - The Comprehensive LaTeX Symbol List.pdf:/Users/richardford/Zotero/storage/8ZIDMML6/Pakin - The Comprehensive LaTeX Symbol List.pdf:application/pdf}
}

@article{ebner_metaprogramming_2017,
	title = {A Metaprogramming Framework for Formal Verification},
	volume = {1},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3110278},
	doi = {10.1145/3110278},
	abstract = {We describe the metaprogramming framework currently used in Lean, an interactive theorem prover based on dependent type theory. This framework extends Lean's object language with an {API} to some of Lean's internal structures and procedures, and provides ways of reflecting object-level expressions into the metalanguage. We provide evidence to show that our implementation is performant, and that it provides a convenient and flexible way of writing not only small-scale interactive tactics, but also more substantial kinds of automation.},
	pages = {34:1--34:29},
	issue = {{ICFP}},
	journaltitle = {Proc. {ACM} Program. Lang.},
	author = {Ebner, Gabriel and Ullrich, Sebastian and Roesch, Jared and Avigad, Jeremy and de Moura, Leonardo},
	urldate = {2019-02-01},
	date = {2017-08},
	keywords = {dependent type theory, metaprogramming, tactic language, theorem proving},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/BQCSENJ7/Ebner et al. - 2017 - A Metaprogramming Framework for Formal Verificatio.pdf:application/pdf}
}

@online{letouzey_certified_nodate,
	title = {Certified functional programming : Program extraction within Coq proof assistant},
	url = {https://www.researchgate.net/publication/280790704_Certified_functional_programming_Program_extraction_within_Coq_proof_assistant},
	shorttitle = {(8) ({PDF}) Certified functional programming},
	abstract = {{NOTA}: {THIS} {IS} {THE} {ENGLISH} {TRANSLATION} {OF} {MY} {FRENCH} {PHD} {MANUSCRIPT}. This work concerns the generation of programs which are certified to be correct by construction. These programs are obtained by extracting relevant information from constructive proofs made with the Coq proof assistant. Such a translation, named ``extraction'', of constructive proofs into functional programs is not new, and corresponds to an isomorphism known as Curry-Howard's. An extraction tool has been part of Coq assistant for a long time. But this old extraction tool suffered from several limitations: in particular, some Coq proofs were refused by it, whereas some others led to incorrect programs. In order to overcome these limitations, we built a completely new extraction tool for Coq, including both a new theory and a new implementation. Concerning theory, we developed new correctness proofs for this extraction mechanism. These new proofs are both complex and original. Concerning implementation, we focused on the generation of efficient and realistic code, which can be integrated in large-scale software developments, using modules and interfaces. Finally, we also present several case studies illustrating the capabilities of our new extraction. For example, we describe the certification of a modular library of finite set structures, and the production of programs about real exact arithmetic, starting from a formalization of constructive real analysis. These examples show the progress already achieved, even if the situation is not perfect yet, in particular in the last study.},
	titleaddon = {{ResearchGate}},
	author = {Letouzey, Pierre},
	urldate = {2019-02-01},
	langid = {english},
	file = {(8) (PDF) Certified functional programming  Progr.pdf:/Users/richardford/Zotero/storage/5IQA98EJ/(8) (PDF) Certified functional programming  Progr.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/V78NSVFJ/280790704_Certified_functional_programming_Program_extraction_within_Coq_proof_assistant.html:text/html}
}

@inproceedings{kang_crellvm:_2018,
	location = {New York, {NY}, {USA}},
	title = {Crellvm: Verified Credible Compilation for {LLVM}},
	isbn = {978-1-4503-5698-5},
	url = {http://doi.acm.org/10.1145/3192366.3192377},
	doi = {10.1145/3192366.3192377},
	series = {{PLDI} 2018},
	shorttitle = {Crellvm},
	abstract = {Production compilers such as {GCC} and {LLVM} are large complex software systems, for which achieving a high level of reliability is hard. Although testing is an effective method for finding bugs, it alone cannot guarantee a high level of reliability. To provide a higher level of reliability, many approaches that examine compilers' internal logics have been proposed. However, none of them have been successfully applied to major optimizations of production compilers. This paper presents Crellvm: a verified credible compilation framework for {LLVM}, which can be used as a systematic way of providing a high level of reliability for major optimizations in {LLVM}. Specifically, we augment an {LLVM} optimizer to generate translation results together with their correctness proofs, which can then be checked by a proof checker formally verified in Coq. As case studies, we applied our approach to two major optimizations of {LLVM}: register promotion mem2reg and global value numbering gvn, having found four new miscompilation bugs (two in each).},
	pages = {631--645},
	booktitle = {Proceedings of the 39th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Kang, Jeehoon and Kim, Yoonseung and Song, Youngju and Lee, Juneyoung and Park, Sanghoon and Shin, Mark Dongyeon and Kim, Yonghyun and Cho, Sungkeun and Choi, Joonwon and Hur, Chung-Kil and Yi, Kwangkeun},
	urldate = {2019-02-01},
	date = {2018},
	keywords = {compiler verification, Coq, credible compilation, {LLVM}, relational Hoare logic, translation validation},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/9BFDP4D4/Kang et al. - 2018 - Crellvm Verified Credible Compilation for LLVM.pdf:application/pdf}
}

@online{luo_extended_nodate,
	title = {An Extended Calculus of Constructions},
	url = {http://www.lfcs.inf.ed.ac.uk/reports/90/ECS-LFCS-90-118/},
	author = {Luo, Zhaohui},
	urldate = {2019-02-01},
	file = {Snapshot:/Users/richardford/Zotero/storage/7C9DFE56/ECS-LFCS-90-118.html:text/html;Zhaohui Luo - An Extended Calculus of Constructions.pdf:/Users/richardford/Zotero/storage/LXDDMBKD/Zhaohui Luo - An Extended Calculus of Constructions.pdf:application/pdf}
}

@online{patterson_compositional_nodate,
	title = {On Compositional Compiler Correctness and Fully Abstract Compilation - {POPL} 2018},
	url = {https://popl18.sigplan.org/event/prisc-2018-on-compositional-compiler-correctness-and-fully-abstract-compilation},
	author = {Patterson, Daniel and Ahmed, Amal},
	urldate = {2019-02-01},
	file = {On Compositional Compiler Correctness and Fully Abstract Compilation - POPL 2018:/Users/richardford/Zotero/storage/3WP6IYAC/prisc-2018-on-compositional-compiler-correctness-and-fully-abstract-compilation.html:text/html}
}

@article{patterson_compositional_nodate-1,
	title = {On Compositional Compiler Correctness and Fully Abstract Compilation},
	url = {https://popl18.sigplan.org/event/prisc-2018-on-compositional-compiler-correctness-and-fully-abstract-compilation},
	pages = {3},
	author = {Patterson, Daniel and Ahmed, Amal},
	langid = {english},
	file = {Patterson and Ahmed - On Compositional Compiler Correctness and Fully Ab.pdf:/Users/richardford/Zotero/storage/4BK4I6T7/Patterson and Ahmed - On Compositional Compiler Correctness and Fully Ab.pdf:application/pdf}
}

@book{gasser_building_1988,
	location = {New York},
	title = {Building a secure computer system},
	isbn = {978-0-442-23022-7},
	pagetotal = {288},
	publisher = {Van Nostrand Reinhold Co},
	author = {Gasser, Morrie},
	date = {1988},
	keywords = {Computer security, System design},
	file = {Gasser - 1988 - Building a secure computer system.pdf:/Users/richardford/Zotero/storage/DRV4KDU6/Gasser - 1988 - Building a secure computer system.pdf:application/pdf}
}

@inproceedings{costan_sanctum:_2016,
	title = {Sanctum: Minimal Hardware Extensions for Strong Software Isolation},
	url = {https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/costan},
	shorttitle = {Sanctum},
	eventtitle = {25th \{{USENIX}\} Security Symposium (\{{USENIX}\} Security 16)},
	pages = {857--874},
	author = {Costan, Victor and Lebedev, Ilia and Devadas, Srinivas},
	urldate = {2019-02-01},
	date = {2016},
	langid = {english},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/XM5L2QXN/Costan et al. - 2016 - Sanctum Minimal Hardware Extensions for Strong So.pdf:application/pdf}
}

@article{costan_secure_2017,
	title = {Secure Processors Part I: Background, Taxonomy for Secure Enclaves and Intel {SGX} Architecture},
	volume = {11},
	issn = {1551-3939, 1551-3947},
	url = {http://www.nowpublishers.com/article/Details/EDA-051},
	doi = {10.1561/1000000051},
	shorttitle = {Secure Processors Part I},
	pages = {1--248},
	number = {1},
	journaltitle = {Foundations and Trends® in Electronic Design Automation},
	author = {Costan, Victor and Lebedev, Ilia and Devadas, Srinivas},
	urldate = {2019-02-01},
	date = {2017},
	langid = {english},
	file = {Costan et al. - 2017 - Secure Processors Part I Background, Taxonomy for.pdf:/Users/richardford/Zotero/storage/2ZB798A8/Costan et al. - 2017 - Secure Processors Part I Background, Taxonomy for.pdf:application/pdf}
}

@article{costan_secure_2017-1,
	title = {Secure Processors Part {II}: Intel {SGX} Security Analysis and {MIT} Sanctum Architecture},
	volume = {11},
	issn = {1551-3939, 1551-3947},
	url = {http://www.nowpublishers.com/article/Details/EDA-052},
	doi = {10.1561/1000000052},
	shorttitle = {Secure Processors Part {II}},
	pages = {249--361},
	number = {3},
	journaltitle = {Foundations and Trends® in Electronic Design Automation},
	author = {Costan, Victor and Lebedev, Ilia and Devadas, Srinivas},
	urldate = {2019-02-01},
	date = {2017},
	langid = {english},
	file = {Costan et al. - 2017 - Secure Processors Part II Intel SGX Security Anal.pdf:/Users/richardford/Zotero/storage/64GE2MA5/Costan et al. - 2017 - Secure Processors Part II Intel SGX Security Anal.pdf:application/pdf}
}

@online{pottier_menhir_nodate,
	title = {Menhir Reference Manual (version 20181113)},
	url = {http://gallium.inria.fr/~fpottier/menhir/manual.html},
	author = {Pottier, Francois and {REgis}-Gianas, Yan},
	urldate = {2019-02-01},
	file = {Menhir Reference Manual (version 20181113):/Users/richardford/Zotero/storage/P8JV42LL/manual.html:text/html;Menhir Reference Manual (version 20181113).pdf:/Users/richardford/Zotero/storage/P7ZHFCWM/Menhir Reference Manual (version 20181113).pdf:application/pdf}
}

@software{jacobs_verifast/verifast:_2019,
	title = {verifast/verifast: Research prototype tool for modular formal verification of C and Java programs},
	rights = {View license},
	url = {https://github.com/verifast/verifast},
	shorttitle = {Research prototype tool for modular formal verification of C and Java programs},
	publisher = {verifast},
	author = {Jacobs, Bart},
	urldate = {2019-02-01},
	date = {2019-01-25},
	note = {original-date: 2013-11-19T08:57:02Z}
}

@article{jacobs_featherweight_2015,
	title = {Featherweight {VeriFast}},
	volume = {11},
	issn = {18605974},
	url = {http://arxiv.org/abs/1507.07697},
	doi = {10.2168/LMCS-11(3:19)2015},
	abstract = {{VeriFast} is a leading research prototype tool for the sound modular verification of safety and correctness properties of single-threaded and multithreaded C and Java programs. It has been used as a vehicle for exploration and validation of novel program verification techniques and for industrial case studies; it has served well at a number of program verification competitions; and it has been used for teaching by multiple teachers independent of the authors. However, until now, while {VeriFast}'s operation has been described informally in a number of publications, and specific verification techniques have been formalized, a clear and precise exposition of how {VeriFast} works has not yet appeared. In this article we present for the first time a formal definition and soundness proof of a core subset of the {VeriFast} program verification approach. The exposition aims to be both accessible and rigorous: the text is based on lecture notes for a graduate course on program verification, and it is backed by an executable machine-readable definition and machine-checked soundness proof in Coq.},
	number = {3},
	journaltitle = {Logical Methods in Computer Science},
	author = {Jacobs, Bart and Vogels, Frédéric and Piessens, Frank},
	urldate = {2019-02-01},
	date = {2015-09-22},
	eprinttype = {arxiv},
	eprint = {1507.07697},
	keywords = {Computer Science - Logic in Computer Science},
	file = {arXiv\:1507.07697 PDF:/Users/richardford/Zotero/storage/6M9VGQ6K/Jacobs et al. - 2015 - Featherweight VeriFast.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/DVD7VF44/1507.html:text/html}
}

@report{jacobs_verifast_2008,
	title = {The {VeriFast} program verifier},
	abstract = {This note describes a separation-logic-based approach for the spec-ification and verification of safety properties of pointer-manipulating imperative programs. We describe the approach for the C language. The safety properties to be verified are specified as annotations in the source code, in the form of function preconditions and post-conditions expressed as separation logic assertions. To enable rich specifications, the user may include additional annotations that de-fine inductive datatypes, primitive recursive pure functions over these datatypes, and abstract predicates (i.e. named, parameterized assertions). A restricted form of existential quantification is sup-ported in assertions in the form of pattern matching. Verification is based on forward symbolic execution, where memory is represented as a separate conjunction of points-to as-sertions and abstract predicate assertions, and data values are rep-},
	author = {Jacobs, Bart and Piessens, Frank},
	date = {2008},
	file = {Citeseer - Full Text PDF:/Users/richardford/Zotero/storage/92SEBWLL/Jacobs and Piessens - 2008 - The VeriFast program verifier.pdf:application/pdf;Citeseer - Snapshot:/Users/richardford/Zotero/storage/5AS6HTW6/summary.html:text/html}
}

@article{jacobs_verifast_2017,
	title = {The {VeriFast} Program Veriﬁer: A Tutorial},
	pages = {102},
	author = {Jacobs, Bart and Smans, Jan and Piessens, Frank},
	date = {2017-11-28},
	langid = {english},
	file = {Jacobs et al. - The VeriFast Program Veriﬁer A Tutorial.pdf:/Users/richardford/Zotero/storage/EUBUNUXD/Jacobs et al. - The VeriFast Program Veriﬁer A Tutorial.pdf:application/pdf}
}

@online{leroy_ocaml_nodate,
	title = {{OCaml} Home Page},
	url = {https://ocaml.org/},
	author = {Leroy, Xavier},
	urldate = {2019-02-01},
	file = {OCaml – OCaml:/Users/richardford/Zotero/storage/GH352N3D/ocaml.org.html:text/html}
}

@online{minsky_real_nodate,
	title = {Real World {OCaml}},
	url = {http://dev.realworldocaml.org/},
	author = {Minsky, Yaron and Madhavapeddy, Anil and Hickey, Jason},
	urldate = {2019-02-01},
	file = {Real World OCaml:/Users/richardford/Zotero/storage/H2TNKC6U/dev.realworldocaml.org.html:text/html}
}

@inproceedings{lampson_abcds_2001,
	location = {New York, {NY}, {USA}},
	title = {The {ABCD}'s of Paxos},
	isbn = {978-1-58113-383-7},
	url = {http://doi.acm.org/10.1145/383962.383969},
	doi = {10.1145/383962.383969},
	series = {{PODC} '01},
	abstract = {We explain how consensus is used to implement replicated state machines, the general mechanism for fault-tolerance. We describe an abstract version of Lamport's Paxos algorithm for asynchronous consensus. Then we derive the Byzantine, classic, and disk versions of Paxos from the abstract one, show how they are related to each other, and discuss the safety, liveness, and performance of each one.},
	pages = {13--},
	booktitle = {Proceedings of the Twentieth Annual {ACM} Symposium on Principles of Distributed Computing},
	publisher = {{ACM}},
	author = {Lampson, Butler},
	urldate = {2019-02-01},
	date = {2001},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/RSUUAANU/Lampson - 2001 - The ABCD's of Paxos.pdf:application/pdf}
}

@article{van_renesse_paxos_2015,
	title = {Paxos Made Moderately Complex},
	volume = {47},
	issn = {0360-0300},
	url = {http://doi.acm.org/10.1145/2673577},
	doi = {10.1145/2673577},
	abstract = {This article explains the full reconfigurable multidecree Paxos (or multi-Paxos) protocol. Paxos is by no means a simple protocol, even though it is based on relatively simple invariants. We provide pseudocode and explain it guided by invariants. We initially avoid optimizations that complicate comprehension. Next we discuss liveness, list various optimizations that make the protocol practical, and present variants of the protocol.},
	pages = {42:1--42:36},
	number = {3},
	journaltitle = {{ACM} Comput. Surv.},
	author = {Van Renesse, Robbert and Altinbuken, Deniz},
	urldate = {2019-02-01},
	date = {2015-02},
	keywords = {consensus, Replicated state machines, voting},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/WITY9Q45/Van Renesse and Altinbuken - 2015 - Paxos Made Moderately Complex.pdf:application/pdf}
}

@incollection{hutchison_improving_2012,
	location = {Berlin, Heidelberg},
	title = {Improving Real Analysis in Coq: A User-Friendly Approach to Integrals and Derivatives},
	volume = {7679},
	isbn = {978-3-642-35307-9 978-3-642-35308-6},
	url = {http://link.springer.com/10.1007/978-3-642-35308-6_22},
	shorttitle = {Improving Real Analysis in Coq},
	abstract = {Veriﬁcation of numerical analysis programs requires dealing with derivatives and integrals. High conﬁdence in this process can be achieved using a formal proof checker, such as Coq. Its standard library provides an axiomatization of real numbers and various lemmas about real analysis, which may be used for this purpose. Unfortunately, its deﬁnitions of derivative and integral are unpractical as they are partial functions that demand a proof term. This proof term makes the handling of mathematical formulas cumbersome and does not conform to traditional analysis. Other proof assistants usually do not suﬀer from this issue; for instance, they may rely on Hilbert’s epsilon to get total operators. In this paper, we propose a way to deﬁne total operators for derivative and integral without having to extend Coq’s standard axiomatization of real numbers. We proved the compatibility of our deﬁnitions with the standard library’s in order to leverage existing results. We also greatly improved automation for real analysis proofs that use Coq standard deﬁnitions. We exercised our approach on lemmas involving iterated partial derivatives and diﬀerentiation under the integral sign, that were missing from the formal proof of a numerical program solving the wave equation.},
	pages = {289--304},
	booktitle = {Certified Programs and Proofs},
	publisher = {Springer Berlin Heidelberg},
	author = {Boldo, Sylvie and Lelay, Catherine and Melquiond, Guillaume},
	editor = {Hawblitzel, Chris and Miller, Dale},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2019-02-01},
	date = {2012},
	langid = {english},
	doi = {10.1007/978-3-642-35308-6_22},
	file = {Boldo et al. - 2012 - Improving Real Analysis in Coq A User-Friendly Ap.pdf:/Users/richardford/Zotero/storage/4BBRWC9Y/Boldo et al. - 2012 - Improving Real Analysis in Coq A User-Friendly Ap.pdf:application/pdf}
}

@article{martin-dorel_proving_2016,
	title = {Proving Tight Bounds on Univariate Expressions with Elementary Functions in Coq},
	volume = {57},
	issn = {1573-0670},
	url = {https://doi.org/10.1007/s10817-015-9350-4},
	doi = {10.1007/s10817-015-9350-4},
	abstract = {The verification of floating-point mathematical libraries requires computing numerical bounds on approximation errors. Due to the tightness of these bounds and the peculiar structure of approximation errors, such a verification is out of the reach of generic tools such as computer algebra systems. In fact, the inherent difficulty of computing such bounds often mandates a formal proof of them. In this paper, we present a tactic for the Coq proof assistant that is designed to automatically and formally prove bounds on univariate expressions. It is based on a formalization of floating-point and interval arithmetic, associated with an on-the-fly computation of Taylor expansions. All the computations are performed inside Coq’s logic, in a reflexive setting. This paper also compares our tactic with various existing tools on a large set of examples.},
	pages = {187--217},
	number = {3},
	journaltitle = {J Autom Reasoning},
	author = {Martin-Dorel, Érik and Melquiond, Guillaume},
	urldate = {2019-02-01},
	date = {2016-10-01},
	langid = {english},
	keywords = {Coq proof assistant, Decision procedure, Floating-point arithmetic, Formal proof, Interval arithmetic, Nonlinear arithmetic},
	file = {Submitted Version:/Users/richardford/Zotero/storage/VKBLSM3J/Martin-Dorel and Melquiond - 2016 - Proving Tight Bounds on Univariate Expressions wit.pdf:application/pdf}
}

@inproceedings{boldo_round-off_2017,
	location = {London, United Kingdom},
	title = {Round-off Error Analysis of Explicit One-Step Numerical Integration Methods},
	url = {https://hal.archives-ouvertes.fr/hal-01581794},
	doi = {10.1109/ARITH.2017.22},
	abstract = {Ordinary differential equations are ubiquitous in scientific computing. Solving exactly these equations is usually not possible, except for special cases, hence the use of numerical schemes to get a discretized solution. We are interested in such numerical integration methods, for instance Euler's method or the Runge-Kutta methods. As they are implemented using floating-point arithmetic, round-off errors occur. In order to guarantee their accuracy, we aim at providing bounds on the round-off errors of explicit one-step numerical integration methods. Our methodology is to apply a fine-grained analysis to these numerical algorithms. Our originality is that our floating-point analysis takes advantage of the linear stability of the scheme, a mathematical property that vouches the scheme is well-behaved.},
	booktitle = {24th {IEEE} Symposium on Computer Arithmetic},
	author = {Boldo, Sylvie and Faissole, Florian and Chapoutot, Alexandre},
	urldate = {2019-02-01},
	date = {2017-07},
	keywords = {Floating-Point, Numerical Integration, Ordinary Differential Equation, Round-Off Error, Runge-Kutta Methods, Stability},
	file = {HAL PDF Full Text:/Users/richardford/Zotero/storage/T6FAQZYN/Boldo et al. - 2017 - Round-off Error Analysis of Explicit One-Step Nume.pdf:application/pdf}
}

@unpublished{boldo_round-off_2018,
	title = {Round-off error and exceptional behavior analysis of explicit Runge-Kutta methods},
	url = {https://hal.archives-ouvertes.fr/hal-01883843},
	abstract = {Numerical integration schemes are mandatory to understand complex behaviors of dynamical systems described by ordinary differential equations. Implementation of these numerical methods involve floating-point computations and propagation of round-off errors. This paper presents a new fine-grained analysis of round-off errors in explicit Runge-Kutta integration methods, taking into account exceptional behaviors, such as underflow and overflow. Linear stability properties play a central role in the proposed approach. For a large class of Runge-Kutta methods applied on linear problems, a tight bound of the round-off errors is provided. A simple test is defined and ensures the absence of underflow and a tighter round-off error bound. The absence of overflow is guaranteed as linear stability properties imply that (computed) solutions are non-increasing.},
	author = {Boldo, Sylvie and Faissole, Florian and Chapoutot, Alexandre},
	urldate = {2019-02-01},
	date = {2018-09},
	keywords = {Linear stability, Numerical integration, Overflow, Round-off error, Runge-Kutta method, Underflow},
	file = {HAL PDF Full Text:/Users/richardford/Zotero/storage/STNM4VEB/Boldo et al. - 2018 - Round-off error and exceptional behavior analysis .pdf:application/pdf}
}

@article{immler_verified_2018,
	title = {A Verified {ODE} Solver and the Lorenz Attractor},
	volume = {61},
	issn = {1573-0670},
	url = {https://doi.org/10.1007/s10817-017-9448-y},
	doi = {10.1007/s10817-017-9448-y},
	abstract = {A rigorous numerical algorithm, formally verified with Isabelle/{HOL}, is used to certify the computations that Tucker used to prove chaos for the Lorenz attractor. The verification is based on a formalization of a diverse variety of mathematics and algorithms. Formalized mathematics include ordinary differential equations and Poincaré maps. Algorithms include low level approximation schemes based on Runge–Kutta methods and affine arithmetic. On a high level, reachability analysis is guided by static hybridization and adaptive step-size control and splitting. The algorithms are systematically refined towards an implementation that can be executed on Tucker’s original input data.},
	pages = {73--111},
	number = {1},
	journaltitle = {J Autom Reasoning},
	author = {Immler, Fabian},
	urldate = {2019-02-01},
	date = {2018-06-01},
	langid = {english},
	keywords = {Isabelle/{HOL}, Lorenz attractor, Ordinary differential equation, Poincaré map, Rigorous numerics},
	file = {Springer Full Text PDF:/Users/richardford/Zotero/storage/9487Y7HE/Immler - 2018 - A Verified ODE Solver and the Lorenz Attractor.pdf:application/pdf}
}

@misc{boldo_coquelicot:_2013,
	title = {Coquelicot: A User-Friendly Library of Real Analysis for Coq},
	url = {https://hal.inria.fr/hal-00860648/document},
	shorttitle = {Coquelicot},
	abstract = {Real analysis is pervasive to many applications, if only because it is a suitable tool for modeling physical or socio-economical systems. As such, its support is warranted in proof assistants, so that the users have a way to formally verify mathematical theorems and correctness of critical systems. The Coq system comes with an axiomatization of standard real numbers and a library of theorems on real analysis. Unfortunately, this standard library is lacking some widely used results. For instance, power series are not developed further than their definition. Moreover, the definitions of integrals and derivatives are based on dependent types, which make them especially cumbersome to use in practice. To palliate these inadequacies, we have designed a user-friendly library: Coquelicot. An easier way of writing formulas and theorem statements is achieved by relying on total functions in place of dependent types for limits, derivatives, integrals, power series, and so on. To help with the proof process, the library comes with a comprehensive set of theorems that cover not only these notions, but also some extensions such as parametric integrals, two-dimensional differentiability, asymptotic behaviors. It also offers some automations for performing differentiability proofs. Moreover, Coquelicot is a conservative extension of Coq's standard library and we provide correspondence theorems between the two libraries. We have exercised the library on several use cases: in an exam at university entry level, for the definitions and properties of Bessel functions, and for the solution of the one-dimensional wave equation.},
	author = {Boldo, Sylvie and Lelay, Catherine and Melquiond, Guillaume},
	urldate = {2019-02-01},
	date = {2013-09-10},
	langid = {english},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/WYXEI9GV/Boldo et al. - 2013 - Coquelicot A User-Friendly Library of Real Analys.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/FSB8NLLY/hal-00860648v1.html:text/html}
}

@article{boldo_formalization_2016,
	title = {Formalization of Real Analysis: A Survey of Proof Assistants and Libraries},
	volume = {26},
	url = {https://hal.inria.fr/hal-00806920/document},
	doi = {10.1017/S0960129514000437},
	shorttitle = {Formalization of Real Analysis},
	abstract = {In the recent years, numerous proof systems have improved enough to be used for formally verifying non-trivial mathematical results. They, however, have different purposes and it is not always easy to choose which one is adapted to undertake a formalization effort. In this survey, we focus on properties related to real analysis: real numbers, arithmetic operators, limits, differentiability, integrability, and so on. We have chosen to look into the formalizations provided in standard by the following systems: Coq, {HOL}4, {HOL} Light, Isabelle/{HOL}, Mizar, {ProofPower}-{HOL}, and {PVS}. We have also accounted for large developments that play a similar role or extend standard libraries: {ACL}2(r) for {ACL}2, C-{CoRN}/{MathClasses} for Coq, and the {NASA} {PVS} library. This survey presents how real numbers have been defined in these various provers and how the notions of real analysis described above have been formalized. We also look at the methods of automation these systems provide for real analysis.},
	pages = {1196--1233},
	number = {7},
	journaltitle = {Mathematical Structures in Computer Science},
	author = {Boldo, Sylvie and Lelay, Catherine and Melquiond, Guillaume},
	urldate = {2019-02-01},
	date = {2016-10},
	langid = {english},
	file = {Full Text PDF:/Users/richardford/Zotero/storage/LKG9S93Z/Boldo et al. - 2016 - Formalization of Real Analysis A Survey of Proof .pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/6E5738FR/hal-00806920v2.html:text/html}
}

@inproceedings{holzl_type_2013,
	title = {Type Classes and Filters for Mathematical Analysis in Isabelle/{HOL}},
	isbn = {978-3-642-39634-2},
	series = {Lecture Notes in Computer Science},
	abstract = {The theory of analysis in Isabelle/{HOL} derives from earlier formalizations that were limited to specific concrete types: ℝ, ℂ and ℝ n . Isabelle’s new analysis theory unifies and generalizes these earlier efforts. The improvements are centered on two primary contributions: a generic theory of limits based on filters, and a new hierarchy of type classes that includes various topological, metric, vector, and algebraic spaces. These let us apply many results in multivariate analysis to types which are not Euclidean spaces, such as the extended real numbers, bounded continuous functions, or finite maps.},
	pages = {279--294},
	booktitle = {Interactive Theorem Proving},
	publisher = {Springer Berlin Heidelberg},
	author = {Hölzl, Johannes and Immler, Fabian and Huffman, Brian},
	editor = {Blazy, Sandrine and Paulin-Mohring, Christine and Pichardie, David},
	date = {2013},
	langid = {english},
	keywords = {Euclidean vector spaces, Filters, Isabelle/{HOL}, Limits, Mathematical analysis, Topology, Type classes},
	file = {Hölzl et al. - 2013 - Type Classes and Filters for Mathematical Analysis.pdf:/Users/richardford/Zotero/storage/PAGHJGKC/Hölzl et al. - 2013 - Type Classes and Filters for Mathematical Analysis.pdf:application/pdf}
}

@article{krebbers_type_2011,
	title = {Type classes for efficient exact real arithmetic in Coq},
	url = {http://arxiv.org/abs/1106.3448},
	doi = {10.2168/LMCS-9(1:01)2013},
	abstract = {Floating point operations are fast, but require continuous effort on the part of the user in order to ensure that the results are correct. This burden can be shifted away from the user by providing a library of exact analysis in which the computer handles the error estimates. Previously, we [Krebbers/Spitters 2011] provided a fast implementation of the exact real numbers in the Coq proof assistant. Our implementation improved on an earlier implementation by O'Connor by using type classes to describe an abstract specification of the underlying dense set from which the real numbers are built. In particular, we used dyadic rationals built from Coq's machine integers to obtain a 100 times speed up of the basic operations already. This article is a substantially expanded version of [Krebbers/Spitters 2011] in which the implementation is extended in the various ways. First, we implement and verify the sine and cosine function. Secondly, we create an additional implementation of the dense set based on Coq's fast rational numbers. Thirdly, we extend the hierarchy to capture order on undecidable structures, while it was limited to decidable structures before. This hierarchy, based on type classes, allows us to share theory on the naturals, integers, rationals, dyadics, and reals in a convenient way. Finally, we obtain another dramatic speed-up by avoiding evaluation of termination proofs at runtime.},
	journaltitle = {{arXiv}:1106.3448 [cs, math]},
	author = {Krebbers, Robbert and Spitters, Bas},
	urldate = {2019-02-01},
	date = {2011-06-17},
	eprinttype = {arxiv},
	eprint = {1106.3448},
	keywords = {Computer Science - Logic in Computer Science, D.2.4, F.4.1, G.1, Mathematics - Numerical Analysis},
	file = {arXiv\:1106.3448 PDF:/Users/richardford/Zotero/storage/2LLH7TZN/Krebbers and Spitters - 2011 - Type classes for efficient exact real arithmetic i.pdf:application/pdf;arXiv.org Snapshot:/Users/richardford/Zotero/storage/489A4YCS/1106.html:text/html}
}

@article{shrobe_trust-management_2009,
	title = {Trust-Management, Intrusion-Tolerance, Accountability, and Reconstitution Architecture ({TIARA})},
	url = {https://apps.dtic.mil/dtic/tr/fulltext/u2/a511350.pdf},
	abstract = {This report describes the Trust-management, Intrusion-tolerance, Accountability, and Reconstitution Architecture ({TIARA}) system,
a broad design effort including novel computer architecture, operating system and application middleware. {TIARA} illustrates that a
highly secure computer system can be designed without sacrificing performance. {TIARA} involves three major sub-efforts: A
hardware security tagged architecture ({STA}) that tags each word of the computer’s memory with metadata such as the data type and
compartment of the data. The {STA} hardware enforces access rules controlling which principals are allowed to perform which
operations on which data. This allows the construction of a novel Zero-kernel Operating System ({ZKOS}) that has no single all
privileged kernel and that provides strong guarantees against penetration. Finally {TIARA} provides a level of application middleware
that enforces architectural level constraints and maintains the provenance of application data. All common exploits are preventable
by the {TIARA} architecture and this incurs only a minor increase in chip area.},
	pages = {133},
	issue = {{AFRL}-{RI}-{RS}-{TR}-2009-271},
	author = {Shrobe, Howard and {DeHon}, Andre and Knight, Thomas},
	date = {2009-12},
	langid = {english},
	file = {Trust-Management, Intrusion-Tolerance, Accountabil.pdf:/Users/richardford/Zotero/storage/QA4ZCYDJ/Trust-Management, Intrusion-Tolerance, Accountabil.pdf:application/pdf}
}

@inproceedings{azevedo_de_amorim_verified_2014,
	location = {New York, {NY}, {USA}},
	title = {A Verified Information-flow Architecture},
	isbn = {978-1-4503-2544-8},
	url = {http://doi.acm.org/10.1145/2535838.2535839},
	doi = {10.1145/2535838.2535839},
	series = {{POPL} '14},
	abstract = {{SAFE} is a clean-slate design for a highly secure computer system, with pervasive mechanisms for tracking and limiting information flows. At the lowest level, the {SAFE} hardware supports fine-grained programmable tags, with efficient and flexible propagation and combination of tags as instructions are executed. The operating system virtualizes these generic facilities to present an information-flow abstract machine that allows user programs to label sensitive data with rich confidentiality policies. We present a formal, machine-checked model of the key hardware and software mechanisms used to control information flow in {SAFE} and an end-to-end proof of noninterference for this model.},
	pages = {165--178},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Azevedo de Amorim, Arthur and Collins, Nathan and {DeHon}, André and Demange, Delphine and Hriţcu, Cătălin and Pichardie, David and Pierce, Benjamin C. and Pollack, Randy and Tolmach, Andrew},
	urldate = {2019-02-01},
	date = {2014},
	keywords = {clean-slate design, formal verification, information-flow control, refinement, security, tagged architecture},
	file = {ACM Full Text PDF:/Users/richardford/Zotero/storage/9CDWT8UT/Azevedo de Amorim et al. - 2014 - A Verified Information-flow Architecture.pdf:application/pdf}
}

@book{amorim_verified_2013,
	title = {A Verified Information-Flow Architecture (Long version)},
	abstract = {{SAFE} is a clean-slate effort to build a highly secure computer system, including pervasive mechanisms for tracking and limiting information flows. At the lowest level, the {SAFE} hardware supports fine-grained programmable tags, with efficient and flexible propagation and combination of tags as instructions are executed. The operating system virtualizes these generic facilities to present an information-flow abstract machine, on which user programs can label sensitive data with rich confidentiality and integrity policies. We present a formal, machine-checked model of the key information-flow mechanisms of the {SAFE} hardware and software, together with an end-to-end proof of noninterference for this model.},
	author = {Amorim, Arthur Azevedo de and Collins, Nathan and {DeHon}, André and Demange, Delphine and Hritcu, Cătălin and Pichardie, David and Pierce, Benjamin C. and Pollack, Randy and Tolmach, Andrew},
	date = {2013},
	file = {Citeseer - Full Text PDF:/Users/richardford/Zotero/storage/2YMYHR23/Amorim et al. - 2013 - A Verified Information-Flow Architecture (Long ver.pdf:application/pdf;Citeseer - Snapshot:/Users/richardford/Zotero/storage/M7W2QFG9/summary.html:text/html}
}

@book{andrew_oracle_2008,
	title = {Oracle Semantics Aquinas Hobor},
	abstract = {We define a Concurrent Separation Logic with first-class locks and threads for the C language, and prove its soundness in Coq with re-spect to a compilable operataional semantics. We define the language Concurrent C minor, an extension of the C minor language of Leroy. C minor was designed as the highest-level intermediate language in the {CompCert} certified {ANSI} C compiler, and we add to it lock, unlock, and fork statements to make Concurrent C minor, giving it a standard Pthreads style of concurrency. We define a Concurrent Separation Logic for Concurrent C minor, which extends the original Concurrent Separation Logic of O’Hearn to handle first-class locks and threads. We then prove the soundness of the logic with respect to the opera-tional semantics of the language. First, we define an erased concurrent operational semantics for Concurrent C minor that is a reasonable ab-},
	author = {Andrew, Advisor},
	date = {2008},
	file = {Citeseer - Full Text PDF:/Users/richardford/Zotero/storage/KI5U9GHB/Andrew - 2008 - Oracle Semantics Aquinas Hobor.pdf:application/pdf;Citeseer - Snapshot:/Users/richardford/Zotero/storage/G77WVBCV/summary.html:text/html}
}

@inproceedings{berdine_smallfoot:_2006,
	title = {Smallfoot: Modular Automatic Assertion Checking with Separation Logic},
	isbn = {978-3-540-36750-5},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Smallfoot},
	abstract = {Separation logic is a program logic for reasoning about programs that manipulate pointer data structures. We describe Smallfoot, a tool for checking certain lightweight separation logic specifications. The assertions describe the shapes of data structures rather than their detailed contents, and this allows reasoning to be fully automatic. The presentation in the paper is tutorial in style. We illustrate what the tool can do via examples which are oriented toward novel aspects of separation logic, namely: avoidance of frame axioms (which say what a procedure does not change); embracement of “dirty” features such as memory disposal and address arithmetic; information hiding in the presence of pointers; and modular reasoning about concurrent programs.},
	pages = {115--137},
	booktitle = {Formal Methods for Components and Objects},
	publisher = {Springer Berlin Heidelberg},
	author = {Berdine, Josh and Calcagno, Cristiano and O’Hearn, Peter W.},
	editor = {de Boer, Frank S. and Bonsangue, Marcello M. and Graf, Susanne and de Roever, Willem-Paul},
	date = {2006},
	langid = {english},
	keywords = {Free List, Information Hiding, Separation Logic, Symbolic Execution, Tree Predicate},
	file = {Berdine et al. - 2006 - Smallfoot Modular Automatic Assertion Checking wi.pdf:/Users/richardford/Zotero/storage/RU9SZ96Q/Berdine et al. - 2006 - Smallfoot Modular Automatic Assertion Checking wi.pdf:application/pdf}
}

@incollection{ohearn_local_2001,
	title = {Local Reasoning about Programs that Alter Data Structures},
	isbn = {978-3-540-44802-0},
	series = {Lecture Notes in Computer Science},
	abstract = {We describe an extension of Hoare’s logic for reasoning about programs that alter data structures. We consider a low-level storage model based on a heap with associated lookup, update, allocation and deallocation operations, and unrestricted address arithmetic. The assertion language is based on a possible worlds model of the logic of bunched implications, and includes spatial conjunction and implication connectives alongside those of classical logic. Heap operations are axiomatized using what we call the “small axioms”, each of which mentions only those cells accessed by a particular command. Through these and a number of examples we show that the formalism supports local reasoning: A specification and proof can concentrate on only those cells in memory that a program accesses.This paper builds on earlier work by Burstall, Reynolds, Ishtiaq and O’Hearn on reasoning about data structures.},
	pages = {1--19},
	booktitle = {Computer Science Logic},
	publisher = {Springer Berlin Heidelberg},
	author = {O’Hearn, Peter and Reynolds, John and Yang, Hongseok},
	editor = {Fribourg, Laurent},
	date = {2001},
	langid = {english},
	keywords = {Frame Problem, Hoare Logic, Local Reasoning, Memory Fault, Weak Precondition},
	file = {O’Hearn et al. - 2001 - Local Reasoning about Programs that Alter Data Str.pdf:/Users/richardford/Zotero/storage/DSQLQ2IN/O’Hearn et al. - 2001 - Local Reasoning about Programs that Alter Data Str.pdf:application/pdf;O’Hearn et al. - 2001 - Local Reasoning about Programs that Alter Data Str.pdf:/Users/richardford/Zotero/storage/EFFA7GBR/O’Hearn et al. - 2001 - Local Reasoning about Programs that Alter Data Str.pdf:application/pdf}
}

@incollection{hermanns_local_2006,
	location = {Berlin, Heidelberg},
	title = {A Local Shape Analysis Based on Separation Logic},
	volume = {3920},
	isbn = {978-3-540-33056-1 978-3-540-33057-8},
	url = {http://link.springer.com/10.1007/11691372_19},
	abstract = {We describe a program analysis for linked list programs where the abstract domain uses formulae from separation logic.},
	pages = {287--302},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Distefano, Dino and O’Hearn, Peter W. and Yang, Hongseok},
	editor = {Hermanns, Holger and Palsberg, Jens},
	urldate = {2019-02-01},
	date = {2006},
	langid = {english},
	doi = {10.1007/11691372_19},
	file = {Distefano et al. - 2006 - A Local Shape Analysis Based on Separation Logic.pdf:/Users/richardford/Zotero/storage/SYDSVSRA/Distefano et al. - 2006 - A Local Shape Analysis Based on Separation Logic.pdf:application/pdf}
}

@online{calcagno_moving_nodate,
	title = {Moving Fast with Software Verification},
	url = {https://research.fb.com/publications/moving-fast-with-software-verification},
	abstract = {For organisations like Facebook, high quality software is important. However, the pace of change and increasing complexity of modern code makes it difficult to produce error free software. Available tools are often lacking in helping programmers develop more reliable and secure applications.},
	titleaddon = {Facebook Research},
	author = {Calcagno, Cristiano and Distefano, Dino and Dubreil, Jeremy and O'Hearn, Peter},
	urldate = {2019-02-01},
	langid = {american},
	file = {Moving Fast with Software Verification.pdf:/Users/richardford/Zotero/storage/5FPGIE6K/Moving Fast with Software Verification.pdf:application/pdf;Snapshot:/Users/richardford/Zotero/storage/FFZ2PSBG/moving-fast-with-software-verification.html:text/html}
}